(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/editor/main.js":[function(require,module,exports){
'use strict';

var amgui = require('./amgui');
var EventEmitter = require('events').EventEmitter;
var Transhand = require('./transhand');
var Timeline = require('./timeline');
var Toolbar = require('./toolbar');
var Windooman = require('./windooman');
var Warehouseman = require('./warehouseman');
var Chronicler = require('./chronicler');
var DomPicker = require('./dom-picker');
var Mouse = require('./mouse');
var dialogFeatureDoesntExits = require('./commonDialogs/dialogFeatureDoesntExits');
var dialogFeedback = require('./commonDialogs/dialogFeedback');
var modules = {
    css: require('./modules/css'),
    js: require('./modules/javascript')
};
var externalStylesheets = [
    // require('./assets/fontello/css/amgui.css'),
    require('./am.css'),
];

var isInited = false, handlerBuff = [];


var am = window.am = module.exports = _.extend(new EventEmitter(), {

    sequenceTypes: {},

    selectedElement: undefined,

    registerSequenceType: function (Sequence, type) {

        this.sequenceTypes[type] = Sequence;
    }
});

am.getHandler = function () {

    if (handlerBuff.length) {

        return handlerBuff.pop();
    }
    else {
        return new Transhand();
    }
};

am.throwHandler = function (handler) {

    handlerBuff.push(handler);
};

am.open = function (save) {

    if (!window.chrome) {
    
        return alertUnsupportedBrowsers();
    }

    am._init();

    if (save) {

        if (typeof(save) === 'string') {

            save = JSON.parse(save);
        }

        am.timeline.useSave(save);
    }
};

am._init = function () {

    if (isInited) return;
    
    am.dialogs = {
        featureDoesntExist: dialogFeatureDoesntExits,
        feedback: dialogFeedback,
    };

    am.workspace = new Windooman();
    am.workspace.loadWorkspaces({
        base: getBaseWorkspace()
    });
    am.workspace.load('base');

    am.mouse = new Mouse();

    am.storage = new Warehouseman();

    am.domElem = createAmRoot();
    am.deHandlerCont = createAmLayer();
    am.deGuiCont = createAmLayer();
    am.deDialogCont = createAmLayer();


    amgui.deOverlayCont = am.deDialogCont;

    am.deGuiCont.appendChild(am.workspace.domElem);

    am.deRoot = document.body;
    am.history = new Chronicler();
    am.toolbar = new Toolbar();
    am.timeline = new Timeline();
    am.domPicker = new DomPicker();

    am.workspace.fillTab('tools', am.toolbar.domElem);

    am.deHandlerCont.appendChild(am.domPicker.domElem);
    am.domPicker.on('pick', onSelectWithDomPicker);

    am.toolbar.addIcon({
        tooltip: 'undo',
        icon: 'ccw',
        onClick: am.history.undo.bind(am.history)
    });

    am.toolbar.addIcon({
        tooltip: 'redo',
        icon: 'cw',
        onClick: am.history.redo.bind(am.history)
    });


    am.toolbar.addIcon({
        tooltip: 'feedback',
        icon: 'megaphone',
        separator: 'rest',
        onClick: function () {
            am.dialogs.feedback.show();
        }
    });



    am.timeline.domElem.style.position = 'fixed';
    am.timeline.domElem.style.width = '100%';
    am.timeline.domElem.style.height = '230px';
    am.timeline.domElem.style.bottom = '0px';
    am.workspace.fillTab('timeline', am.timeline.domElem);

    addToggleGui();

    document.body.addEventListener('click', onClickRoot);

    Object.keys(modules).forEach(function (moduleName) {

        console.log('init', moduleName, 'module...');

        modules[moduleName].init(am);
    });

    createMenu();
    createStatusLabel();
};

function createMenu() {
    
    var iconMenu = am.toolbar.addIcon({
        tooltip: 'file',
        icon: 'menu',
        separator: 'global',
    });

    amgui.bindDropdown({
        deTarget: iconMenu,
        deMenu: amgui.createDropdown({
            options: [
                {text: 'new', onSelect: onSelectNew},
                {text: 'save', onSelect: onSelectSave},
                {text: 'saveAs', onSelect: onSelectSave},
                {text: 'open', onSelect: onSelectOpen},
            ]
        })
    });

    function onSelectNew() {

        am.timeline.clear();
    }

    function onSelectSave() {

        am.storage.showSaveDialog({

            getSave: function () {
                
                var opt = am.storage.getSaveOptions();

                return am.timeline.getScript(opt);
            }
        });
    }

    function onSelectOpen() {

        am.storage.showOpenDialog({

            onOpen: function (save) {

                console.log(save);

                am.timeline.clear();
                am.timeline.useSave(save);
            }
        });
    }
}

function onClickRoot(e) {

    if (am.isPickableDomElem(e.target)) {
        
        if (e.target !== am.selectedElement) {//hack!
            
            am.domPicker.focusElem(e.target);
        }
    }
    else {
        setSelectedElement(undefined);
    }
}

function onSelectWithDomPicker(de) {

    setSelectedElement(de);
}

function setSelectedElement(de) {

    if (am.selectedElement !== de) {

        am.selectedElement = de;
        am.emit('selectDomElement', am.selectedElement);
    }
}

am.isPickableDomElem = function (deTest) {
    //TODO use .compareDocumentPosition()
    if (!deTest) {
        return false;
    }

    return step(deTest);

    function step(de) {

        if (!de) {
            return false;
        }
        else if (de.nodeType === 9) {
            return false;
        }
        else if (de.hasAttribute('data-am-pick')) {
            return true;
        }
        else if (de.hasAttribute('data-am-nopick')) {
            return false;
        }
        else if (de === document.body) {
            return de !== deTest;
        }
        else if (de) {
            return step(de.parentNode);
        }
    }
};

function createAmRoot() {

    // $('body').css('opacity', .23)
        // .mouseenter(function () {$('body').css('opacity', 1)})
        // .mouseleave(function () {$('body').css('opacity', .23)});
    
    var de = document.createElement('div');
    de.style.position = 'fixed';
    de.style.left = '0px';
    de.style.top = '0px';
    de.style.width = '100%';
    de.style.height = '100%';
    de.style.pointerEvents = 'none';
    de.style.userSelect = 'none';
    de.style.webktUserSelect = 'none';
    de.style.fontFamily = amgui.FONT_FAMILY;
    de.style.color = amgui.color.text;

    de.setAttribute('data-am-nopick', '');

    var zIndex = getMaxZIndex();
    if (zIndex) {
        de.style.zIndex = zIndex + 1000;
    }

    document.body.appendChild(de);

    var sr = de.createShadowRoot();
        
    sr.appendChild(amgui.getStyleSheet());

    externalStylesheets.forEach(function (css) {

        var style = document.createElement('style');
        style.innerHTML = css;
        //TODO
        sr.appendChild(style);
        // document.head.appendChild(style);
    });

    return sr;
    // return de;
}

function addToggleGui() {

    am.toolbar.addIcon({
        tooltip: 'show/hide editor',
        icon: 'resize-small',
        separator: 'first',
        onClick: function () {

            am.deGuiCont.style.display = 'none';
            
            document.body.appendChild(btnFull);

            var zIndex = getMaxZIndex();
            if (zIndex) {
                btnFull.style.zIndex = zIndex + 1000;
            }
        }
    });

    var btnFull = amgui.createIconBtn({
        width: 32,
        height: 32,
        fontSize: '32px',
        icon: 'resize-full',
        tooltip: 'show editor',
        onClick: function () {
            
            am.deGuiCont.style.display = 'block';
            btnFull.parentElement.removeChild(btnFull);
        }
    });

    btnFull.style.top = '0px';
    btnFull.style.left = '0px';
    btnFull.style.position = 'fixed';
}

function createAmLayer() {

    var de = document.createElement('div');
    de.style.position = 'fixed';
    de.style.width = '100%';
    de.style.height = '100%';
    de.setAttribute('data-am-nopick', '');
    am.domElem.appendChild(de);
    return de;
}




function getMaxZIndex() {

    var zIndex = 0, els, x, xLen, el, val;

    els = document.querySelectorAll('*');
    for (x = 0, xLen = els.length; x < xLen; x += 1) {
      el = els[x];
      if (window.getComputedStyle(el).getPropertyValue('position') !== 'static') {
        val = window.getComputedStyle(el).getPropertyValue('z-index');
        if (val) {
          val = +val;
          if (val > zIndex) {
            zIndex = val;
          }
        }
      }
    }
    return zIndex;    
}


function getBaseWorkspace() {

    return {
        type: 'container',
        direction: 'column',
        children: [{
                type: 'panel',
                size: 32,
                scaleMode: 'fix',
                noHead: false,
                tabs: [{name: 'tools'}],
            },{
                type: 'container',
                direction: 'row',
                size: 10,
                scaleMode: 'flex',
                children: [{                    
                    type: 'panel',
                    size: 3,
                    scaleMode: 'flex',
                    tabs: [
                        {name: 'Css Style'},
                        {name: 'Dom Tree'}
                    ]
                }, {                    
                    type: 'panel',
                    empty: true,
                    size: 12,
                    scaleMode: 'flex'
                }]
            }, {
                type: 'panel',
                size: 4,
                scaleMode: 'flex',
                noHead: false,
                tabs: [{name: 'timeline'}],
            }]
    };
}

function createStatusLabel() {

    var deTitle = amgui.createLabel({
        caption: 'Animachine (alpha)',
        parent: am.deDialogCont,
        position: 'fixed',
        fontSize: '18px'
    });

    deTitle.style.pointerEvents = 'none';
    deTitle.style.top = '32px';
    deTitle.style.left = '3px';
    deTitle.style.opacity = '0.23';
    deTitle.style.fontWeight = 'bold';
}

function alertUnsupportedBrowsers() {

    var deSorry = document.createElement('div');
    deSorry.textContent = 'Sorry, this demo is currently only supported by chrome. ';
    amgui.createIcon({icon: 'emo-unhappy', parent: deSorry, display: 'inline'});
    deSorry.style.display = 'fixed';
    deSorry.style.margin = 'auto';
    deSorry.style.fontFamily = amgui.FONT_FAMILY;
    deSorry.style.fontSize = '21px';
    deSorry.style.color = amgui.color.text;
    deSorry.style.background = amgui.color.overlay;
    deSorry.style.top = 0;
    deSorry.style.right = 0;
    deSorry.style.bottom = 0;
    deSorry.style.left = 0;
    document.body.innerHTML = '';
    document.body.appendChild(deSorry);
}

///polyfills
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(predicate) {
      if (this == null) {
        throw new TypeError('Array.prototype.find called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;

      for (var i = 0; i < length; i++) {
        if (i in list) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return value;
          }
        }
      }
      return undefined;
    }
  });
}
},{"./am.css":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\am.css","./amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./chronicler":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\chronicler\\Chronicler.js","./commonDialogs/dialogFeatureDoesntExits":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\commonDialogs\\dialogFeatureDoesntExits.js","./commonDialogs/dialogFeedback":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\commonDialogs\\dialogFeedback.js","./dom-picker":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\dom-picker\\DomPicker.js","./modules/css":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\cssModule.js","./modules/javascript":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\jsModule.js","./mouse":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\mouse\\Mouse.js","./timeline":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\Timeline.js","./toolbar":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\toolbar\\Toolbar.js","./transhand":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\transhand\\Transhand.js","./warehouseman":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\Warehouseman.js","./windooman":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Windooman.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\path-browserify\\index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\process\\browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\process\\browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\util\\support\\isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\util\\util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\util\\support\\isBufferBrowser.js","_process":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\process\\browser.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\lodash\\dist\\lodash.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map.js":[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\source-map-consumer.js","./source-map/source-map-generator":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\source-map-generator.js","./source-map/source-node":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\source-node.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\array-set.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\util.js","amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\base64-vlq.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\base64.js","amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\base64.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\binary-search.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\source-map-consumer.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping && mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\array-set.js","./base64-vlq":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\base64-vlq.js","./binary-search":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\binary-search.js","./util":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\util.js","amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\source-map-generator.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        if (!aSourceMapConsumer.file) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (aSourceMapPath) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\array-set.js","./base64-vlq":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\base64-vlq.js","./util":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\util.js","amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\source-node.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/g;

  // Matches a Windows-style newline, or any character.
  var REGEX_CHARACTER = /\r\n|[\s\S]/g;

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.match(REGEX_CHARACTER).forEach(function (ch, idx, array) {
        if (REGEX_NEWLINE.test(ch)) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === array.length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column += ch.length;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\source-map-generator.js","./util":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\util.js","amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map\\util.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js":[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules\\uglify-js\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js")
},{"_process":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\process\\browser.js","path":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\path-browserify\\index.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\tools\\node.js":[function(require,module,exports){
var sys = require("util");
var MOZ_SourceMap = require("source-map");
var UglifyJS = exports;
/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function array_to_hash(a) {
    var ret = Object.create(null);
    for (var i = 0; i < a.length; ++i)
        ret[a[i]] = true;
    return ret;
};

function slice(a, start) {
    return Array.prototype.slice.call(a, start || 0);
};

function characters(str) {
    return str.split("");
};

function member(name, array) {
    for (var i = array.length; --i >= 0;)
        if (array[i] == name)
            return true;
    return false;
};

function find_if(func, array) {
    for (var i = 0, n = array.length; i < n; ++i) {
        if (func(array[i]))
            return array[i];
    }
};

function repeat_string(str, i) {
    if (i <= 0) return "";
    if (i == 1) return str;
    var d = repeat_string(str, i >> 1);
    d += d;
    if (i & 1) d += str;
    return d;
};

function DefaultsError(msg, defs) {
    Error.call(this, msg);
    this.msg = msg;
    this.defs = defs;
};
DefaultsError.prototype = Object.create(Error.prototype);
DefaultsError.prototype.constructor = DefaultsError;

DefaultsError.croak = function(msg, defs) {
    throw new DefaultsError(msg, defs);
};

function defaults(args, defs, croak) {
    if (args === true)
        args = {};
    var ret = args || {};
    if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i))
        DefaultsError.croak("`" + i + "` is not a supported option", defs);
    for (var i in defs) if (defs.hasOwnProperty(i)) {
        ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];
    }
    return ret;
};

function merge(obj, ext) {
    for (var i in ext) if (ext.hasOwnProperty(i)) {
        obj[i] = ext[i];
    }
    return obj;
};

function noop() {};

var MAP = (function(){
    function MAP(a, f, backwards) {
        var ret = [], top = [], i;
        function doit() {
            var val = f(a[i], i);
            var is_last = val instanceof Last;
            if (is_last) val = val.v;
            if (val instanceof AtTop) {
                val = val.v;
                if (val instanceof Splice) {
                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    top.push(val);
                }
            }
            else if (val !== skip) {
                if (val instanceof Splice) {
                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                } else {
                    ret.push(val);
                }
            }
            return is_last;
        };
        if (a instanceof Array) {
            if (backwards) {
                for (i = a.length; --i >= 0;) if (doit()) break;
                ret.reverse();
                top.reverse();
            } else {
                for (i = 0; i < a.length; ++i) if (doit()) break;
            }
        }
        else {
            for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;
        }
        return top.concat(ret);
    };
    MAP.at_top = function(val) { return new AtTop(val) };
    MAP.splice = function(val) { return new Splice(val) };
    MAP.last = function(val) { return new Last(val) };
    var skip = MAP.skip = {};
    function AtTop(val) { this.v = val };
    function Splice(val) { this.v = val };
    function Last(val) { this.v = val };
    return MAP;
})();

function push_uniq(array, el) {
    if (array.indexOf(el) < 0)
        array.push(el);
};

function string_template(text, props) {
    return text.replace(/\{(.+?)\}/g, function(str, p){
        return props[p];
    });
};

function remove(array, el) {
    for (var i = array.length; --i >= 0;) {
        if (array[i] === el) array.splice(i, 1);
    }
};

function mergeSort(array, cmp) {
    if (array.length < 2) return array.slice();
    function merge(a, b) {
        var r = [], ai = 0, bi = 0, i = 0;
        while (ai < a.length && bi < b.length) {
            cmp(a[ai], b[bi]) <= 0
                ? r[i++] = a[ai++]
                : r[i++] = b[bi++];
        }
        if (ai < a.length) r.push.apply(r, a.slice(ai));
        if (bi < b.length) r.push.apply(r, b.slice(bi));
        return r;
    };
    function _ms(a) {
        if (a.length <= 1)
            return a;
        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
        left = _ms(left);
        right = _ms(right);
        return merge(left, right);
    };
    return _ms(array);
};

function set_difference(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) < 0;
    });
};

function set_intersection(a, b) {
    return a.filter(function(el){
        return b.indexOf(el) >= 0;
    });
};

// this function is taken from Acorn [1], written by Marijn Haverbeke
// [1] https://github.com/marijnh/acorn
function makePredicate(words) {
    if (!(words instanceof Array)) words = words.split(" ");
    var f = "", cats = [];
    out: for (var i = 0; i < words.length; ++i) {
        for (var j = 0; j < cats.length; ++j)
            if (cats[j][0].length == words[i].length) {
                cats[j].push(words[i]);
                continue out;
            }
        cats.push([words[i]]);
    }
    function compareTo(arr) {
        if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
        f += "switch(str){";
        for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
        f += "return true}return false;";
    }
    // When there are more than three length categories, an outer
    // switch first dispatches on the lengths, to save on comparisons.
    if (cats.length > 3) {
        cats.sort(function(a, b) {return b.length - a.length;});
        f += "switch(str.length){";
        for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
        }
        f += "}";
        // Otherwise, simply generate a flat `switch` statement.
    } else {
        compareTo(words);
    }
    return new Function("str", f);
};

function all(array, predicate) {
    for (var i = array.length; --i >= 0;)
        if (!predicate(array[i]))
            return false;
    return true;
};

function Dictionary() {
    this._values = Object.create(null);
    this._size = 0;
};
Dictionary.prototype = {
    set: function(key, val) {
        if (!this.has(key)) ++this._size;
        this._values["$" + key] = val;
        return this;
    },
    add: function(key, val) {
        if (this.has(key)) {
            this.get(key).push(val);
        } else {
            this.set(key, [ val ]);
        }
        return this;
    },
    get: function(key) { return this._values["$" + key] },
    del: function(key) {
        if (this.has(key)) {
            --this._size;
            delete this._values["$" + key];
        }
        return this;
    },
    has: function(key) { return ("$" + key) in this._values },
    each: function(f) {
        for (var i in this._values)
            f(this._values[i], i.substr(1));
    },
    size: function() {
        return this._size;
    },
    map: function(f) {
        var ret = [];
        for (var i in this._values)
            ret.push(f(this._values[i], i.substr(1)));
        return ret;
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function DEFNODE(type, props, methods, base) {
    if (arguments.length < 4) base = AST_Node;
    if (!props) props = [];
    else props = props.split(/\s+/);
    var self_props = props;
    if (base && base.PROPS)
        props = props.concat(base.PROPS);
    var code = "return function AST_" + type + "(props){ if (props) { ";
    for (var i = props.length; --i >= 0;) {
        code += "this." + props[i] + " = props." + props[i] + ";";
    }
    var proto = base && new base;
    if (proto && proto.initialize || (methods && methods.initialize))
        code += "this.initialize();";
    code += "}}";
    var ctor = new Function(code)();
    if (proto) {
        ctor.prototype = proto;
        ctor.BASE = base;
    }
    if (base) base.SUBCLASSES.push(ctor);
    ctor.prototype.CTOR = ctor;
    ctor.PROPS = props || null;
    ctor.SELF_PROPS = self_props;
    ctor.SUBCLASSES = [];
    if (type) {
        ctor.prototype.TYPE = ctor.TYPE = type;
    }
    if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {
        if (/^\$/.test(i)) {
            ctor[i.substr(1)] = methods[i];
        } else {
            ctor.prototype[i] = methods[i];
        }
    }
    ctor.DEFMETHOD = function(name, method) {
        this.prototype[name] = method;
    };
    return ctor;
};

var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {
}, null);

var AST_Node = DEFNODE("Node", "start end", {
    clone: function() {
        return new this.CTOR(this);
    },
    $documentation: "Base class of all AST nodes",
    $propdoc: {
        start: "[AST_Token] The first token of this node",
        end: "[AST_Token] The last token of this node"
    },
    _walk: function(visitor) {
        return visitor._visit(this);
    },
    walk: function(visitor) {
        return this._walk(visitor); // not sure the indirection will be any help
    }
}, null);

AST_Node.warn_function = null;
AST_Node.warn = function(txt, props) {
    if (AST_Node.warn_function)
        AST_Node.warn_function(string_template(txt, props));
};

/* -----[ statements ]----- */

var AST_Statement = DEFNODE("Statement", null, {
    $documentation: "Base class of all statements",
});

var AST_Debugger = DEFNODE("Debugger", null, {
    $documentation: "Represents a debugger statement",
}, AST_Statement);

var AST_Directive = DEFNODE("Directive", "value scope", {
    $documentation: "Represents a directive, like \"use strict\";",
    $propdoc: {
        value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
        scope: "[AST_Scope/S] The scope that this directive affects"
    },
}, AST_Statement);

var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
        body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

function walk_body(node, visitor) {
    if (node.body instanceof AST_Statement) {
        node.body._walk(visitor);
    }
    else node.body.forEach(function(stat){
        stat._walk(visitor);
    });
};

var AST_Block = DEFNODE("Block", "body", {
    $documentation: "A body of statements (usually bracketed)",
    $propdoc: {
        body: "[AST_Statement*] an array of statements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
        });
    }
}, AST_Statement);

var AST_BlockStatement = DEFNODE("BlockStatement", null, {
    $documentation: "A block statement",
}, AST_Block);

var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
    $documentation: "The empty statement (empty block or simply a semicolon)",
    _walk: function(visitor) {
        return visitor._visit(this);
    }
}, AST_Statement);

var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
        body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.body._walk(visitor);
        });
    }
}, AST_Statement);

var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
        label: "[AST_Label] a label definition"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.label._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

var AST_IterationStatement = DEFNODE("IterationStatement", null, {
    $documentation: "Internal class.  All loops inherit from it."
}, AST_StatementWithBody);

var AST_DWLoop = DEFNODE("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
        condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_Do = DEFNODE("Do", null, {
    $documentation: "A `do` statement",
}, AST_DWLoop);

var AST_While = DEFNODE("While", null, {
    $documentation: "A `while` statement",
}, AST_DWLoop);

var AST_For = DEFNODE("For", "init condition step", {
    $documentation: "A `for` statement",
    $propdoc: {
        init: "[AST_Node?] the `for` initialization code, or null if empty",
        condition: "[AST_Node?] the `for` termination clause, or null if empty",
        step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.init) this.init._walk(visitor);
            if (this.condition) this.condition._walk(visitor);
            if (this.step) this.step._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_ForIn = DEFNODE("ForIn", "init name object", {
    $documentation: "A `for ... in` statement",
    $propdoc: {
        init: "[AST_Node] the `for/in` initialization code",
        name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
        object: "[AST_Node] the object that we're looping through"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.init._walk(visitor);
            this.object._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_IterationStatement);

var AST_With = DEFNODE("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
        expression: "[AST_Node] the `with` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.body._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ scope and functions ]----- */

var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
        directives: "[string*/S] an array of directives declared in this scope",
        variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        functions: "[Object/S] like `variables`, but only lists function declarations",
        uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
        uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
        parent_scope: "[AST_Scope?/S] link to the parent scope",
        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
        cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
    },
}, AST_Block);

var AST_Toplevel = DEFNODE("Toplevel", "globals", {
    $documentation: "The toplevel scope",
    $propdoc: {
        globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
    },
    wrap_enclose: function(arg_parameter_pairs) {
        var self = this;
        var args = [];
        var parameters = [];

        arg_parameter_pairs.forEach(function(pair) {
            var splitAt = pair.lastIndexOf(":");

            args.push(pair.substr(0, splitAt));
            parameters.push(pair.substr(splitAt + 1));
        });

        var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_Directive && node.value == "$ORIG") {
                return MAP.splice(self.body);
            }
        }));
        return wrapped_tl;
    },
    wrap_commonjs: function(name, export_all) {
        var self = this;
        var to_export = [];
        if (export_all) {
            self.figure_out_scope();
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_SymbolDeclaration && node.definition().global) {
                    if (!find_if(function(n){ return n.name == node.name }, to_export))
                        to_export.push(node);
                }
            }));
        }
        var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
        wrapped_tl = parse(wrapped_tl);
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
            if (node instanceof AST_SimpleStatement) {
                node = node.body;
                if (node instanceof AST_String) switch (node.getValue()) {
                  case "$ORIG":
                    return MAP.splice(self.body);
                  case "$EXPORTS":
                    var body = [];
                    to_export.forEach(function(sym){
                        body.push(new AST_SimpleStatement({
                            body: new AST_Assign({
                                left: new AST_Sub({
                                    expression: new AST_SymbolRef({ name: "exports" }),
                                    property: new AST_String({ value: sym.name }),
                                }),
                                operator: "=",
                                right: new AST_SymbolRef(sym),
                            }),
                        }));
                    });
                    return MAP.splice(body);
                }
            }
        }));
        return wrapped_tl;
    }
}, AST_Scope);

var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
    $documentation: "Base class for functions",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this function",
        argnames: "[AST_SymbolFunarg*] array of function arguments",
        uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            if (this.name) this.name._walk(visitor);
            this.argnames.forEach(function(arg){
                arg._walk(visitor);
            });
            walk_body(this, visitor);
        });
    }
}, AST_Scope);

var AST_Accessor = DEFNODE("Accessor", null, {
    $documentation: "A setter/getter function.  The `name` property is always null."
}, AST_Lambda);

var AST_Function = DEFNODE("Function", null, {
    $documentation: "A function expression"
}, AST_Lambda);

var AST_Defun = DEFNODE("Defun", null, {
    $documentation: "A function definition"
}, AST_Lambda);

/* -----[ JUMPS ]----- */

var AST_Jump = DEFNODE("Jump", null, {
    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
}, AST_Statement);

var AST_Exit = DEFNODE("Exit", "value", {
    $documentation: "Base class for “exits” (`return` and `throw`)",
    $propdoc: {
        value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.value && function(){
            this.value._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Return = DEFNODE("Return", null, {
    $documentation: "A `return` statement"
}, AST_Exit);

var AST_Throw = DEFNODE("Throw", null, {
    $documentation: "A `throw` statement"
}, AST_Exit);

var AST_LoopControl = DEFNODE("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
        label: "[AST_LabelRef?] the label, or null if none",
    },
    _walk: function(visitor) {
        return visitor._visit(this, this.label && function(){
            this.label._walk(visitor);
        });
    }
}, AST_Jump);

var AST_Break = DEFNODE("Break", null, {
    $documentation: "A `break` statement"
}, AST_LoopControl);

var AST_Continue = DEFNODE("Continue", null, {
    $documentation: "A `continue` statement"
}, AST_LoopControl);

/* -----[ IF ]----- */

var AST_If = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
        condition: "[AST_Node] the `if` condition",
        alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.body._walk(visitor);
            if (this.alternative) this.alternative._walk(visitor);
        });
    }
}, AST_StatementWithBody);

/* -----[ SWITCH ]----- */

var AST_Switch = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
        expression: "[AST_Node] the `switch` “discriminant”"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches",
}, AST_Block);

var AST_Default = DEFNODE("Default", null, {
    $documentation: "A `default` switch branch",
}, AST_SwitchBranch);

var AST_Case = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
        expression: "[AST_Node] the `case` expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_SwitchBranch);

/* -----[ EXCEPTIONS ]----- */

var AST_Try = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
        bcatch: "[AST_Catch?] the catch block, or null if not present",
        bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            walk_body(this, visitor);
            if (this.bcatch) this.bcatch._walk(visitor);
            if (this.bfinally) this.bfinally._walk(visitor);
        });
    }
}, AST_Block);

var AST_Catch = DEFNODE("Catch", "argname", {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
        argname: "[AST_SymbolCatch] symbol for the exception"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.argname._walk(visitor);
            walk_body(this, visitor);
        });
    }
}, AST_Block);

var AST_Finally = DEFNODE("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block);

/* -----[ VAR/CONST ]----- */

var AST_Definitions = DEFNODE("Definitions", "definitions", {
    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
    $propdoc: {
        definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.definitions.forEach(function(def){
                def._walk(visitor);
            });
        });
    }
}, AST_Statement);

var AST_Var = DEFNODE("Var", null, {
    $documentation: "A `var` statement"
}, AST_Definitions);

var AST_Const = DEFNODE("Const", null, {
    $documentation: "A `const` statement"
}, AST_Definitions);

var AST_VarDef = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
        name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
        value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.name._walk(visitor);
            if (this.value) this.value._walk(visitor);
        });
    }
});

/* -----[ OTHER ]----- */

var AST_Call = DEFNODE("Call", "expression args", {
    $documentation: "A function call expression",
    $propdoc: {
        expression: "[AST_Node] expression to invoke as function",
        args: "[AST_Node*] array of arguments"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.args.forEach(function(arg){
                arg._walk(visitor);
            });
        });
    }
});

var AST_New = DEFNODE("New", null, {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
}, AST_Call);

var AST_Seq = DEFNODE("Seq", "car cdr", {
    $documentation: "A sequence expression (two comma-separated expressions)",
    $propdoc: {
        car: "[AST_Node] first element in sequence",
        cdr: "[AST_Node] second element in sequence"
    },
    $cons: function(x, y) {
        var seq = new AST_Seq(x);
        seq.car = x;
        seq.cdr = y;
        return seq;
    },
    $from_array: function(array) {
        if (array.length == 0) return null;
        if (array.length == 1) return array[0].clone();
        var list = null;
        for (var i = array.length; --i >= 0;) {
            list = AST_Seq.cons(array[i], list);
        }
        var p = list;
        while (p) {
            if (p.cdr && !p.cdr.cdr) {
                p.cdr = p.cdr.car;
                break;
            }
            p = p.cdr;
        }
        return list;
    },
    to_array: function() {
        var p = this, a = [];
        while (p) {
            a.push(p.car);
            if (p.cdr && !(p.cdr instanceof AST_Seq)) {
                a.push(p.cdr);
                break;
            }
            p = p.cdr;
        }
        return a;
    },
    add: function(node) {
        var p = this;
        while (p) {
            if (!(p.cdr instanceof AST_Seq)) {
                var cell = AST_Seq.cons(p.cdr, node);
                return p.cdr = cell;
            }
            p = p.cdr;
        }
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.car._walk(visitor);
            if (this.cdr) this.cdr._walk(visitor);
        });
    }
});

var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
    $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
    $propdoc: {
        expression: "[AST_Node] the “container” expression",
        property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
    }
});

var AST_Dot = DEFNODE("Dot", null, {
    $documentation: "A dotted property access expression",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Sub = DEFNODE("Sub", null, {
    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
            this.property._walk(visitor);
        });
    }
}, AST_PropAccess);

var AST_Unary = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
        operator: "[string] the operator",
        expression: "[AST_Node] expression that this unary operator applies to"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.expression._walk(visitor);
        });
    }
});

var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary);

var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
}, AST_Unary);

var AST_Binary = DEFNODE("Binary", "left operator right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
        left: "[AST_Node] left-hand side expression",
        operator: "[string] the operator",
        right: "[AST_Node] right-hand side expression"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.left._walk(visitor);
            this.right._walk(visitor);
        });
    }
});

var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
        condition: "[AST_Node]",
        consequent: "[AST_Node]",
        alternative: "[AST_Node]"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.condition._walk(visitor);
            this.consequent._walk(visitor);
            this.alternative._walk(visitor);
        });
    }
});

var AST_Assign = DEFNODE("Assign", null, {
    $documentation: "An assignment expression — `a = b + 5`",
}, AST_Binary);

/* -----[ LITERALS ]----- */

var AST_Array = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
        elements: "[AST_Node*] array of elements"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.elements.forEach(function(el){
                el._walk(visitor);
            });
        });
    }
});

var AST_Object = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
        properties: "[AST_ObjectProperty*] array of properties"
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.properties.forEach(function(prop){
                prop._walk(visitor);
            });
        });
    }
});

var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
        key: "[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.",
        value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
    },
    _walk: function(visitor) {
        return visitor._visit(this, function(){
            this.value._walk(visitor);
        });
    }
});

var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
    $documentation: "A key: value object property",
}, AST_ObjectProperty);

var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
    $documentation: "An object setter property",
}, AST_ObjectProperty);

var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
    $documentation: "An object getter property",
}, AST_ObjectProperty);

var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
    $propdoc: {
        name: "[string] name of this symbol",
        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
        thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols",
});

var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
    $documentation: "The name of a property accessor (setter/getter function)"
}, AST_Symbol);

var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
    $propdoc: {
        init: "[AST_Node*/S] array of initializers for this declaration."
    }
}, AST_Symbol);

var AST_SymbolVar = DEFNODE("SymbolVar", null, {
    $documentation: "Symbol defining a variable",
}, AST_SymbolDeclaration);

var AST_SymbolConst = DEFNODE("SymbolConst", null, {
    $documentation: "A constant declaration"
}, AST_SymbolDeclaration);

var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
    $documentation: "Symbol naming a function argument",
}, AST_SymbolVar);

var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
    $documentation: "Symbol defining a function",
}, AST_SymbolDeclaration);

var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression",
}, AST_SymbolDeclaration);

var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch",
}, AST_SymbolDeclaration);

var AST_Label = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
        references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: function() {
        this.references = [];
        this.thedef = this;
    }
}, AST_Symbol);

var AST_SymbolRef = DEFNODE("SymbolRef", null, {
    $documentation: "Reference to some symbol (not definition/declaration)",
}, AST_Symbol);

var AST_LabelRef = DEFNODE("LabelRef", null, {
    $documentation: "Reference to a label symbol",
}, AST_Symbol);

var AST_This = DEFNODE("This", null, {
    $documentation: "The `this` symbol",
}, AST_Symbol);

var AST_Constant = DEFNODE("Constant", null, {
    $documentation: "Base class for all constants",
    getValue: function() {
        return this.value;
    }
});

var AST_String = DEFNODE("String", "value", {
    $documentation: "A string literal",
    $propdoc: {
        value: "[string] the contents of this string"
    }
}, AST_Constant);

var AST_Number = DEFNODE("Number", "value", {
    $documentation: "A number literal",
    $propdoc: {
        value: "[number] the numeric value"
    }
}, AST_Constant);

var AST_RegExp = DEFNODE("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
        value: "[RegExp] the actual regexp"
    }
}, AST_Constant);

var AST_Atom = DEFNODE("Atom", null, {
    $documentation: "Base class for atoms",
}, AST_Constant);

var AST_Null = DEFNODE("Null", null, {
    $documentation: "The `null` atom",
    value: null
}, AST_Atom);

var AST_NaN = DEFNODE("NaN", null, {
    $documentation: "The impossible value",
    value: 0/0
}, AST_Atom);

var AST_Undefined = DEFNODE("Undefined", null, {
    $documentation: "The `undefined` value",
    value: (function(){}())
}, AST_Atom);

var AST_Hole = DEFNODE("Hole", null, {
    $documentation: "A hole in an array",
    value: (function(){}())
}, AST_Atom);

var AST_Infinity = DEFNODE("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1/0
}, AST_Atom);

var AST_Boolean = DEFNODE("Boolean", null, {
    $documentation: "Base class for booleans",
}, AST_Atom);

var AST_False = DEFNODE("False", null, {
    $documentation: "The `false` atom",
    value: false
}, AST_Boolean);

var AST_True = DEFNODE("True", null, {
    $documentation: "The `true` atom",
    value: true
}, AST_Boolean);

/* -----[ TreeWalker ]----- */

function TreeWalker(callback) {
    this.visit = callback;
    this.stack = [];
};
TreeWalker.prototype = {
    _visit: function(node, descend) {
        this.stack.push(node);
        var ret = this.visit(node, descend ? function(){
            descend.call(node);
        } : noop);
        if (!ret && descend) {
            descend.call(node);
        }
        this.stack.pop();
        return ret;
    },
    parent: function(n) {
        return this.stack[this.stack.length - 2 - (n || 0)];
    },
    push: function (node) {
        this.stack.push(node);
    },
    pop: function() {
        return this.stack.pop();
    },
    self: function() {
        return this.stack[this.stack.length - 1];
    },
    find_parent: function(type) {
        var stack = this.stack;
        for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof type) return x;
        }
    },
    has_directive: function(type) {
        return this.find_parent(AST_Scope).has_directive(type);
    },
    in_boolean_context: function() {
        var stack = this.stack;
        var i = stack.length, self = stack[--i];
        while (i > 0) {
            var p = stack[--i];
            if ((p instanceof AST_If           && p.condition === self) ||
                (p instanceof AST_Conditional  && p.condition === self) ||
                (p instanceof AST_DWLoop       && p.condition === self) ||
                (p instanceof AST_For          && p.condition === self) ||
                (p instanceof AST_UnaryPrefix  && p.operator == "!" && p.expression === self))
            {
                return true;
            }
            if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||")))
                return false;
            self = p;
        }
    },
    loopcontrol_target: function(label) {
        var stack = this.stack;
        if (label) for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof AST_LabeledStatement && x.label.name == label.name) {
                return x.body;
            }
        } else for (var i = stack.length; --i >= 0;) {
            var x = stack[i];
            if (x instanceof AST_Switch || x instanceof AST_IterationStatement)
                return x;
        }
    }
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

var KEYWORDS = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with';
var KEYWORDS_ATOM = 'false null true';
var RESERVED_WORDS = 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield'
    + " " + KEYWORDS_ATOM + " " + KEYWORDS;
var KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case';

KEYWORDS = makePredicate(KEYWORDS);
RESERVED_WORDS = makePredicate(RESERVED_WORDS);
KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);

var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));

var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
var RE_OCT_NUMBER = /^0[0-7]+$/;
var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;

var OPERATORS = makePredicate([
    "in",
    "instanceof",
    "typeof",
    "new",
    "void",
    "delete",
    "++",
    "--",
    "+",
    "-",
    "!",
    "~",
    "&",
    "|",
    "^",
    "*",
    "/",
    "%",
    ">>",
    "<<",
    ">>>",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "?",
    "=",
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    ">>=",
    "<<=",
    ">>>=",
    "|=",
    "^=",
    "&=",
    "&&",
    "||"
]);

var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));

var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));

var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));

var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));

/* -----[ Tokenizer ]----- */

// regexps adapted from http://xregexp.com/plugins/#unicode
var UNICODE = {
    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
    non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
    space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
};

function is_letter(code) {
    return (code >= 97 && code <= 122)
        || (code >= 65 && code <= 90)
        || (code >= 0xaa && UNICODE.letter.test(String.fromCharCode(code)));
};

function is_digit(code) {
    return code >= 48 && code <= 57; //XXX: find out if "UnicodeDigit" means something else than 0..9
};

function is_alphanumeric_char(code) {
    return is_digit(code) || is_letter(code);
};

function is_unicode_combining_mark(ch) {
    return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
};

function is_unicode_connector_punctuation(ch) {
    return UNICODE.connector_punctuation.test(ch);
};

function is_identifier(name) {
    return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
};

function is_identifier_start(code) {
    return code == 36 || code == 95 || is_letter(code);
};

function is_identifier_char(ch) {
    var code = ch.charCodeAt(0);
    return is_identifier_start(code)
        || is_digit(code)
        || code == 8204 // \u200c: zero-width non-joiner <ZWNJ>
        || code == 8205 // \u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
        || is_unicode_combining_mark(ch)
        || is_unicode_connector_punctuation(ch)
    ;
};

function is_identifier_string(str){
    return /^[a-z_$][a-z0-9_$]*$/i.test(str);
};

function parse_js_number(num) {
    if (RE_HEX_NUMBER.test(num)) {
        return parseInt(num.substr(2), 16);
    } else if (RE_OCT_NUMBER.test(num)) {
        return parseInt(num.substr(1), 8);
    } else if (RE_DEC_NUMBER.test(num)) {
        return parseFloat(num);
    }
};

function JS_Parse_Error(message, line, col, pos) {
    this.message = message;
    this.line = line;
    this.col = col;
    this.pos = pos;
    this.stack = new Error().stack;
};

JS_Parse_Error.prototype.toString = function() {
    return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
};

function js_error(message, filename, line, col, pos) {
    throw new JS_Parse_Error(message, line, col, pos);
};

function is_token(token, type, val) {
    return token.type == type && (val == null || token.value == val);
};

var EX_EOF = {};

function tokenizer($TEXT, filename, html5_comments) {

    var S = {
        text            : $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ''),
        filename        : filename,
        pos             : 0,
        tokpos          : 0,
        line            : 1,
        tokline         : 0,
        col             : 0,
        tokcol          : 0,
        newline_before  : false,
        regex_allowed   : false,
        comments_before : []
    };

    function peek() { return S.text.charAt(S.pos); };

    function next(signal_eof, in_string) {
        var ch = S.text.charAt(S.pos++);
        if (signal_eof && !ch)
            throw EX_EOF;
        if (ch == "\n") {
            S.newline_before = S.newline_before || !in_string;
            ++S.line;
            S.col = 0;
        } else {
            ++S.col;
        }
        return ch;
    };

    function forward(i) {
        while (i-- > 0) next();
    };

    function looking_at(str) {
        return S.text.substr(S.pos, str.length) == str;
    };

    function find(what, signal_eof) {
        var pos = S.text.indexOf(what, S.pos);
        if (signal_eof && pos == -1) throw EX_EOF;
        return pos;
    };

    function start_token() {
        S.tokline = S.line;
        S.tokcol = S.col;
        S.tokpos = S.pos;
    };

    var prev_was_dot = false;
    function token(type, value, is_comment) {
        S.regex_allowed = ((type == "operator" && !UNARY_POSTFIX(value)) ||
                           (type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value)) ||
                           (type == "punc" && PUNC_BEFORE_EXPRESSION(value)));
        prev_was_dot = (type == "punc" && value == ".");
        var ret = {
            type   : type,
            value  : value,
            line   : S.tokline,
            col    : S.tokcol,
            pos    : S.tokpos,
            endpos : S.pos,
            nlb    : S.newline_before,
            file   : filename
        };
        if (!is_comment) {
            ret.comments_before = S.comments_before;
            S.comments_before = [];
            // make note of any newlines in the comments that came before
            for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
            }
        }
        S.newline_before = false;
        return new AST_Token(ret);
    };

    function skip_whitespace() {
        while (WHITESPACE_CHARS(peek()))
            next();
    };

    function read_while(pred) {
        var ret = "", ch, i = 0;
        while ((ch = peek()) && pred(ch, i++))
            ret += next();
        return ret;
    };

    function parse_error(err) {
        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
    };

    function read_num(prefix) {
        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
        var num = read_while(function(ch, i){
            var code = ch.charCodeAt(0);
            switch (code) {
              case 120: case 88: // xX
                return has_x ? false : (has_x = true);
              case 101: case 69: // eE
                return has_x ? true : has_e ? false : (has_e = after_e = true);
              case 45: // -
                return after_e || (i == 0 && !prefix);
              case 43: // +
                return after_e;
              case (after_e = false, 46): // .
                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;
            }
            return is_alphanumeric_char(code);
        });
        if (prefix) num = prefix + num;
        var valid = parse_js_number(num);
        if (!isNaN(valid)) {
            return token("num", valid);
        } else {
            parse_error("Invalid syntax: " + num);
        }
    };

    function read_escaped_char(in_string) {
        var ch = next(true, in_string);
        switch (ch.charCodeAt(0)) {
          case 110 : return "\n";
          case 114 : return "\r";
          case 116 : return "\t";
          case 98  : return "\b";
          case 118 : return "\u000b"; // \v
          case 102 : return "\f";
          case 48  : return "\0";
          case 120 : return String.fromCharCode(hex_bytes(2)); // \x
          case 117 : return String.fromCharCode(hex_bytes(4)); // \u
          case 10  : return ""; // newline
          default  : return ch;
        }
    };

    function hex_bytes(n) {
        var num = 0;
        for (; n > 0; --n) {
            var digit = parseInt(next(true), 16);
            if (isNaN(digit))
                parse_error("Invalid hex-character pattern in string");
            num = (num << 4) | digit;
        }
        return num;
    };

    var read_string = with_eof_error("Unterminated string constant", function(){
        var quote = next(), ret = "";
        for (;;) {
            var ch = next(true);
            if (ch == "\\") {
                // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                // https://github.com/mishoo/UglifyJS/issues/178
                var octal_len = 0, first = null;
                ch = read_while(function(ch){
                    if (ch >= "0" && ch <= "7") {
                        if (!first) {
                            first = ch;
                            return ++octal_len;
                        }
                        else if (first <= "3" && octal_len <= 2) return ++octal_len;
                        else if (first >= "4" && octal_len <= 1) return ++octal_len;
                    }
                    return false;
                });
                if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));
                else ch = read_escaped_char(true);
            }
            else if (ch == quote) break;
            ret += ch;
        }
        return token("string", ret);
    });

    function skip_line_comment(type) {
        var regex_allowed = S.regex_allowed;
        var i = find("\n"), ret;
        if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
        } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
        }
        S.comments_before.push(token(type, ret, true));
        S.regex_allowed = regex_allowed;
        return next_token();
    };

    var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function(){
        var regex_allowed = S.regex_allowed;
        var i = find("*/", true);
        var text = S.text.substring(S.pos, i);
        var a = text.split("\n"), n = a.length;
        // update stream position
        S.pos = i + 2;
        S.line += n - 1;
        if (n > 1) S.col = a[n - 1].length;
        else S.col += a[n - 1].length;
        S.col += 2;
        var nlb = S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
        S.comments_before.push(token("comment2", text, true));
        S.regex_allowed = regex_allowed;
        S.newline_before = nlb;
        return next_token();
    });

    function read_name() {
        var backslash = false, name = "", ch, escaped = false, hex;
        while ((ch = peek()) != null) {
            if (!backslash) {
                if (ch == "\\") escaped = backslash = true, next();
                else if (is_identifier_char(ch)) name += next();
                else break;
            }
            else {
                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                ch = read_escaped_char();
                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                name += ch;
                backslash = false;
            }
        }
        if (KEYWORDS(name) && escaped) {
            hex = name.charCodeAt(0).toString(16).toUpperCase();
            name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
        }
        return name;
    };

    var read_regexp = with_eof_error("Unterminated regular expression", function(regexp){
        var prev_backslash = false, ch, in_class = false;
        while ((ch = next(true))) if (prev_backslash) {
            regexp += "\\" + ch;
            prev_backslash = false;
        } else if (ch == "[") {
            in_class = true;
            regexp += ch;
        } else if (ch == "]" && in_class) {
            in_class = false;
            regexp += ch;
        } else if (ch == "/" && !in_class) {
            break;
        } else if (ch == "\\") {
            prev_backslash = true;
        } else {
            regexp += ch;
        }
        var mods = read_name();
        return token("regexp", new RegExp(regexp, mods));
    });

    function read_operator(prefix) {
        function grow(op) {
            if (!peek()) return op;
            var bigger = op + peek();
            if (OPERATORS(bigger)) {
                next();
                return grow(bigger);
            } else {
                return op;
            }
        };
        return token("operator", grow(prefix || next()));
    };

    function handle_slash() {
        next();
        switch (peek()) {
          case "/":
            next();
            return skip_line_comment("comment1");
          case "*":
            next();
            return skip_multiline_comment();
        }
        return S.regex_allowed ? read_regexp("") : read_operator("/");
    };

    function handle_dot() {
        next();
        return is_digit(peek().charCodeAt(0))
            ? read_num(".")
            : token("punc", ".");
    };

    function read_word() {
        var word = read_name();
        if (prev_was_dot) return token("name", word);
        return KEYWORDS_ATOM(word) ? token("atom", word)
            : !KEYWORDS(word) ? token("name", word)
            : OPERATORS(word) ? token("operator", word)
            : token("keyword", word);
    };

    function with_eof_error(eof_error, cont) {
        return function(x) {
            try {
                return cont(x);
            } catch(ex) {
                if (ex === EX_EOF) parse_error(eof_error);
                else throw ex;
            }
        };
    };

    function next_token(force_regexp) {
        if (force_regexp != null)
            return read_regexp(force_regexp);
        skip_whitespace();
        start_token();
        if (html5_comments) {
            if (looking_at("<!--")) {
                forward(4);
                return skip_line_comment("comment3");
            }
            if (looking_at("-->") && S.newline_before) {
                forward(3);
                return skip_line_comment("comment4");
            }
        }
        var ch = peek();
        if (!ch) return token("eof");
        var code = ch.charCodeAt(0);
        switch (code) {
          case 34: case 39: return read_string();
          case 46: return handle_dot();
          case 47: return handle_slash();
        }
        if (is_digit(code)) return read_num();
        if (PUNC_CHARS(ch)) return token("punc", next());
        if (OPERATOR_CHARS(ch)) return read_operator();
        if (code == 92 || is_identifier_start(code)) return read_word();
        parse_error("Unexpected character '" + ch + "'");
    };

    next_token.context = function(nc) {
        if (nc) S = nc;
        return S;
    };

    return next_token;

};

/* -----[ Parser (constants) ]----- */

var UNARY_PREFIX = makePredicate([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+"
]);

var UNARY_POSTFIX = makePredicate([ "--", "++" ]);

var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);

var PRECEDENCE = (function(a, ret){
    for (var i = 0; i < a.length; ++i) {
        var b = a[i];
        for (var j = 0; j < b.length; ++j) {
            ret[b[j]] = i + 1;
        }
    }
    return ret;
})(
    [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ],
    {}
);

var STATEMENTS_WITH_LABELS = array_to_hash([ "fo" + "r", "do", "while", "switch" ]);

var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);

/* -----[ Parser ]----- */

function parse($TEXT, options) {

    options = defaults(options, {
        strict         : false,
        filename       : null,
        toplevel       : null,
        expression     : false,
        html5_comments : true,
    });

    var S = {
        input         : (typeof $TEXT == "string"
                         ? tokenizer($TEXT, options.filename,
                                     options.html5_comments)
                         : $TEXT),
        token         : null,
        prev          : null,
        peeked        : null,
        in_function   : 0,
        in_directives : true,
        in_loop       : 0,
        labels        : []
    };

    S.token = next();

    function is(type, value) {
        return is_token(S.token, type, value);
    };

    function peek() { return S.peeked || (S.peeked = S.input()); };

    function next() {
        S.prev = S.token;
        if (S.peeked) {
            S.token = S.peeked;
            S.peeked = null;
        } else {
            S.token = S.input();
        }
        S.in_directives = S.in_directives && (
            S.token.type == "string" || is("punc", ";")
        );
        return S.token;
    };

    function prev() {
        return S.prev;
    };

    function croak(msg, line, col, pos) {
        var ctx = S.input.context();
        js_error(msg,
                 ctx.filename,
                 line != null ? line : ctx.tokline,
                 col != null ? col : ctx.tokcol,
                 pos != null ? pos : ctx.tokpos);
    };

    function token_error(token, msg) {
        croak(msg, token.line, token.col);
    };

    function unexpected(token) {
        if (token == null)
            token = S.token;
        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
    };

    function expect_token(type, val) {
        if (is(type, val)) {
            return next();
        }
        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");
    };

    function expect(punc) { return expect_token("punc", punc); };

    function can_insert_semicolon() {
        return !options.strict && (
            S.token.nlb || is("eof") || is("punc", "}")
        );
    };

    function semicolon() {
        if (is("punc", ";")) next();
        else if (!can_insert_semicolon()) unexpected();
    };

    function parenthesised() {
        expect("(");
        var exp = expression(true);
        expect(")");
        return exp;
    };

    function embed_tokens(parser) {
        return function() {
            var start = S.token;
            var expr = parser();
            var end = prev();
            expr.start = start;
            expr.end = end;
            return expr;
        };
    };

    function handle_regexp() {
        if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1)); // force regexp
        }
    };

    var statement = embed_tokens(function() {
        var tmp;
        handle_regexp();
        switch (S.token.type) {
          case "string":
            var dir = S.in_directives, stat = simple_statement();
            // XXXv2: decide how to fix directives
            if (dir && stat.body instanceof AST_String && !is("punc", ","))
                return new AST_Directive({ value: stat.body.value });
            return stat;
          case "num":
          case "regexp":
          case "operator":
          case "atom":
            return simple_statement();

          case "name":
            return is_token(peek(), "punc", ":")
                ? labeled_statement()
                : simple_statement();

          case "punc":
            switch (S.token.value) {
              case "{":
                return new AST_BlockStatement({
                    start : S.token,
                    body  : block_(),
                    end   : prev()
                });
              case "[":
              case "(":
                return simple_statement();
              case ";":
                next();
                return new AST_EmptyStatement();
              default:
                unexpected();
            }

          case "keyword":
            switch (tmp = S.token.value, next(), tmp) {
              case "break":
                return break_cont(AST_Break);

              case "continue":
                return break_cont(AST_Continue);

              case "debugger":
                semicolon();
                return new AST_Debugger();

              case "do":
                return new AST_Do({
                    body      : in_loop(statement),
                    condition : (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(), tmp)
                });

              case "while":
                return new AST_While({
                    condition : parenthesised(),
                    body      : in_loop(statement)
                });

              case "fo" + "r":
                return for_();

              case "function":
                return function_(AST_Defun);

              case "if":
                return if_();

              case "return":
                if (S.in_function == 0)
                    croak("'return' outside of function");
                return new AST_Return({
                    value: ( is("punc", ";")
                             ? (next(), null)
                             : can_insert_semicolon()
                             ? null
                             : (tmp = expression(true), semicolon(), tmp) )
                });

              case "switch":
                return new AST_Switch({
                    expression : parenthesised(),
                    body       : in_loop(switch_body_)
                });

              case "throw":
                if (S.token.nlb)
                    croak("Illegal newline after 'throw'");
                return new AST_Throw({
                    value: (tmp = expression(true), semicolon(), tmp)
                });

              case "try":
                return try_();

              case "var":
                return tmp = var_(), semicolon(), tmp;

              case "const":
                return tmp = const_(), semicolon(), tmp;

              case "with":
                return new AST_With({
                    expression : parenthesised(),
                    body       : statement()
                });

              default:
                unexpected();
            }
        }
    });

    function labeled_statement() {
        var label = as_symbol(AST_Label);
        if (find_if(function(l){ return l.name == label.name }, S.labels)) {
            // ECMA-262, 12.12: An ECMAScript program is considered
            // syntactically incorrect if it contains a
            // LabelledStatement that is enclosed by a
            // LabelledStatement with the same Identifier as label.
            croak("Label " + label.name + " defined twice");
        }
        expect(":");
        S.labels.push(label);
        var stat = statement();
        S.labels.pop();
        if (!(stat instanceof AST_IterationStatement)) {
            // check for `continue` that refers to this label.
            // those should be reported as syntax errors.
            // https://github.com/mishoo/UglifyJS2/issues/287
            label.references.forEach(function(ref){
                if (ref instanceof AST_Continue) {
                    ref = ref.label.start;
                    croak("Continue label `" + label.name + "` refers to non-IterationStatement.",
                          ref.line, ref.col, ref.pos);
                }
            });
        }
        return new AST_LabeledStatement({ body: stat, label: label });
    };

    function simple_statement(tmp) {
        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
    };

    function break_cont(type) {
        var label = null, ldef;
        if (!can_insert_semicolon()) {
            label = as_symbol(AST_LabelRef, true);
        }
        if (label != null) {
            ldef = find_if(function(l){ return l.name == label.name }, S.labels);
            if (!ldef)
                croak("Undefined label " + label.name);
            label.thedef = ldef;
        }
        else if (S.in_loop == 0)
            croak(type.TYPE + " not inside a loop or switch");
        semicolon();
        var stat = new type({ label: label });
        if (ldef) ldef.references.push(stat);
        return stat;
    };

    function for_() {
        expect("(");
        var init = null;
        if (!is("punc", ";")) {
            init = is("keyword", "var")
                ? (next(), var_(true))
                : expression(true, true);
            if (is("operator", "in")) {
                if (init instanceof AST_Var && init.definitions.length > 1)
                    croak("Only one variable declaration allowed in for..in loop");
                next();
                return for_in(init);
            }
        }
        return regular_for(init);
    };

    function regular_for(init) {
        expect(";");
        var test = is("punc", ";") ? null : expression(true);
        expect(";");
        var step = is("punc", ")") ? null : expression(true);
        expect(")");
        return new AST_For({
            init      : init,
            condition : test,
            step      : step,
            body      : in_loop(statement)
        });
    };

    function for_in(init) {
        var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
        var obj = expression(true);
        expect(")");
        return new AST_ForIn({
            init   : init,
            name   : lhs,
            object : obj,
            body   : in_loop(statement)
        });
    };

    var function_ = function(ctor) {
        var in_statement = ctor === AST_Defun;
        var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
        if (in_statement && !name)
            unexpected();
        expect("(");
        return new ctor({
            name: name,
            argnames: (function(first, a){
                while (!is("punc", ")")) {
                    if (first) first = false; else expect(",");
                    a.push(as_symbol(AST_SymbolFunarg));
                }
                next();
                return a;
            })(true, []),
            body: (function(loop, labels){
                ++S.in_function;
                S.in_directives = true;
                S.in_loop = 0;
                S.labels = [];
                var a = block_();
                --S.in_function;
                S.in_loop = loop;
                S.labels = labels;
                return a;
            })(S.in_loop, S.labels)
        });
    };

    function if_() {
        var cond = parenthesised(), body = statement(), belse = null;
        if (is("keyword", "else")) {
            next();
            belse = statement();
        }
        return new AST_If({
            condition   : cond,
            body        : body,
            alternative : belse
        });
    };

    function block_() {
        expect("{");
        var a = [];
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            a.push(statement());
        }
        next();
        return a;
    };

    function switch_body_() {
        expect("{");
        var a = [], cur = null, branch = null, tmp;
        while (!is("punc", "}")) {
            if (is("eof")) unexpected();
            if (is("keyword", "case")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Case({
                    start      : (tmp = S.token, next(), tmp),
                    expression : expression(true),
                    body       : cur
                });
                a.push(branch);
                expect(":");
            }
            else if (is("keyword", "default")) {
                if (branch) branch.end = prev();
                cur = [];
                branch = new AST_Default({
                    start : (tmp = S.token, next(), expect(":"), tmp),
                    body  : cur
                });
                a.push(branch);
            }
            else {
                if (!cur) unexpected();
                cur.push(statement());
            }
        }
        if (branch) branch.end = prev();
        next();
        return a;
    };

    function try_() {
        var body = block_(), bcatch = null, bfinally = null;
        if (is("keyword", "catch")) {
            var start = S.token;
            next();
            expect("(");
            var name = as_symbol(AST_SymbolCatch);
            expect(")");
            bcatch = new AST_Catch({
                start   : start,
                argname : name,
                body    : block_(),
                end     : prev()
            });
        }
        if (is("keyword", "finally")) {
            var start = S.token;
            next();
            bfinally = new AST_Finally({
                start : start,
                body  : block_(),
                end   : prev()
            });
        }
        if (!bcatch && !bfinally)
            croak("Missing catch/finally blocks");
        return new AST_Try({
            body     : body,
            bcatch   : bcatch,
            bfinally : bfinally
        });
    };

    function vardefs(no_in, in_const) {
        var a = [];
        for (;;) {
            a.push(new AST_VarDef({
                start : S.token,
                name  : as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
                value : is("operator", "=") ? (next(), expression(false, no_in)) : null,
                end   : prev()
            }));
            if (!is("punc", ","))
                break;
            next();
        }
        return a;
    };

    var var_ = function(no_in) {
        return new AST_Var({
            start       : prev(),
            definitions : vardefs(no_in, false),
            end         : prev()
        });
    };

    var const_ = function() {
        return new AST_Const({
            start       : prev(),
            definitions : vardefs(false, true),
            end         : prev()
        });
    };

    var new_ = function() {
        var start = S.token;
        expect_token("operator", "new");
        var newexp = expr_atom(false), args;
        if (is("punc", "(")) {
            next();
            args = expr_list(")");
        } else {
            args = [];
        }
        return subscripts(new AST_New({
            start      : start,
            expression : newexp,
            args       : args,
            end        : prev()
        }), true);
    };

    function as_atom_node() {
        var tok = S.token, ret;
        switch (tok.type) {
          case "name":
          case "keyword":
            ret = _make_symbol(AST_SymbolRef);
            break;
          case "num":
            ret = new AST_Number({ start: tok, end: tok, value: tok.value });
            break;
          case "string":
            ret = new AST_String({ start: tok, end: tok, value: tok.value });
            break;
          case "regexp":
            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });
            break;
          case "atom":
            switch (tok.value) {
              case "false":
                ret = new AST_False({ start: tok, end: tok });
                break;
              case "true":
                ret = new AST_True({ start: tok, end: tok });
                break;
              case "null":
                ret = new AST_Null({ start: tok, end: tok });
                break;
            }
            break;
        }
        next();
        return ret;
    };

    var expr_atom = function(allow_calls) {
        if (is("operator", "new")) {
            return new_();
        }
        var start = S.token;
        if (is("punc")) {
            switch (start.value) {
              case "(":
                next();
                var ex = expression(true);
                ex.start = start;
                ex.end = S.token;
                expect(")");
                return subscripts(ex, allow_calls);
              case "[":
                return subscripts(array_(), allow_calls);
              case "{":
                return subscripts(object_(), allow_calls);
            }
            unexpected();
        }
        if (is("keyword", "function")) {
            next();
            var func = function_(AST_Function);
            func.start = start;
            func.end = prev();
            return subscripts(func, allow_calls);
        }
        if (ATOMIC_START_TOKEN[S.token.type]) {
            return subscripts(as_atom_node(), allow_calls);
        }
        unexpected();
    };

    function expr_list(closing, allow_trailing_comma, allow_empty) {
        var first = true, a = [];
        while (!is("punc", closing)) {
            if (first) first = false; else expect(",");
            if (allow_trailing_comma && is("punc", closing)) break;
            if (is("punc", ",") && allow_empty) {
                a.push(new AST_Hole({ start: S.token, end: S.token }));
            } else {
                a.push(expression(false));
            }
        }
        next();
        return a;
    };

    var array_ = embed_tokens(function() {
        expect("[");
        return new AST_Array({
            elements: expr_list("]", !options.strict, true)
        });
    });

    var object_ = embed_tokens(function() {
        expect("{");
        var first = true, a = [];
        while (!is("punc", "}")) {
            if (first) first = false; else expect(",");
            if (!options.strict && is("punc", "}"))
                // allow trailing comma
                break;
            var start = S.token;
            var type = start.type;
            var name = as_property_name();
            if (type == "name" && !is("punc", ":")) {
                if (name == "get") {
                    a.push(new AST_ObjectGetter({
                        start : start,
                        key   : as_atom_node(),
                        value : function_(AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
                if (name == "set") {
                    a.push(new AST_ObjectSetter({
                        start : start,
                        key   : as_atom_node(),
                        value : function_(AST_Accessor),
                        end   : prev()
                    }));
                    continue;
                }
            }
            expect(":");
            a.push(new AST_ObjectKeyVal({
                start : start,
                key   : name,
                value : expression(false),
                end   : prev()
            }));
        }
        next();
        return new AST_Object({ properties: a });
    });

    function as_property_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "num":
          case "string":
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function as_name() {
        var tmp = S.token;
        next();
        switch (tmp.type) {
          case "name":
          case "operator":
          case "keyword":
          case "atom":
            return tmp.value;
          default:
            unexpected();
        }
    };

    function _make_symbol(type) {
        var name = S.token.value;
        return new (name == "this" ? AST_This : type)({
            name  : String(name),
            start : S.token,
            end   : S.token
        });
    };

    function as_symbol(type, noerror) {
        if (!is("name")) {
            if (!noerror) croak("Name expected");
            return null;
        }
        var sym = _make_symbol(type);
        next();
        return sym;
    };

    var subscripts = function(expr, allow_calls) {
        var start = expr.start;
        if (is("punc", ".")) {
            next();
            return subscripts(new AST_Dot({
                start      : start,
                expression : expr,
                property   : as_name(),
                end        : prev()
            }), allow_calls);
        }
        if (is("punc", "[")) {
            next();
            var prop = expression(true);
            expect("]");
            return subscripts(new AST_Sub({
                start      : start,
                expression : expr,
                property   : prop,
                end        : prev()
            }), allow_calls);
        }
        if (allow_calls && is("punc", "(")) {
            next();
            return subscripts(new AST_Call({
                start      : start,
                expression : expr,
                args       : expr_list(")"),
                end        : prev()
            }), true);
        }
        return expr;
    };

    var maybe_unary = function(allow_calls) {
        var start = S.token;
        if (is("operator") && UNARY_PREFIX(start.value)) {
            next();
            handle_regexp();
            var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
            ex.start = start;
            ex.end = prev();
            return ex;
        }
        var val = expr_atom(allow_calls);
        while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
            val = make_unary(AST_UnaryPostfix, S.token.value, val);
            val.start = start;
            val.end = S.token;
            next();
        }
        return val;
    };

    function make_unary(ctor, op, expr) {
        if ((op == "++" || op == "--") && !is_assignable(expr))
            croak("Invalid use of " + op + " operator");
        return new ctor({ operator: op, expression: expr });
    };

    var expr_op = function(left, min_prec, no_in) {
        var op = is("operator") ? S.token.value : null;
        if (op == "in" && no_in) op = null;
        var prec = op != null ? PRECEDENCE[op] : null;
        if (prec != null && prec > min_prec) {
            next();
            var right = expr_op(maybe_unary(true), prec, no_in);
            return expr_op(new AST_Binary({
                start    : left.start,
                left     : left,
                operator : op,
                right    : right,
                end      : right.end
            }), min_prec, no_in);
        }
        return left;
    };

    function expr_ops(no_in) {
        return expr_op(maybe_unary(true), 0, no_in);
    };

    var maybe_conditional = function(no_in) {
        var start = S.token;
        var expr = expr_ops(no_in);
        if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return new AST_Conditional({
                start       : start,
                condition   : expr,
                consequent  : yes,
                alternative : expression(false, no_in),
                end         : prev()
            });
        }
        return expr;
    };

    function is_assignable(expr) {
        if (!options.strict) return true;
        if (expr instanceof AST_This) return false;
        return (expr instanceof AST_PropAccess || expr instanceof AST_Symbol);
    };

    var maybe_assign = function(no_in) {
        var start = S.token;
        var left = maybe_conditional(no_in), val = S.token.value;
        if (is("operator") && ASSIGNMENT(val)) {
            if (is_assignable(left)) {
                next();
                return new AST_Assign({
                    start    : start,
                    left     : left,
                    operator : val,
                    right    : maybe_assign(no_in),
                    end      : prev()
                });
            }
            croak("Invalid assignment");
        }
        return left;
    };

    var expression = function(commas, no_in) {
        var start = S.token;
        var expr = maybe_assign(no_in);
        if (commas && is("punc", ",")) {
            next();
            return new AST_Seq({
                start  : start,
                car    : expr,
                cdr    : expression(true, no_in),
                end    : peek()
            });
        }
        return expr;
    };

    function in_loop(cont) {
        ++S.in_loop;
        var ret = cont();
        --S.in_loop;
        return ret;
    };

    if (options.expression) {
        return expression(true);
    }

    return (function(){
        var start = S.token;
        var body = [];
        while (!is("eof"))
            body.push(statement());
        var end = prev();
        var toplevel = options.toplevel;
        if (toplevel) {
            toplevel.body = toplevel.body.concat(body);
            toplevel.end = end;
        } else {
            toplevel = new AST_Toplevel({ start: start, body: body, end: end });
        }
        return toplevel;
    })();

};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// Tree transformer helpers.

function TreeTransformer(before, after) {
    TreeWalker.call(this);
    this.before = before;
    this.after = after;
}
TreeTransformer.prototype = new TreeWalker;

(function(undefined){

    function _(node, descend) {
        node.DEFMETHOD("transform", function(tw, in_list){
            var x, y;
            tw.push(this);
            if (tw.before) x = tw.before(this, descend, in_list);
            if (x === undefined) {
                if (!tw.after) {
                    x = this;
                    descend(x, tw);
                } else {
                    tw.stack[tw.stack.length - 1] = x = this.clone();
                    descend(x, tw);
                    y = tw.after(x, in_list);
                    if (y !== undefined) x = y;
                }
            }
            tw.pop();
            return x;
        });
    };

    function do_list(list, tw) {
        return MAP(list, function(node){
            return node.transform(tw, true);
        });
    };

    _(AST_Node, noop);

    _(AST_LabeledStatement, function(self, tw){
        self.label = self.label.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_SimpleStatement, function(self, tw){
        self.body = self.body.transform(tw);
    });

    _(AST_Block, function(self, tw){
        self.body = do_list(self.body, tw);
    });

    _(AST_DWLoop, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_For, function(self, tw){
        if (self.init) self.init = self.init.transform(tw);
        if (self.condition) self.condition = self.condition.transform(tw);
        if (self.step) self.step = self.step.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_ForIn, function(self, tw){
        self.init = self.init.transform(tw);
        self.object = self.object.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_With, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = self.body.transform(tw);
    });

    _(AST_Exit, function(self, tw){
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_LoopControl, function(self, tw){
        if (self.label) self.label = self.label.transform(tw);
    });

    _(AST_If, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.body = self.body.transform(tw);
        if (self.alternative) self.alternative = self.alternative.transform(tw);
    });

    _(AST_Switch, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Case, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Try, function(self, tw){
        self.body = do_list(self.body, tw);
        if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
        if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
    });

    _(AST_Catch, function(self, tw){
        self.argname = self.argname.transform(tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Definitions, function(self, tw){
        self.definitions = do_list(self.definitions, tw);
    });

    _(AST_VarDef, function(self, tw){
        self.name = self.name.transform(tw);
        if (self.value) self.value = self.value.transform(tw);
    });

    _(AST_Lambda, function(self, tw){
        if (self.name) self.name = self.name.transform(tw);
        self.argnames = do_list(self.argnames, tw);
        self.body = do_list(self.body, tw);
    });

    _(AST_Call, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.args = do_list(self.args, tw);
    });

    _(AST_Seq, function(self, tw){
        self.car = self.car.transform(tw);
        self.cdr = self.cdr.transform(tw);
    });

    _(AST_Dot, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Sub, function(self, tw){
        self.expression = self.expression.transform(tw);
        self.property = self.property.transform(tw);
    });

    _(AST_Unary, function(self, tw){
        self.expression = self.expression.transform(tw);
    });

    _(AST_Binary, function(self, tw){
        self.left = self.left.transform(tw);
        self.right = self.right.transform(tw);
    });

    _(AST_Conditional, function(self, tw){
        self.condition = self.condition.transform(tw);
        self.consequent = self.consequent.transform(tw);
        self.alternative = self.alternative.transform(tw);
    });

    _(AST_Array, function(self, tw){
        self.elements = do_list(self.elements, tw);
    });

    _(AST_Object, function(self, tw){
        self.properties = do_list(self.properties, tw);
    });

    _(AST_ObjectProperty, function(self, tw){
        self.value = self.value.transform(tw);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function SymbolDef(scope, index, orig) {
    this.name = orig.name;
    this.orig = [ orig ];
    this.scope = scope;
    this.references = [];
    this.global = false;
    this.mangled_name = null;
    this.undeclared = false;
    this.constant = false;
    this.index = index;
};

SymbolDef.prototype = {
    unmangleable: function(options) {
        return (this.global && !(options && options.toplevel))
            || this.undeclared
            || (!(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with));
    },
    mangle: function(options) {
        if (!this.mangled_name && !this.unmangleable(options)) {
            var s = this.scope;
            if (!options.screw_ie8 && this.orig[0] instanceof AST_SymbolLambda)
                s = s.parent_scope;
            this.mangled_name = s.next_mangled(options, this);
        }
    }
};

AST_Toplevel.DEFMETHOD("figure_out_scope", function(options){
    options = defaults(options, {
        screw_ie8: false
    });

    // pass 1: setup scope chaining and handle definitions
    var self = this;
    var scope = self.parent_scope = null;
    var defun = null;
    var nesting = 0;
    var tw = new TreeWalker(function(node, descend){
        if (options.screw_ie8 && node instanceof AST_Catch) {
            var save_scope = scope;
            scope = new AST_Scope(node);
            scope.init_scope_vars(nesting);
            scope.parent_scope = save_scope;
            descend();
            scope = save_scope;
            return true;
        }
        if (node instanceof AST_Scope) {
            node.init_scope_vars(nesting);
            var save_scope = node.parent_scope = scope;
            var save_defun = defun;
            defun = scope = node;
            ++nesting; descend(); --nesting;
            scope = save_scope;
            defun = save_defun;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Directive) {
            node.scope = scope;
            push_uniq(scope.directives, node.value);
            return true;
        }
        if (node instanceof AST_With) {
            for (var s = scope; s; s = s.parent_scope)
                s.uses_with = true;
            return;
        }
        if (node instanceof AST_Symbol) {
            node.scope = scope;
        }
        if (node instanceof AST_SymbolLambda) {
            defun.def_function(node);
        }
        else if (node instanceof AST_SymbolDefun) {
            // Careful here, the scope where this should be defined is
            // the parent scope.  The reason is that we enter a new
            // scope when we encounter the AST_Defun node (which is
            // instanceof AST_Scope) but we get to the symbol a bit
            // later.
            (node.scope = defun.parent_scope).def_function(node);
        }
        else if (node instanceof AST_SymbolVar
                 || node instanceof AST_SymbolConst) {
            var def = defun.def_variable(node);
            def.constant = node instanceof AST_SymbolConst;
            def.init = tw.parent().value;
        }
        else if (node instanceof AST_SymbolCatch) {
            (options.screw_ie8 ? scope : defun)
                .def_variable(node);
        }
    });
    self.walk(tw);

    // pass 2: find back references and eval
    var func = null;
    var globals = self.globals = new Dictionary();
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_Lambda) {
            var prev_func = func;
            func = node;
            descend();
            func = prev_func;
            return true;
        }
        if (node instanceof AST_SymbolRef) {
            var name = node.name;
            var sym = node.scope.find_variable(name);
            if (!sym) {
                var g;
                if (globals.has(name)) {
                    g = globals.get(name);
                } else {
                    g = new SymbolDef(self, globals.size(), node);
                    g.undeclared = true;
                    g.global = true;
                    globals.set(name, g);
                }
                node.thedef = g;
                if (name == "eval" && tw.parent() instanceof AST_Call) {
                    for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope)
                        s.uses_eval = true;
                }
                if (func && name == "arguments") {
                    func.uses_arguments = true;
                }
            } else {
                node.thedef = sym;
            }
            node.reference();
            return true;
        }
    });
    self.walk(tw);
});

AST_Scope.DEFMETHOD("init_scope_vars", function(nesting){
    this.directives = [];     // contains the directives defined in this scope, i.e. "use strict"
    this.variables = new Dictionary(); // map name to AST_SymbolVar (variables defined in this scope; includes functions)
    this.functions = new Dictionary(); // map name to AST_SymbolDefun (functions defined in this scope)
    this.uses_with = false;   // will be set to true if this or some nested scope uses the `with` statement
    this.uses_eval = false;   // will be set to true if this or nested scope uses the global `eval`
    this.parent_scope = null; // the parent scope
    this.enclosed = [];       // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
    this.cname = -1;          // the current index for mangling functions/variables
    this.nesting = nesting;   // the nesting level of this scope (0 means toplevel)
});

AST_Scope.DEFMETHOD("strict", function(){
    return this.has_directive("use strict");
});

AST_Lambda.DEFMETHOD("init_scope_vars", function(){
    AST_Scope.prototype.init_scope_vars.apply(this, arguments);
    this.uses_arguments = false;
});

AST_SymbolRef.DEFMETHOD("reference", function() {
    var def = this.definition();
    def.references.push(this);
    var s = this.scope;
    while (s) {
        push_uniq(s.enclosed, def);
        if (s === def.scope) break;
        s = s.parent_scope;
    }
    this.frame = this.scope.nesting - def.scope.nesting;
});

AST_Scope.DEFMETHOD("find_variable", function(name){
    if (name instanceof AST_Symbol) name = name.name;
    return this.variables.get(name)
        || (this.parent_scope && this.parent_scope.find_variable(name));
});

AST_Scope.DEFMETHOD("has_directive", function(value){
    return this.parent_scope && this.parent_scope.has_directive(value)
        || (this.directives.indexOf(value) >= 0 ? this : null);
});

AST_Scope.DEFMETHOD("def_function", function(symbol){
    this.functions.set(symbol.name, this.def_variable(symbol));
});

AST_Scope.DEFMETHOD("def_variable", function(symbol){
    var def;
    if (!this.variables.has(symbol.name)) {
        def = new SymbolDef(this, this.variables.size(), symbol);
        this.variables.set(symbol.name, def);
        def.global = !this.parent_scope;
    } else {
        def = this.variables.get(symbol.name);
        def.orig.push(symbol);
    }
    return symbol.thedef = def;
});

AST_Scope.DEFMETHOD("next_mangled", function(options){
    var ext = this.enclosed;
    out: while (true) {
        var m = base54(++this.cname);
        if (!is_identifier(m)) continue; // skip over "do"

        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not
        // shadow a name excepted from mangling.
        if (options.except.indexOf(m) >= 0) continue;

        // we must ensure that the mangled name does not shadow a name
        // from some parent scope that is referenced in this or in
        // inner scopes.
        for (var i = ext.length; --i >= 0;) {
            var sym = ext[i];
            var name = sym.mangled_name || (sym.unmangleable(options) && sym.name);
            if (m == name) continue out;
        }
        return m;
    }
});

AST_Function.DEFMETHOD("next_mangled", function(options, def){
    // #179, #326
    // in Safari strict mode, something like (function x(x){...}) is a syntax error;
    // a function expression's argument cannot shadow the function expression's name

    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
    while (true) {
        var name = AST_Lambda.prototype.next_mangled.call(this, options, def);
        if (!(tricky_def && tricky_def.mangled_name == name))
            return name;
    }
});

AST_Scope.DEFMETHOD("references", function(sym){
    if (sym instanceof AST_Symbol) sym = sym.definition();
    return this.enclosed.indexOf(sym) < 0 ? null : sym;
});

AST_Symbol.DEFMETHOD("unmangleable", function(options){
    return this.definition().unmangleable(options);
});

// property accessors are not mangleable
AST_SymbolAccessor.DEFMETHOD("unmangleable", function(){
    return true;
});

// labels are always mangleable
AST_Label.DEFMETHOD("unmangleable", function(){
    return false;
});

AST_Symbol.DEFMETHOD("unreferenced", function(){
    return this.definition().references.length == 0
        && !(this.scope.uses_eval || this.scope.uses_with);
});

AST_Symbol.DEFMETHOD("undeclared", function(){
    return this.definition().undeclared;
});

AST_LabelRef.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Label.DEFMETHOD("undeclared", function(){
    return false;
});

AST_Symbol.DEFMETHOD("definition", function(){
    return this.thedef;
});

AST_Symbol.DEFMETHOD("global", function(){
    return this.definition().global;
});

AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options){
    return defaults(options, {
        except   : [],
        eval     : false,
        sort     : false,
        toplevel : false,
        screw_ie8 : false
    });
});

AST_Toplevel.DEFMETHOD("mangle_names", function(options){
    options = this._default_mangler_options(options);
    // We only need to mangle declaration nodes.  Special logic wired
    // into the code generator will display the mangled name if it's
    // present (and for AST_SymbolRef-s it'll use the mangled name of
    // the AST_SymbolDeclaration that it points to).
    var lname = -1;
    var to_mangle = [];
    var tw = new TreeWalker(function(node, descend){
        if (node instanceof AST_LabeledStatement) {
            // lname is incremented when we get to the AST_Label
            var save_nesting = lname;
            descend();
            lname = save_nesting;
            return true;        // don't descend again in TreeWalker
        }
        if (node instanceof AST_Scope) {
            var p = tw.parent(), a = [];
            node.variables.each(function(symbol){
                if (options.except.indexOf(symbol.name) < 0) {
                    a.push(symbol);
                }
            });
            if (options.sort) a.sort(function(a, b){
                return b.references.length - a.references.length;
            });
            to_mangle.push.apply(to_mangle, a);
            return;
        }
        if (node instanceof AST_Label) {
            var name;
            do name = base54(++lname); while (!is_identifier(name));
            node.mangled_name = name;
            return true;
        }
        if (options.screw_ie8 && node instanceof AST_SymbolCatch) {
            to_mangle.push(node.definition());
            return;
        }
    });
    this.walk(tw);
    to_mangle.forEach(function(def){ def.mangle(options) });
});

AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options){
    options = this._default_mangler_options(options);
    var tw = new TreeWalker(function(node){
        if (node instanceof AST_Constant)
            base54.consider(node.print_to_string());
        else if (node instanceof AST_Return)
            base54.consider("return");
        else if (node instanceof AST_Throw)
            base54.consider("throw");
        else if (node instanceof AST_Continue)
            base54.consider("continue");
        else if (node instanceof AST_Break)
            base54.consider("break");
        else if (node instanceof AST_Debugger)
            base54.consider("debugger");
        else if (node instanceof AST_Directive)
            base54.consider(node.value);
        else if (node instanceof AST_While)
            base54.consider("while");
        else if (node instanceof AST_Do)
            base54.consider("do while");
        else if (node instanceof AST_If) {
            base54.consider("if");
            if (node.alternative) base54.consider("else");
        }
        else if (node instanceof AST_Var)
            base54.consider("var");
        else if (node instanceof AST_Const)
            base54.consider("const");
        else if (node instanceof AST_Lambda)
            base54.consider("function");
        else if (node instanceof AST_For)
            base54.consider("fo" + "r");
        else if (node instanceof AST_ForIn)
            base54.consider("for in");
        else if (node instanceof AST_Switch)
            base54.consider("switch");
        else if (node instanceof AST_Case)
            base54.consider("case");
        else if (node instanceof AST_Default)
            base54.consider("default");
        else if (node instanceof AST_With)
            base54.consider("with");
        else if (node instanceof AST_ObjectSetter)
            base54.consider("set" + node.key);
        else if (node instanceof AST_ObjectGetter)
            base54.consider("get" + node.key);
        else if (node instanceof AST_ObjectKeyVal)
            base54.consider(node.key);
        else if (node instanceof AST_New)
            base54.consider("new");
        else if (node instanceof AST_This)
            base54.consider("this");
        else if (node instanceof AST_Try)
            base54.consider("try");
        else if (node instanceof AST_Catch)
            base54.consider("catch");
        else if (node instanceof AST_Finally)
            base54.consider("finally");
        else if (node instanceof AST_Symbol && node.unmangleable(options))
            base54.consider(node.name);
        else if (node instanceof AST_Unary || node instanceof AST_Binary)
            base54.consider(node.operator);
        else if (node instanceof AST_Dot)
            base54.consider(node.property);
    });
    this.walk(tw);
    base54.sort();
});

var base54 = (function() {
    var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
    var chars, frequency;
    function reset() {
        frequency = Object.create(null);
        chars = string.split("").map(function(ch){ return ch.charCodeAt(0) });
        chars.forEach(function(ch){ frequency[ch] = 0 });
    }
    base54.consider = function(str){
        for (var i = str.length; --i >= 0;) {
            var code = str.charCodeAt(i);
            if (code in frequency) ++frequency[code];
        }
    };
    base54.sort = function() {
        chars = mergeSort(chars, function(a, b){
            if (is_digit(a) && !is_digit(b)) return 1;
            if (is_digit(b) && !is_digit(a)) return -1;
            return frequency[b] - frequency[a];
        });
    };
    base54.reset = reset;
    reset();
    base54.get = function(){ return chars };
    base54.freq = function(){ return frequency };
    function base54(num) {
        var ret = "", base = 54;
        do {
            ret += String.fromCharCode(chars[num % base]);
            num = Math.floor(num / base);
            base = 64;
        } while (num > 0);
        return ret;
    };
    return base54;
})();

AST_Toplevel.DEFMETHOD("scope_warnings", function(options){
    options = defaults(options, {
        undeclared       : false, // this makes a lot of noise
        unreferenced     : true,
        assign_to_global : true,
        func_arguments   : true,
        nested_defuns    : true,
        eval             : true
    });
    var tw = new TreeWalker(function(node){
        if (options.undeclared
            && node instanceof AST_SymbolRef
            && node.undeclared())
        {
            // XXX: this also warns about JS standard names,
            // i.e. Object, Array, parseInt etc.  Should add a list of
            // exceptions.
            AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.assign_to_global)
        {
            var sym = null;
            if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef)
                sym = node.left;
            else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef)
                sym = node.init;
            if (sym
                && (sym.undeclared()
                    || (sym.global() && sym.scope !== sym.definition().scope))) {
                AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                    msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                    name: sym.name,
                    file: sym.start.file,
                    line: sym.start.line,
                    col: sym.start.col
                });
            }
        }
        if (options.eval
            && node instanceof AST_SymbolRef
            && node.undeclared()
            && node.name == "eval") {
            AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
        }
        if (options.unreferenced
            && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label)
            && node.unreferenced()) {
            AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                type: node instanceof AST_Label ? "Label" : "Symbol",
                name: node.name,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.func_arguments
            && node instanceof AST_Lambda
            && node.uses_arguments) {
            AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
                name: node.name ? node.name.name : "anonymous",
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
        if (options.nested_defuns
            && node instanceof AST_Defun
            && !(tw.parent() instanceof AST_Scope)) {
            AST_Node.warn("Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]", {
                name: node.name.name,
                type: tw.parent().TYPE,
                file: node.start.file,
                line: node.start.line,
                col: node.start.col
            });
        }
    });
    this.walk(tw);
});

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function OutputStream(options) {

    options = defaults(options, {
        indent_start     : 0,
        indent_level     : 4,
        quote_keys       : false,
        space_colon      : true,
        ascii_only       : false,
        unescape_regexps : false,
        inline_script    : false,
        width            : 80,
        max_line_len     : 32000,
        beautify         : false,
        source_map       : null,
        bracketize       : false,
        semicolons       : true,
        comments         : false,
        preserve_line    : false,
        screw_ie8        : false,
        preamble         : null,
    }, true);

    var indentation = 0;
    var current_col = 0;
    var current_line = 1;
    var current_pos = 0;
    var OUTPUT = "";

    function to_ascii(str, identifier) {
        return str.replace(/[\u0080-\uffff]/g, function(ch) {
            var code = ch.charCodeAt(0).toString(16);
            if (code.length <= 2 && !identifier) {
                while (code.length < 2) code = "0" + code;
                return "\\x" + code;
            } else {
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
            }
        });
    };

    function make_string(str) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
            switch (s) {
              case "\\": return "\\\\";
              case "\b": return "\\b";
              case "\f": return "\\f";
              case "\n": return "\\n";
              case "\r": return "\\r";
              case "\u2028": return "\\u2028";
              case "\u2029": return "\\u2029";
              case '"': ++dq; return '"';
              case "'": ++sq; return "'";
              case "\0": return "\\x00";
            }
            return s;
        });
        if (options.ascii_only) str = to_ascii(str);
        if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
        else return '"' + str.replace(/\x22/g, '\\"') + '"';
    };

    function encode_string(str) {
        var ret = make_string(str);
        if (options.inline_script)
            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
        return ret;
    };

    function make_name(name) {
        name = name.toString();
        if (options.ascii_only)
            name = to_ascii(name, true);
        return name;
    };

    function make_indent(back) {
        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
    };

    /* -----[ beautification/minification ]----- */

    var might_need_space = false;
    var might_need_semicolon = false;
    var last = null;

    function last_char() {
        return last.charAt(last.length - 1);
    };

    function maybe_newline() {
        if (options.max_line_len && current_col > options.max_line_len)
            print("\n");
    };

    var requireSemicolonChars = makePredicate("( [ + * / - , .");

    function print(str) {
        str = String(str);
        var ch = str.charAt(0);
        if (might_need_semicolon) {
            if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
                if (options.semicolons || requireSemicolonChars(ch)) {
                    OUTPUT += ";";
                    current_col++;
                    current_pos++;
                } else {
                    OUTPUT += "\n";
                    current_pos++;
                    current_line++;
                    current_col = 0;
                }
                if (!options.beautify)
                    might_need_space = false;
            }
            might_need_semicolon = false;
            maybe_newline();
        }

        if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
            var target_line = stack[stack.length - 1].start.line;
            while (current_line < target_line) {
                OUTPUT += "\n";
                current_pos++;
                current_line++;
                current_col = 0;
                might_need_space = false;
            }
        }

        if (might_need_space) {
            var prev = last_char();
            if ((is_identifier_char(prev)
                 && (is_identifier_char(ch) || ch == "\\"))
                || (/^[\+\-\/]$/.test(ch) && ch == prev))
            {
                OUTPUT += " ";
                current_col++;
                current_pos++;
            }
            might_need_space = false;
        }
        var a = str.split(/\r?\n/), n = a.length - 1;
        current_line += n;
        if (n == 0) {
            current_col += a[n].length;
        } else {
            current_col = a[n].length;
        }
        current_pos += str.length;
        last = str;
        OUTPUT += str;
    };

    var space = options.beautify ? function() {
        print(" ");
    } : function() {
        might_need_space = true;
    };

    var indent = options.beautify ? function(half) {
        if (options.beautify) {
            print(make_indent(half ? 0.5 : 0));
        }
    } : noop;

    var with_indent = options.beautify ? function(col, cont) {
        if (col === true) col = next_indent();
        var save_indentation = indentation;
        indentation = col;
        var ret = cont();
        indentation = save_indentation;
        return ret;
    } : function(col, cont) { return cont() };

    var newline = options.beautify ? function() {
        print("\n");
    } : noop;

    var semicolon = options.beautify ? function() {
        print(";");
    } : function() {
        might_need_semicolon = true;
    };

    function force_semicolon() {
        might_need_semicolon = false;
        print(";");
    };

    function next_indent() {
        return indentation + options.indent_level;
    };

    function with_block(cont) {
        var ret;
        print("{");
        newline();
        with_indent(next_indent(), function(){
            ret = cont();
        });
        indent();
        print("}");
        return ret;
    };

    function with_parens(cont) {
        print("(");
        //XXX: still nice to have that for argument lists
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print(")");
        return ret;
    };

    function with_square(cont) {
        print("[");
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print("]");
        return ret;
    };

    function comma() {
        print(",");
        space();
    };

    function colon() {
        print(":");
        if (options.space_colon) space();
    };

    var add_mapping = options.source_map ? function(token, name) {
        try {
            if (token) options.source_map.add(
                token.file || "?",
                current_line, current_col,
                token.line, token.col,
                (!name && token.type == "name") ? token.value : name
            );
        } catch(ex) {
            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                file: token.file,
                line: token.line,
                col: token.col,
                cline: current_line,
                ccol: current_col,
                name: name || ""
            })
        }
    } : noop;

    function get() {
        return OUTPUT;
    };

    if (options.preamble) {
        print(options.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
    }

    var stack = [];
    return {
        get             : get,
        toString        : get,
        indent          : indent,
        indentation     : function() { return indentation },
        current_width   : function() { return current_col - indentation },
        should_break    : function() { return options.width && this.current_width() >= options.width },
        newline         : newline,
        print           : print,
        space           : space,
        comma           : comma,
        colon           : colon,
        last            : function() { return last },
        semicolon       : semicolon,
        force_semicolon : force_semicolon,
        to_ascii        : to_ascii,
        print_name      : function(name) { print(make_name(name)) },
        print_string    : function(str) { print(encode_string(str)) },
        next_indent     : next_indent,
        with_indent     : with_indent,
        with_block      : with_block,
        with_parens     : with_parens,
        with_square     : with_square,
        add_mapping     : add_mapping,
        option          : function(opt) { return options[opt] },
        line            : function() { return current_line },
        col             : function() { return current_col },
        pos             : function() { return current_pos },
        push_node       : function(node) { stack.push(node) },
        pop_node        : function() { return stack.pop() },
        stack           : function() { return stack },
        parent          : function(n) {
            return stack[stack.length - 2 - (n || 0)];
        }
    };

};

/* -----[ code generators ]----- */

(function(){

    /* -----[ utils ]----- */

    function DEFPRINT(nodetype, generator) {
        nodetype.DEFMETHOD("_codegen", generator);
    };

    AST_Node.DEFMETHOD("print", function(stream, force_parens){
        var self = this, generator = self._codegen;
        function doit() {
            self.add_comments(stream);
            self.add_source_map(stream);
            generator(self, stream);
        }
        stream.push_node(self);
        if (force_parens || self.needs_parens(stream)) {
            stream.with_parens(doit);
        } else {
            doit();
        }
        stream.pop_node();
    });

    AST_Node.DEFMETHOD("print_to_string", function(options){
        var s = OutputStream(options);
        this.print(s);
        return s.get();
    });

    /* -----[ comments ]----- */

    AST_Node.DEFMETHOD("add_comments", function(output){
        var c = output.option("comments"), self = this;
        if (c) {
            var start = self.start;
            if (start && !start._comments_dumped) {
                start._comments_dumped = true;
                var comments = start.comments_before || [];

                // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                //               and https://github.com/mishoo/UglifyJS2/issues/372
                if (self instanceof AST_Exit && self.value) {
                    self.value.walk(new TreeWalker(function(node){
                        if (node.start && node.start.comments_before) {
                            comments = comments.concat(node.start.comments_before);
                            node.start.comments_before = [];
                        }
                        if (node instanceof AST_Function ||
                            node instanceof AST_Array ||
                            node instanceof AST_Object)
                        {
                            return true; // don't go inside.
                        }
                    }));
                }

                if (c.test) {
                    comments = comments.filter(function(comment){
                        return c.test(comment.value);
                    });
                } else if (typeof c == "function") {
                    comments = comments.filter(function(comment){
                        return c(self, comment);
                    });
                }
                comments.forEach(function(c){
                    if (/comment[134]/.test(c.type)) {
                        output.print("//" + c.value + "\n");
                        output.indent();
                    }
                    else if (c.type == "comment2") {
                        output.print("/*" + c.value + "*/");
                        if (start.nlb) {
                            output.print("\n");
                            output.indent();
                        } else {
                            output.space();
                        }
                    }
                });
            }
        }
    });

    /* -----[ PARENTHESES ]----- */

    function PARENS(nodetype, func) {
        nodetype.DEFMETHOD("needs_parens", func);
    };

    PARENS(AST_Node, function(){
        return false;
    });

    // a function expression needs parens around it when it's provably
    // the first token to appear in a statement.
    PARENS(AST_Function, function(output){
        return first_in_statement(output);
    });

    // same goes for an object literal, because otherwise it would be
    // interpreted as a block of code.
    PARENS(AST_Object, function(output){
        return first_in_statement(output);
    });

    PARENS(AST_Unary, function(output){
        var p = output.parent();
        return p instanceof AST_PropAccess && p.expression === this;
    });

    PARENS(AST_Seq, function(output){
        var p = output.parent();
        return p instanceof AST_Call             // (foo, bar)() or foo(1, (2, 3), 4)
            || p instanceof AST_Unary            // !(foo, bar, baz)
            || p instanceof AST_Binary           // 1 + (2, 3) + 4 ==> 8
            || p instanceof AST_VarDef           // var a = (1, 2), b = a + a; ==> b == 4
            || p instanceof AST_PropAccess       // (1, {foo:2}).foo or (1, {foo:2})["foo"] ==> 2
            || p instanceof AST_Array            // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
            || p instanceof AST_ObjectProperty   // { foo: (1, 2) }.foo ==> 2
            || p instanceof AST_Conditional      /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                  * ==> 20 (side effect, set a := 10 and b := 20) */
        ;
    });

    PARENS(AST_Binary, function(output){
        var p = output.parent();
        // (foo && bar)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // typeof (foo && bar)
        if (p instanceof AST_Unary)
            return true;
        // (foo && bar)["prop"], (foo && bar).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        // this deals with precedence: 3 * (2 + 1)
        if (p instanceof AST_Binary) {
            var po = p.operator, pp = PRECEDENCE[po];
            var so = this.operator, sp = PRECEDENCE[so];
            if (pp > sp
                || (pp == sp
                    && this === p.right)) {
                return true;
            }
        }
    });

    PARENS(AST_PropAccess, function(output){
        var p = output.parent();
        if (p instanceof AST_New && p.expression === this) {
            // i.e. new (foo.bar().baz)
            //
            // if there's one call into this subtree, then we need
            // parens around it too, otherwise the call will be
            // interpreted as passing the arguments to the upper New
            // expression.
            try {
                this.walk(new TreeWalker(function(node){
                    if (node instanceof AST_Call) throw p;
                }));
            } catch(ex) {
                if (ex !== p) throw ex;
                return true;
            }
        }
    });

    PARENS(AST_Call, function(output){
        var p = output.parent(), p1;
        if (p instanceof AST_New && p.expression === this)
            return true;

        // workaround for Safari bug.
        // https://bugs.webkit.org/show_bug.cgi?id=123506
        return this.expression instanceof AST_Function
            && p instanceof AST_PropAccess
            && p.expression === this
            && (p1 = output.parent(1)) instanceof AST_Assign
            && p1.left === p;
    });

    PARENS(AST_New, function(output){
        var p = output.parent();
        if (no_constructor_parens(this, output)
            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)["getTime"]()
                || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
            return true;
    });

    PARENS(AST_Number, function(output){
        var p = output.parent();
        if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    PARENS(AST_NaN, function(output){
        var p = output.parent();
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    function assign_and_conditional_paren_rules(output) {
        var p = output.parent();
        // !(a = false) → true
        if (p instanceof AST_Unary)
            return true;
        // 1 + (a = 2) + 3 → 6, side effect setting a = 2
        if (p instanceof AST_Binary && !(p instanceof AST_Assign))
            return true;
        // (a = func)() —or— new (a = Object)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // (a = foo) ? bar : baz
        if (p instanceof AST_Conditional && p.condition === this)
            return true;
        // (a = foo)["prop"] —or— (a = foo).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    };

    PARENS(AST_Assign, assign_and_conditional_paren_rules);
    PARENS(AST_Conditional, assign_and_conditional_paren_rules);

    /* -----[ PRINTERS ]----- */

    DEFPRINT(AST_Directive, function(self, output){
        output.print_string(self.value);
        output.semicolon();
    });
    DEFPRINT(AST_Debugger, function(self, output){
        output.print("debugger");
        output.semicolon();
    });

    /* -----[ statements ]----- */

    function display_body(body, is_toplevel, output) {
        var last = body.length - 1;
        body.forEach(function(stmt, i){
            if (!(stmt instanceof AST_EmptyStatement)) {
                output.indent();
                stmt.print(output);
                if (!(i == last && is_toplevel)) {
                    output.newline();
                    if (is_toplevel) output.newline();
                }
            }
        });
    };

    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output){
        force_statement(this.body, output);
    });

    DEFPRINT(AST_Statement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    DEFPRINT(AST_Toplevel, function(self, output){
        display_body(self.body, true, output);
        output.print("");
    });
    DEFPRINT(AST_LabeledStatement, function(self, output){
        self.label.print(output);
        output.colon();
        self.body.print(output);
    });
    DEFPRINT(AST_SimpleStatement, function(self, output){
        self.body.print(output);
        output.semicolon();
    });
    function print_bracketed(body, output) {
        if (body.length > 0) output.with_block(function(){
            display_body(body, false, output);
        });
        else output.print("{}");
    };
    DEFPRINT(AST_BlockStatement, function(self, output){
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_EmptyStatement, function(self, output){
        output.semicolon();
    });
    DEFPRINT(AST_Do, function(self, output){
        output.print("do");
        output.space();
        self._do_print_body(output);
        output.space();
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.semicolon();
    });
    DEFPRINT(AST_While, function(self, output){
        output.print("while");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_For, function(self, output){
        output.print("fo" + "r");
        output.space();
        output.with_parens(function(){
            if (self.init && !(self.init instanceof AST_EmptyStatement)) {
                if (self.init instanceof AST_Definitions) {
                    self.init.print(output);
                } else {
                    parenthesize_for_noin(self.init, output, true);
                }
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.condition) {
                self.condition.print(output);
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.step) {
                self.step.print(output);
            }
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_ForIn, function(self, output){
        output.print("fo" + "r");
        output.space();
        output.with_parens(function(){
            self.init.print(output);
            output.space();
            output.print("in");
            output.space();
            self.object.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_With, function(self, output){
        output.print("with");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        self._do_print_body(output);
    });

    /* -----[ functions ]----- */
    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword){
        var self = this;
        if (!nokeyword) {
            output.print("function");
        }
        if (self.name) {
            output.space();
            self.name.print(output);
        }
        output.with_parens(function(){
            self.argnames.forEach(function(arg, i){
                if (i) output.comma();
                arg.print(output);
            });
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Lambda, function(self, output){
        self._do_print(output);
    });

    /* -----[ exits ]----- */
    AST_Exit.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.value) {
            output.space();
            this.value.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Return, function(self, output){
        self._do_print(output, "return");
    });
    DEFPRINT(AST_Throw, function(self, output){
        self._do_print(output, "throw");
    });

    /* -----[ loop control ]----- */
    AST_LoopControl.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        if (this.label) {
            output.space();
            this.label.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Break, function(self, output){
        self._do_print(output, "break");
    });
    DEFPRINT(AST_Continue, function(self, output){
        self._do_print(output, "continue");
    });

    /* -----[ if ]----- */
    function make_then(self, output) {
        if (output.option("bracketize")) {
            make_block(self.body, output);
            return;
        }
        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block brackets if needed.
        if (!self.body)
            return output.force_semicolon();
        if (self.body instanceof AST_Do
            && !output.option("screw_ie8")) {
            // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
            // croaks with "syntax error" on code like this: if (foo)
            // do ... while(cond); else ...  we need block brackets
            // around do/while
            make_block(self.body, output);
            return;
        }
        var b = self.body;
        while (true) {
            if (b instanceof AST_If) {
                if (!b.alternative) {
                    make_block(self.body, output);
                    return;
                }
                b = b.alternative;
            }
            else if (b instanceof AST_StatementWithBody) {
                b = b.body;
            }
            else break;
        }
        force_statement(self.body, output);
    };
    DEFPRINT(AST_If, function(self, output){
        output.print("if");
        output.space();
        output.with_parens(function(){
            self.condition.print(output);
        });
        output.space();
        if (self.alternative) {
            make_then(self, output);
            output.space();
            output.print("else");
            output.space();
            force_statement(self.alternative, output);
        } else {
            self._do_print_body(output);
        }
    });

    /* -----[ switch ]----- */
    DEFPRINT(AST_Switch, function(self, output){
        output.print("switch");
        output.space();
        output.with_parens(function(){
            self.expression.print(output);
        });
        output.space();
        if (self.body.length > 0) output.with_block(function(){
            self.body.forEach(function(stmt, i){
                if (i) output.newline();
                output.indent(true);
                stmt.print(output);
            });
        });
        else output.print("{}");
    });
    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output){
        if (this.body.length > 0) {
            output.newline();
            this.body.forEach(function(stmt){
                output.indent();
                stmt.print(output);
                output.newline();
            });
        }
    });
    DEFPRINT(AST_Default, function(self, output){
        output.print("default:");
        self._do_print_body(output);
    });
    DEFPRINT(AST_Case, function(self, output){
        output.print("case");
        output.space();
        self.expression.print(output);
        output.print(":");
        self._do_print_body(output);
    });

    /* -----[ exceptions ]----- */
    DEFPRINT(AST_Try, function(self, output){
        output.print("try");
        output.space();
        print_bracketed(self.body, output);
        if (self.bcatch) {
            output.space();
            self.bcatch.print(output);
        }
        if (self.bfinally) {
            output.space();
            self.bfinally.print(output);
        }
    });
    DEFPRINT(AST_Catch, function(self, output){
        output.print("catch");
        output.space();
        output.with_parens(function(){
            self.argname.print(output);
        });
        output.space();
        print_bracketed(self.body, output);
    });
    DEFPRINT(AST_Finally, function(self, output){
        output.print("finally");
        output.space();
        print_bracketed(self.body, output);
    });

    /* -----[ var/const ]----- */
    AST_Definitions.DEFMETHOD("_do_print", function(output, kind){
        output.print(kind);
        output.space();
        this.definitions.forEach(function(def, i){
            if (i) output.comma();
            def.print(output);
        });
        var p = output.parent();
        var in_for = p instanceof AST_For || p instanceof AST_ForIn;
        var avoid_semicolon = in_for && p.init === this;
        if (!avoid_semicolon)
            output.semicolon();
    });
    DEFPRINT(AST_Var, function(self, output){
        self._do_print(output, "var");
    });
    DEFPRINT(AST_Const, function(self, output){
        self._do_print(output, "const");
    });

    function parenthesize_for_noin(node, output, noin) {
        if (!noin) node.print(output);
        else try {
            // need to take some precautions here:
            //    https://github.com/mishoo/UglifyJS2/issues/60
            node.walk(new TreeWalker(function(node){
                if (node instanceof AST_Binary && node.operator == "in")
                    throw output;
            }));
            node.print(output);
        } catch(ex) {
            if (ex !== output) throw ex;
            node.print(output, true);
        }
    };

    DEFPRINT(AST_VarDef, function(self, output){
        self.name.print(output);
        if (self.value) {
            output.space();
            output.print("=");
            output.space();
            var p = output.parent(1);
            var noin = p instanceof AST_For || p instanceof AST_ForIn;
            parenthesize_for_noin(self.value, output, noin);
        }
    });

    /* -----[ other expressions ]----- */
    DEFPRINT(AST_Call, function(self, output){
        self.expression.print(output);
        if (self instanceof AST_New && no_constructor_parens(self, output))
            return;
        output.with_parens(function(){
            self.args.forEach(function(expr, i){
                if (i) output.comma();
                expr.print(output);
            });
        });
    });
    DEFPRINT(AST_New, function(self, output){
        output.print("new");
        output.space();
        AST_Call.prototype._codegen(self, output);
    });

    AST_Seq.DEFMETHOD("_do_print", function(output){
        this.car.print(output);
        if (this.cdr) {
            output.comma();
            if (output.should_break()) {
                output.newline();
                output.indent();
            }
            this.cdr.print(output);
        }
    });
    DEFPRINT(AST_Seq, function(self, output){
        self._do_print(output);
        // var p = output.parent();
        // if (p instanceof AST_Statement) {
        //     output.with_indent(output.next_indent(), function(){
        //         self._do_print(output);
        //     });
        // } else {
        //     self._do_print(output);
        // }
    });
    DEFPRINT(AST_Dot, function(self, output){
        var expr = self.expression;
        expr.print(output);
        if (expr instanceof AST_Number && expr.getValue() >= 0) {
            if (!/[xa-f.]/i.test(output.last())) {
                output.print(".");
            }
        }
        output.print(".");
        // the name after dot would be mapped about here.
        output.add_mapping(self.end);
        output.print_name(self.property);
    });
    DEFPRINT(AST_Sub, function(self, output){
        self.expression.print(output);
        output.print("[");
        self.property.print(output);
        output.print("]");
    });
    DEFPRINT(AST_UnaryPrefix, function(self, output){
        var op = self.operator;
        output.print(op);
        if (/^[a-z]/i.test(op)
            || (/[+-]$/.test(op)
                && self.expression instanceof AST_UnaryPrefix
                && /^[+-]/.test(self.expression.operator))) {
            output.space();
        }
        self.expression.print(output);
    });
    DEFPRINT(AST_UnaryPostfix, function(self, output){
        self.expression.print(output);
        output.print(self.operator);
    });
    DEFPRINT(AST_Binary, function(self, output){
        self.left.print(output);
        output.space();
        output.print(self.operator);
        if (self.operator == "<"
            && self.right instanceof AST_UnaryPrefix
            && self.right.operator == "!"
            && self.right.expression instanceof AST_UnaryPrefix
            && self.right.expression.operator == "--") {
            // space is mandatory to avoid outputting <!--
            // http://javascript.spec.whatwg.org/#comment-syntax
            output.print(" ");
        } else {
            // the space is optional depending on "beautify"
            output.space();
        }
        self.right.print(output);
    });
    DEFPRINT(AST_Conditional, function(self, output){
        self.condition.print(output);
        output.space();
        output.print("?");
        output.space();
        self.consequent.print(output);
        output.space();
        output.colon();
        self.alternative.print(output);
    });

    /* -----[ literals ]----- */
    DEFPRINT(AST_Array, function(self, output){
        output.with_square(function(){
            var a = self.elements, len = a.length;
            if (len > 0) output.space();
            a.forEach(function(exp, i){
                if (i) output.comma();
                exp.print(output);
                // If the final element is a hole, we need to make sure it
                // doesn't look like a trailing comma, by inserting an actual
                // trailing comma.
                if (i === len - 1 && exp instanceof AST_Hole)
                  output.comma();
            });
            if (len > 0) output.space();
        });
    });
    DEFPRINT(AST_Object, function(self, output){
        if (self.properties.length > 0) output.with_block(function(){
            self.properties.forEach(function(prop, i){
                if (i) {
                    output.print(",");
                    output.newline();
                }
                output.indent();
                prop.print(output);
            });
            output.newline();
        });
        else output.print("{}");
    });
    DEFPRINT(AST_ObjectKeyVal, function(self, output){
        var key = self.key;
        if (output.option("quote_keys")) {
            output.print_string(key + "");
        } else if ((typeof key == "number"
                    || !output.option("beautify")
                    && +key + "" == key)
                   && parseFloat(key) >= 0) {
            output.print(make_num(key));
        } else if (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) {
            output.print_name(key);
        } else {
            output.print_string(key);
        }
        output.colon();
        self.value.print(output);
    });
    DEFPRINT(AST_ObjectSetter, function(self, output){
        output.print("set");
        output.space();
        self.key.print(output);
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_ObjectGetter, function(self, output){
        output.print("get");
        output.space();
        self.key.print(output);
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_Symbol, function(self, output){
        var def = self.definition();
        output.print_name(def ? def.mangled_name || def.name : self.name);
    });
    DEFPRINT(AST_Undefined, function(self, output){
        output.print("void 0");
    });
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_Infinity, function(self, output){
        output.print("1/0");
    });
    DEFPRINT(AST_NaN, function(self, output){
        output.print("0/0");
    });
    DEFPRINT(AST_This, function(self, output){
        output.print("this");
    });
    DEFPRINT(AST_Constant, function(self, output){
        output.print(self.getValue());
    });
    DEFPRINT(AST_String, function(self, output){
        output.print_string(self.getValue());
    });
    DEFPRINT(AST_Number, function(self, output){
        output.print(make_num(self.getValue()));
    });

    function regexp_safe_literal(code) {
        return [
            0x5c   , // \
            0x2f   , // /
            0x2e   , // .
            0x2b   , // +
            0x2a   , // *
            0x3f   , // ?
            0x28   , // (
            0x29   , // )
            0x5b   , // [
            0x5d   , // ]
            0x7b   , // {
            0x7d   , // }
            0x24   , // $
            0x5e   , // ^
            0x3a   , // :
            0x7c   , // |
            0x21   , // !
            0x0a   , // \n
            0x0d   , // \r
            0x00   , // \0
            0xfeff , // Unicode BOM
            0x2028 , // unicode "line separator"
            0x2029 , // unicode "paragraph separator"
        ].indexOf(code) < 0;
    };

    DEFPRINT(AST_RegExp, function(self, output){
        var str = self.getValue().toString();
        if (output.option("ascii_only")) {
            str = output.to_ascii(str);
        } else if (output.option("unescape_regexps")) {
            str = str.split("\\\\").map(function(str){
                return str.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function(s){
                    var code = parseInt(s.substr(2), 16);
                    return regexp_safe_literal(code) ? String.fromCharCode(code) : s;
                });
            }).join("\\\\");
        }
        output.print(str);
        var p = output.parent();
        if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self)
            output.print(" ");
    });

    function force_statement(stat, output) {
        if (output.option("bracketize")) {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.print("{}");
            else if (stat instanceof AST_BlockStatement)
                stat.print(output);
            else output.with_block(function(){
                output.indent();
                stat.print(output);
                output.newline();
            });
        } else {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.force_semicolon();
            else
                stat.print(output);
        }
    };

    // return true if the node at the top of the stack (that means the
    // innermost node in the current output) is lexically the first in
    // a statement.
    function first_in_statement(output) {
        var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
        while (i > 0) {
            if (p instanceof AST_Statement && p.body === node)
                return true;
            if ((p instanceof AST_Seq           && p.car === node        ) ||
                (p instanceof AST_Call          && p.expression === node && !(p instanceof AST_New) ) ||
                (p instanceof AST_Dot           && p.expression === node ) ||
                (p instanceof AST_Sub           && p.expression === node ) ||
                (p instanceof AST_Conditional   && p.condition === node  ) ||
                (p instanceof AST_Binary        && p.left === node       ) ||
                (p instanceof AST_UnaryPostfix  && p.expression === node ))
            {
                node = p;
                p = a[--i];
            } else {
                return false;
            }
        }
    };

    // self should be AST_New.  decide if we want to show parens or not.
    function no_constructor_parens(self, output) {
        return self.args.length == 0 && !output.option("beautify");
    };

    function best_of(a) {
        var best = a[0], len = best.length;
        for (var i = 1; i < a.length; ++i) {
            if (a[i].length < len) {
                best = a[i];
                len = best.length;
            }
        }
        return best;
    };

    function make_num(num) {
        var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
        if (Math.floor(num) === num) {
            if (num >= 0) {
                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                       "0" + num.toString(8)); // same.
            } else {
                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                       "-0" + (-num).toString(8)); // same.
            }
            if ((m = /^(.*?)(0+)$/.exec(num))) {
                a.push(m[1] + "e" + m[2].length);
            }
        } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
            a.push(m[2] + "e-" + (m[1].length + m[2].length),
                   str.substr(str.indexOf(".")));
        }
        return best_of(a);
    };

    function make_block(stmt, output) {
        if (stmt instanceof AST_BlockStatement) {
            stmt.print(output);
            return;
        }
        output.with_block(function(){
            output.indent();
            stmt.print(output);
            output.newline();
        });
    };

    /* -----[ source map generators ]----- */

    function DEFMAP(nodetype, generator) {
        nodetype.DEFMETHOD("add_source_map", function(stream){
            generator(this, stream);
        });
    };

    // We could easily add info for ALL nodes, but it seems to me that
    // would be quite wasteful, hence this noop in the base class.
    DEFMAP(AST_Node, noop);

    function basic_sourcemap_gen(self, output) {
        output.add_mapping(self.start);
    };

    // XXX: I'm not exactly sure if we need it for all of these nodes,
    // or if we should add even more.

    DEFMAP(AST_Directive, basic_sourcemap_gen);
    DEFMAP(AST_Debugger, basic_sourcemap_gen);
    DEFMAP(AST_Symbol, basic_sourcemap_gen);
    DEFMAP(AST_Jump, basic_sourcemap_gen);
    DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
    DEFMAP(AST_LabeledStatement, noop); // since the label symbol will mark it
    DEFMAP(AST_Lambda, basic_sourcemap_gen);
    DEFMAP(AST_Switch, basic_sourcemap_gen);
    DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
    DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
    DEFMAP(AST_Toplevel, noop);
    DEFMAP(AST_New, basic_sourcemap_gen);
    DEFMAP(AST_Try, basic_sourcemap_gen);
    DEFMAP(AST_Catch, basic_sourcemap_gen);
    DEFMAP(AST_Finally, basic_sourcemap_gen);
    DEFMAP(AST_Definitions, basic_sourcemap_gen);
    DEFMAP(AST_Constant, basic_sourcemap_gen);
    DEFMAP(AST_ObjectProperty, function(self, output){
        output.add_mapping(self.start, self.key);
    });

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

function Compressor(options, false_by_default) {
    if (!(this instanceof Compressor))
        return new Compressor(options, false_by_default);
    TreeTransformer.call(this, this.before, this.after);
    this.options = defaults(options, {
        sequences     : !false_by_default,
        properties    : !false_by_default,
        dead_code     : !false_by_default,
        drop_debugger : !false_by_default,
        unsafe        : false,
        unsafe_comps  : false,
        conditionals  : !false_by_default,
        comparisons   : !false_by_default,
        evaluate      : !false_by_default,
        booleans      : !false_by_default,
        loops         : !false_by_default,
        unused        : !false_by_default,
        hoist_funs    : !false_by_default,
        keep_fargs    : false,
        hoist_vars    : false,
        if_return     : !false_by_default,
        join_vars     : !false_by_default,
        cascade       : !false_by_default,
        side_effects  : !false_by_default,
        pure_getters  : false,
        pure_funcs    : null,
        negate_iife   : !false_by_default,
        screw_ie8     : false,
        drop_console  : false,
        angular       : false,

        warnings      : true,
        global_defs   : {}
    }, true);
};

Compressor.prototype = new TreeTransformer;
merge(Compressor.prototype, {
    option: function(key) { return this.options[key] },
    warn: function() {
        if (this.options.warnings)
            AST_Node.warn.apply(AST_Node, arguments);
    },
    before: function(node, descend, in_list) {
        if (node._squeezed) return node;
        var was_scope = false;
        if (node instanceof AST_Scope) {
            node = node.hoist_declarations(this);
            was_scope = true;
        }
        descend(node, this);
        node = node.optimize(this);
        if (was_scope && node instanceof AST_Scope) {
            node.drop_unused(this);
            descend(node, this);
        }
        node._squeezed = true;
        return node;
    }
});

(function(){

    function OPT(node, optimizer) {
        node.DEFMETHOD("optimize", function(compressor){
            var self = this;
            if (self._optimized) return self;
            var opt = optimizer(self, compressor);
            opt._optimized = true;
            if (opt === self) return opt;
            return opt.transform(compressor);
        });
    };

    OPT(AST_Node, function(self, compressor){
        return self;
    });

    AST_Node.DEFMETHOD("equivalent_to", function(node){
        // XXX: this is a rather expensive way to test two node's equivalence:
        return this.print_to_string() == node.print_to_string();
    });

    function make_node(ctor, orig, props) {
        if (!props) props = {};
        if (orig) {
            if (!props.start) props.start = orig.start;
            if (!props.end) props.end = orig.end;
        }
        return new ctor(props);
    };

    function make_node_from_constant(compressor, val, orig) {
        // XXX: WIP.
        // if (val instanceof AST_Node) return val.transform(new TreeTransformer(null, function(node){
        //     if (node instanceof AST_SymbolRef) {
        //         var scope = compressor.find_parent(AST_Scope);
        //         var def = scope.find_variable(node);
        //         node.thedef = def;
        //         return node;
        //     }
        // })).transform(compressor);

        if (val instanceof AST_Node) return val.transform(compressor);
        switch (typeof val) {
          case "string":
            return make_node(AST_String, orig, {
                value: val
            }).optimize(compressor);
          case "number":
            return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
                value: val
            }).optimize(compressor);
          case "boolean":
            return make_node(val ? AST_True : AST_False, orig).optimize(compressor);
          case "undefined":
            return make_node(AST_Undefined, orig).optimize(compressor);
          default:
            if (val === null) {
                return make_node(AST_Null, orig).optimize(compressor);
            }
            if (val instanceof RegExp) {
                return make_node(AST_RegExp, orig).optimize(compressor);
            }
            throw new Error(string_template("Can't handle constant of type: {type}", {
                type: typeof val
            }));
        }
    };

    function as_statement_array(thing) {
        if (thing === null) return [];
        if (thing instanceof AST_BlockStatement) return thing.body;
        if (thing instanceof AST_EmptyStatement) return [];
        if (thing instanceof AST_Statement) return [ thing ];
        throw new Error("Can't convert thing to statement array");
    };

    function is_empty(thing) {
        if (thing === null) return true;
        if (thing instanceof AST_EmptyStatement) return true;
        if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
        return false;
    };

    function loop_body(x) {
        if (x instanceof AST_Switch) return x;
        if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
            return (x.body instanceof AST_BlockStatement ? x.body : x);
        }
        return x;
    };

    function tighten_body(statements, compressor) {
        var CHANGED;
        do {
            CHANGED = false;
            if (compressor.option("angular")) {
                statements = process_for_angular(statements);
            }
            statements = eliminate_spurious_blocks(statements);
            if (compressor.option("dead_code")) {
                statements = eliminate_dead_code(statements, compressor);
            }
            if (compressor.option("if_return")) {
                statements = handle_if_return(statements, compressor);
            }
            if (compressor.option("sequences")) {
                statements = sequencesize(statements, compressor);
            }
            if (compressor.option("join_vars")) {
                statements = join_consecutive_vars(statements, compressor);
            }
        } while (CHANGED);

        if (compressor.option("negate_iife")) {
            negate_iifes(statements, compressor);
        }

        return statements;

        function process_for_angular(statements) {
            function make_injector(func, name) {
                return make_node(AST_SimpleStatement, func, {
                    body: make_node(AST_Assign, func, {
                        operator: "=",
                        left: make_node(AST_Dot, name, {
                            expression: make_node(AST_SymbolRef, name, name),
                            property: "$inject"
                        }),
                        right: make_node(AST_Array, func, {
                            elements: func.argnames.map(function(sym){
                                return make_node(AST_String, sym, { value: sym.name });
                            })
                        })
                    })
                });
            }
            return statements.reduce(function(a, stat){
                a.push(stat);
                var token = stat.start;
                var comments = token.comments_before;
                if (comments && comments.length > 0) {
                    var last = comments.pop();
                    if (/@ngInject/.test(last.value)) {
                        // case 1: defun
                        if (stat instanceof AST_Defun) {
                            a.push(make_injector(stat, stat.name));
                        }
                        else if (stat instanceof AST_Definitions) {
                            stat.definitions.forEach(function(def){
                                if (def.value && def.value instanceof AST_Lambda) {
                                    a.push(make_injector(def.value, def.name));
                                }
                            });
                        }
                        else {
                            compressor.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]", token);
                        }
                    }
                }
                return a;
            }, []);
        }

        function eliminate_spurious_blocks(statements) {
            var seen_dirs = [];
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_BlockStatement) {
                    CHANGED = true;
                    a.push.apply(a, eliminate_spurious_blocks(stat.body));
                } else if (stat instanceof AST_EmptyStatement) {
                    CHANGED = true;
                } else if (stat instanceof AST_Directive) {
                    if (seen_dirs.indexOf(stat.value) < 0) {
                        a.push(stat);
                        seen_dirs.push(stat.value);
                    } else {
                        CHANGED = true;
                    }
                } else {
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function handle_if_return(statements, compressor) {
            var self = compressor.self();
            var in_lambda = self instanceof AST_Lambda;
            var ret = [];
            loop: for (var i = statements.length; --i >= 0;) {
                var stat = statements[i];
                switch (true) {
                  case (in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0):
                    CHANGED = true;
                    // note, ret.length is probably always zero
                    // because we drop unreachable code before this
                    // step.  nevertheless, it's good to check.
                    continue loop;
                  case stat instanceof AST_If:
                    if (stat.body instanceof AST_Return) {
                        //---
                        // pretty silly case, but:
                        // if (foo()) return; return; ==> foo(); return;
                        if (((in_lambda && ret.length == 0)
                             || (ret[0] instanceof AST_Return && !ret[0].value))
                            && !stat.body.value && !stat.alternative) {
                            CHANGED = true;
                            var cond = make_node(AST_SimpleStatement, stat.condition, {
                                body: stat.condition
                            });
                            ret.unshift(cond);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; return y; ==> return foo() ? x : y;
                        if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0];
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
                        if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.alternative = ret[0] || make_node(AST_Return, stat, {
                                value: make_node(AST_Undefined, stat)
                            });
                            ret[0] = stat.transform(compressor);
                            continue loop;
                        }
                        //---
                        // if (foo()) return; [ else x... ]; y... ==> if (!foo()) { x...; y... }
                        if (!stat.body.value && in_lambda) {
                            CHANGED = true;
                            stat = stat.clone();
                            stat.condition = stat.condition.negate(compressor);
                            stat.body = make_node(AST_BlockStatement, stat, {
                                body: as_statement_array(stat.alternative).concat(ret)
                            });
                            stat.alternative = null;
                            ret = [ stat.transform(compressor) ];
                            continue loop;
                        }
                        //---
                        if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement
                            && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
                            CHANGED = true;
                            ret.push(make_node(AST_Return, ret[0], {
                                value: make_node(AST_Undefined, ret[0])
                            }).transform(compressor));
                            ret = as_statement_array(stat.alternative).concat(ret);
                            ret.unshift(stat);
                            continue loop;
                        }
                    }

                    var ab = aborts(stat.body);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab);
                        }
                        CHANGED = true;
                        var body = as_statement_array(stat.body).slice(0, -1);
                        stat = stat.clone();
                        stat.condition = stat.condition.negate(compressor);
                        stat.body = make_node(AST_BlockStatement, stat, {
                            body: as_statement_array(stat.alternative).concat(ret)
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat, {
                            body: body
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    var ab = aborts(stat.alternative);
                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
                               || (ab instanceof AST_Continue && self === loop_body(lct))
                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
                        if (ab.label) {
                            remove(ab.label.thedef.references, ab);
                        }
                        CHANGED = true;
                        stat = stat.clone();
                        stat.body = make_node(AST_BlockStatement, stat.body, {
                            body: as_statement_array(stat.body).concat(ret)
                        });
                        stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                            body: as_statement_array(stat.alternative).slice(0, -1)
                        });
                        ret = [ stat.transform(compressor) ];
                        continue loop;
                    }

                    ret.unshift(stat);
                    break;
                  default:
                    ret.unshift(stat);
                    break;
                }
            }
            return ret;
        };

        function eliminate_dead_code(statements, compressor) {
            var has_quit = false;
            var orig = statements.length;
            var self = compressor.self();
            statements = statements.reduce(function(a, stat){
                if (has_quit) {
                    extract_declarations_from_unreachable_code(compressor, stat, a);
                } else {
                    if (stat instanceof AST_LoopControl) {
                        var lct = compressor.loopcontrol_target(stat.label);
                        if ((stat instanceof AST_Break
                             && lct instanceof AST_BlockStatement
                             && loop_body(lct) === self) || (stat instanceof AST_Continue
                                                             && loop_body(lct) === self)) {
                            if (stat.label) {
                                remove(stat.label.thedef.references, stat);
                            }
                        } else {
                            a.push(stat);
                        }
                    } else {
                        a.push(stat);
                    }
                    if (aborts(stat)) has_quit = true;
                }
                return a;
            }, []);
            CHANGED = statements.length != orig;
            return statements;
        };

        function sequencesize(statements, compressor) {
            if (statements.length < 2) return statements;
            var seq = [], ret = [];
            function push_seq() {
                seq = AST_Seq.from_array(seq);
                if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
                    body: seq
                }));
                seq = [];
            };
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) seq.push(stat.body);
                else push_seq(), ret.push(stat);
            });
            push_seq();
            ret = sequencesize_2(ret, compressor);
            CHANGED = ret.length != statements.length;
            return ret;
        };

        function sequencesize_2(statements, compressor) {
            function cons_seq(right) {
                ret.pop();
                var left = prev.body;
                if (left instanceof AST_Seq) {
                    left.add(right);
                } else {
                    left = AST_Seq.cons(left, right);
                }
                return left.transform(compressor);
            };
            var ret = [], prev = null;
            statements.forEach(function(stat){
                if (prev) {
                    if (stat instanceof AST_For) {
                        var opera = {};
                        try {
                            prev.body.walk(new TreeWalker(function(node){
                                if (node instanceof AST_Binary && node.operator == "in")
                                    throw opera;
                            }));
                            if (stat.init && !(stat.init instanceof AST_Definitions)) {
                                stat.init = cons_seq(stat.init);
                            }
                            else if (!stat.init) {
                                stat.init = prev.body;
                                ret.pop();
                            }
                        } catch(ex) {
                            if (ex !== opera) throw ex;
                        }
                    }
                    else if (stat instanceof AST_If) {
                        stat.condition = cons_seq(stat.condition);
                    }
                    else if (stat instanceof AST_With) {
                        stat.expression = cons_seq(stat.expression);
                    }
                    else if (stat instanceof AST_Exit && stat.value) {
                        stat.value = cons_seq(stat.value);
                    }
                    else if (stat instanceof AST_Exit) {
                        stat.value = cons_seq(make_node(AST_Undefined, stat));
                    }
                    else if (stat instanceof AST_Switch) {
                        stat.expression = cons_seq(stat.expression);
                    }
                }
                ret.push(stat);
                prev = stat instanceof AST_SimpleStatement ? stat : null;
            });
            return ret;
        };

        function join_consecutive_vars(statements, compressor) {
            var prev = null;
            return statements.reduce(function(a, stat){
                if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
                    prev.definitions = prev.definitions.concat(stat.definitions);
                    CHANGED = true;
                }
                else if (stat instanceof AST_For
                         && prev instanceof AST_Definitions
                         && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                    CHANGED = true;
                    a.pop();
                    if (stat.init) {
                        stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                    } else {
                        stat.init = prev;
                    }
                    a.push(stat);
                    prev = stat;
                }
                else {
                    prev = stat;
                    a.push(stat);
                }
                return a;
            }, []);
        };

        function negate_iifes(statements, compressor) {
            statements.forEach(function(stat){
                if (stat instanceof AST_SimpleStatement) {
                    stat.body = (function transform(thing) {
                        return thing.transform(new TreeTransformer(function(node){
                            if (node instanceof AST_Call && node.expression instanceof AST_Function) {
                                return make_node(AST_UnaryPrefix, node, {
                                    operator: "!",
                                    expression: node
                                });
                            }
                            else if (node instanceof AST_Call) {
                                node.expression = transform(node.expression);
                            }
                            else if (node instanceof AST_Seq) {
                                node.car = transform(node.car);
                            }
                            else if (node instanceof AST_Conditional) {
                                var expr = transform(node.condition);
                                if (expr !== node.condition) {
                                    // it has been negated, reverse
                                    node.condition = expr;
                                    var tmp = node.consequent;
                                    node.consequent = node.alternative;
                                    node.alternative = tmp;
                                }
                            }
                            return node;
                        }));
                    })(stat.body);
                }
            });
        };

    };

    function extract_declarations_from_unreachable_code(compressor, stat, target) {
        compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
        stat.walk(new TreeWalker(function(node){
            if (node instanceof AST_Definitions) {
                compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                node.remove_initializers();
                target.push(node);
                return true;
            }
            if (node instanceof AST_Defun) {
                target.push(node);
                return true;
            }
            if (node instanceof AST_Scope) {
                return true;
            }
        }));
    };

    /* -----[ boolean/negation helpers ]----- */

    // methods to determine whether an expression has a boolean result type
    (function (def){
        var unary_bool = [ "!", "delete" ];
        var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
        def(AST_Node, function(){ return false });
        def(AST_UnaryPrefix, function(){
            return member(this.operator, unary_bool);
        });
        def(AST_Binary, function(){
            return member(this.operator, binary_bool) ||
                ( (this.operator == "&&" || this.operator == "||") &&
                  this.left.is_boolean() && this.right.is_boolean() );
        });
        def(AST_Conditional, function(){
            return this.consequent.is_boolean() && this.alternative.is_boolean();
        });
        def(AST_Assign, function(){
            return this.operator == "=" && this.right.is_boolean();
        });
        def(AST_Seq, function(){
            return this.cdr.is_boolean();
        });
        def(AST_True, function(){ return true });
        def(AST_False, function(){ return true });
    })(function(node, func){
        node.DEFMETHOD("is_boolean", func);
    });

    // methods to determine if an expression has a string result type
    (function (def){
        def(AST_Node, function(){ return false });
        def(AST_String, function(){ return true });
        def(AST_UnaryPrefix, function(){
            return this.operator == "typeof";
        });
        def(AST_Binary, function(compressor){
            return this.operator == "+" &&
                (this.left.is_string(compressor) || this.right.is_string(compressor));
        });
        def(AST_Assign, function(compressor){
            return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
        });
        def(AST_Seq, function(compressor){
            return this.cdr.is_string(compressor);
        });
        def(AST_Conditional, function(compressor){
            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
        });
        def(AST_Call, function(compressor){
            return compressor.option("unsafe")
                && this.expression instanceof AST_SymbolRef
                && this.expression.name == "String"
                && this.expression.undeclared();
        });
    })(function(node, func){
        node.DEFMETHOD("is_string", func);
    });

    function best_of(ast1, ast2) {
        return ast1.print_to_string().length >
            ast2.print_to_string().length
            ? ast2 : ast1;
    };

    // methods to evaluate a constant expression
    (function (def){
        // The evaluate method returns an array with one or two
        // elements.  If the node has been successfully reduced to a
        // constant, then the second element tells us the value;
        // otherwise the second element is missing.  The first element
        // of the array is always an AST_Node descendant; if
        // evaluation was successful it's a node that represents the
        // constant; otherwise it's the original or a replacement node.
        AST_Node.DEFMETHOD("evaluate", function(compressor){
            if (!compressor.option("evaluate")) return [ this ];
            try {
                var val = this._eval(compressor);
                return [ best_of(make_node_from_constant(compressor, val, this), this), val ];
            } catch(ex) {
                if (ex !== def) throw ex;
                return [ this ];
            }
        });
        def(AST_Statement, function(){
            throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
        });
        def(AST_Function, function(){
            // XXX: AST_Function inherits from AST_Scope, which itself
            // inherits from AST_Statement; however, an AST_Function
            // isn't really a statement.  This could byte in other
            // places too. :-( Wish JS had multiple inheritance.
            throw def;
        });
        function ev(node, compressor) {
            if (!compressor) throw new Error("Compressor must be passed");

            return node._eval(compressor);
        };
        def(AST_Node, function(){
            throw def;          // not constant
        });
        def(AST_Constant, function(){
            return this.getValue();
        });
        def(AST_UnaryPrefix, function(compressor){
            var e = this.expression;
            switch (this.operator) {
              case "!": return !ev(e, compressor);
              case "typeof":
                // Function would be evaluated to an array and so typeof would
                // incorrectly return 'object'. Hence making is a special case.
                if (e instanceof AST_Function) return typeof function(){};

                e = ev(e, compressor);

                // typeof <RegExp> returns "object" or "function" on different platforms
                // so cannot evaluate reliably
                if (e instanceof RegExp) throw def;

                return typeof e;
              case "void": return void ev(e, compressor);
              case "~": return ~ev(e, compressor);
              case "-":
                e = ev(e, compressor);
                if (e === 0) throw def;
                return -e;
              case "+": return +ev(e, compressor);
            }
            throw def;
        });
        def(AST_Binary, function(c){
            var left = this.left, right = this.right;
            switch (this.operator) {
              case "&&"         : return ev(left, c) &&         ev(right, c);
              case "||"         : return ev(left, c) ||         ev(right, c);
              case "|"          : return ev(left, c) |          ev(right, c);
              case "&"          : return ev(left, c) &          ev(right, c);
              case "^"          : return ev(left, c) ^          ev(right, c);
              case "+"          : return ev(left, c) +          ev(right, c);
              case "*"          : return ev(left, c) *          ev(right, c);
              case "/"          : return ev(left, c) /          ev(right, c);
              case "%"          : return ev(left, c) %          ev(right, c);
              case "-"          : return ev(left, c) -          ev(right, c);
              case "<<"         : return ev(left, c) <<         ev(right, c);
              case ">>"         : return ev(left, c) >>         ev(right, c);
              case ">>>"        : return ev(left, c) >>>        ev(right, c);
              case "=="         : return ev(left, c) ==         ev(right, c);
              case "==="        : return ev(left, c) ===        ev(right, c);
              case "!="         : return ev(left, c) !=         ev(right, c);
              case "!=="        : return ev(left, c) !==        ev(right, c);
              case "<"          : return ev(left, c) <          ev(right, c);
              case "<="         : return ev(left, c) <=         ev(right, c);
              case ">"          : return ev(left, c) >          ev(right, c);
              case ">="         : return ev(left, c) >=         ev(right, c);
              case "in"         : return ev(left, c) in         ev(right, c);
              case "instanceof" : return ev(left, c) instanceof ev(right, c);
            }
            throw def;
        });
        def(AST_Conditional, function(compressor){
            return ev(this.condition, compressor)
                ? ev(this.consequent, compressor)
                : ev(this.alternative, compressor);
        });
        def(AST_SymbolRef, function(compressor){
            var d = this.definition();
            if (d && d.constant && d.init) return ev(d.init, compressor);
            throw def;
        });
        def(AST_Dot, function(compressor){
            if (compressor.option("unsafe") && this.property == "length") {
                var str = ev(this.expression, compressor);
                if (typeof str == "string")
                    return str.length;
            }
            throw def;
        });
    })(function(node, func){
        node.DEFMETHOD("_eval", func);
    });

    // method to negate an expression
    (function(def){
        function basic_negation(exp) {
            return make_node(AST_UnaryPrefix, exp, {
                operator: "!",
                expression: exp
            });
        };
        def(AST_Node, function(){
            return basic_negation(this);
        });
        def(AST_Statement, function(){
            throw new Error("Cannot negate a statement");
        });
        def(AST_Function, function(){
            return basic_negation(this);
        });
        def(AST_UnaryPrefix, function(){
            if (this.operator == "!")
                return this.expression;
            return basic_negation(this);
        });
        def(AST_Seq, function(compressor){
            var self = this.clone();
            self.cdr = self.cdr.negate(compressor);
            return self;
        });
        def(AST_Conditional, function(compressor){
            var self = this.clone();
            self.consequent = self.consequent.negate(compressor);
            self.alternative = self.alternative.negate(compressor);
            return best_of(basic_negation(this), self);
        });
        def(AST_Binary, function(compressor){
            var self = this.clone(), op = this.operator;
            if (compressor.option("unsafe_comps")) {
                switch (op) {
                  case "<=" : self.operator = ">"  ; return self;
                  case "<"  : self.operator = ">=" ; return self;
                  case ">=" : self.operator = "<"  ; return self;
                  case ">"  : self.operator = "<=" ; return self;
                }
            }
            switch (op) {
              case "==" : self.operator = "!="; return self;
              case "!=" : self.operator = "=="; return self;
              case "===": self.operator = "!=="; return self;
              case "!==": self.operator = "==="; return self;
              case "&&":
                self.operator = "||";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
              case "||":
                self.operator = "&&";
                self.left = self.left.negate(compressor);
                self.right = self.right.negate(compressor);
                return best_of(basic_negation(this), self);
            }
            return basic_negation(this);
        });
    })(function(node, func){
        node.DEFMETHOD("negate", function(compressor){
            return func.call(this, compressor);
        });
    });

    // determine if expression has side effects
    (function(def){
        def(AST_Node, function(compressor){ return true });

        def(AST_EmptyStatement, function(compressor){ return false });
        def(AST_Constant, function(compressor){ return false });
        def(AST_This, function(compressor){ return false });

        def(AST_Call, function(compressor){
            var pure = compressor.option("pure_funcs");
            if (!pure) return true;
            return pure.indexOf(this.expression.print_to_string()) < 0;
        });

        def(AST_Block, function(compressor){
            for (var i = this.body.length; --i >= 0;) {
                if (this.body[i].has_side_effects(compressor))
                    return true;
            }
            return false;
        });

        def(AST_SimpleStatement, function(compressor){
            return this.body.has_side_effects(compressor);
        });
        def(AST_Defun, function(compressor){ return true });
        def(AST_Function, function(compressor){ return false });
        def(AST_Binary, function(compressor){
            return this.left.has_side_effects(compressor)
                || this.right.has_side_effects(compressor);
        });
        def(AST_Assign, function(compressor){ return true });
        def(AST_Conditional, function(compressor){
            return this.condition.has_side_effects(compressor)
                || this.consequent.has_side_effects(compressor)
                || this.alternative.has_side_effects(compressor);
        });
        def(AST_Unary, function(compressor){
            return this.operator == "delete"
                || this.operator == "++"
                || this.operator == "--"
                || this.expression.has_side_effects(compressor);
        });
        def(AST_SymbolRef, function(compressor){ return false });
        def(AST_Object, function(compressor){
            for (var i = this.properties.length; --i >= 0;)
                if (this.properties[i].has_side_effects(compressor))
                    return true;
            return false;
        });
        def(AST_ObjectProperty, function(compressor){
            return this.value.has_side_effects(compressor);
        });
        def(AST_Array, function(compressor){
            for (var i = this.elements.length; --i >= 0;)
                if (this.elements[i].has_side_effects(compressor))
                    return true;
            return false;
        });
        def(AST_Dot, function(compressor){
            if (!compressor.option("pure_getters")) return true;
            return this.expression.has_side_effects(compressor);
        });
        def(AST_Sub, function(compressor){
            if (!compressor.option("pure_getters")) return true;
            return this.expression.has_side_effects(compressor)
                || this.property.has_side_effects(compressor);
        });
        def(AST_PropAccess, function(compressor){
            return !compressor.option("pure_getters");
        });
        def(AST_Seq, function(compressor){
            return this.car.has_side_effects(compressor)
                || this.cdr.has_side_effects(compressor);
        });
    })(function(node, func){
        node.DEFMETHOD("has_side_effects", func);
    });

    // tell me if a statement aborts
    function aborts(thing) {
        return thing && thing.aborts();
    };
    (function(def){
        def(AST_Statement, function(){ return null });
        def(AST_Jump, function(){ return this });
        function block_aborts(){
            var n = this.body.length;
            return n > 0 && aborts(this.body[n - 1]);
        };
        def(AST_BlockStatement, block_aborts);
        def(AST_SwitchBranch, block_aborts);
        def(AST_If, function(){
            return this.alternative && aborts(this.body) && aborts(this.alternative);
        });
    })(function(node, func){
        node.DEFMETHOD("aborts", func);
    });

    /* -----[ optimizers ]----- */

    OPT(AST_Directive, function(self, compressor){
        if (self.scope.has_directive(self.value) !== self.scope) {
            return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    OPT(AST_Debugger, function(self, compressor){
        if (compressor.option("drop_debugger"))
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_LabeledStatement, function(self, compressor){
        if (self.body instanceof AST_Break
            && compressor.loopcontrol_target(self.body.label) === self.body) {
            return make_node(AST_EmptyStatement, self);
        }
        return self.label.references.length == 0 ? self.body : self;
    });

    OPT(AST_Block, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_BlockStatement, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        switch (self.body.length) {
          case 1: return self.body[0];
          case 0: return make_node(AST_EmptyStatement, self);
        }
        return self;
    });

    AST_Scope.DEFMETHOD("drop_unused", function(compressor){
        var self = this;
        if (compressor.option("unused")
            && !(self instanceof AST_Toplevel)
            && !self.uses_eval
           ) {
            var in_use = [];
            var initializations = new Dictionary();
            // pass 1: find out which symbols are directly used in
            // this scope (not in nested scopes).
            var scope = this;
            var tw = new TreeWalker(function(node, descend){
                if (node !== self) {
                    if (node instanceof AST_Defun) {
                        initializations.add(node.name.name, node);
                        return true; // don't go in nested scopes
                    }
                    if (node instanceof AST_Definitions && scope === self) {
                        node.definitions.forEach(function(def){
                            if (def.value) {
                                initializations.add(def.name.name, def.value);
                                if (def.value.has_side_effects(compressor)) {
                                    def.value.walk(tw);
                                }
                            }
                        });
                        return true;
                    }
                    if (node instanceof AST_SymbolRef) {
                        push_uniq(in_use, node.definition());
                        return true;
                    }
                    if (node instanceof AST_Scope) {
                        var save_scope = scope;
                        scope = node;
                        descend();
                        scope = save_scope;
                        return true;
                    }
                }
            });
            self.walk(tw);
            // pass 2: for every used symbol we need to walk its
            // initialization code to figure out if it uses other
            // symbols (that may not be in_use).
            for (var i = 0; i < in_use.length; ++i) {
                in_use[i].orig.forEach(function(decl){
                    // undeclared globals will be instanceof AST_SymbolRef
                    var init = initializations.get(decl.name);
                    if (init) init.forEach(function(init){
                        var tw = new TreeWalker(function(node){
                            if (node instanceof AST_SymbolRef) {
                                push_uniq(in_use, node.definition());
                            }
                        });
                        init.walk(tw);
                    });
                });
            }
            // pass 3: we should drop declarations not in_use
            var tt = new TreeTransformer(
                function before(node, descend, in_list) {
                    if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
                        if (!compressor.option("keep_fargs")) {
                            for (var a = node.argnames, i = a.length; --i >= 0;) {
                                var sym = a[i];
                                if (sym.unreferenced()) {
                                    a.pop();
                                    compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                        name : sym.name,
                                        file : sym.start.file,
                                        line : sym.start.line,
                                        col  : sym.start.col
                                    });
                                }
                                else break;
                            }
                        }
                    }
                    if (node instanceof AST_Defun && node !== self) {
                        if (!member(node.name.definition(), in_use)) {
                            compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                name : node.name.name,
                                file : node.name.start.file,
                                line : node.name.start.line,
                                col  : node.name.start.col
                            });
                            return make_node(AST_EmptyStatement, node);
                        }
                        return node;
                    }
                    if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
                        var def = node.definitions.filter(function(def){
                            if (member(def.name.definition(), in_use)) return true;
                            var w = {
                                name : def.name.name,
                                file : def.name.start.file,
                                line : def.name.start.line,
                                col  : def.name.start.col
                            };
                            if (def.value && def.value.has_side_effects(compressor)) {
                                def._unused_side_effects = true;
                                compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                return true;
                            }
                            compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                            return false;
                        });
                        // place uninitialized names at the start
                        def = mergeSort(def, function(a, b){
                            if (!a.value && b.value) return -1;
                            if (!b.value && a.value) return 1;
                            return 0;
                        });
                        // for unused names whose initialization has
                        // side effects, we can cascade the init. code
                        // into the next one, or next statement.
                        var side_effects = [];
                        for (var i = 0; i < def.length;) {
                            var x = def[i];
                            if (x._unused_side_effects) {
                                side_effects.push(x.value);
                                def.splice(i, 1);
                            } else {
                                if (side_effects.length > 0) {
                                    side_effects.push(x.value);
                                    x.value = AST_Seq.from_array(side_effects);
                                    side_effects = [];
                                }
                                ++i;
                            }
                        }
                        if (side_effects.length > 0) {
                            side_effects = make_node(AST_BlockStatement, node, {
                                body: [ make_node(AST_SimpleStatement, node, {
                                    body: AST_Seq.from_array(side_effects)
                                }) ]
                            });
                        } else {
                            side_effects = null;
                        }
                        if (def.length == 0 && !side_effects) {
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (def.length == 0) {
                            return side_effects;
                        }
                        node.definitions = def;
                        if (side_effects) {
                            side_effects.body.unshift(node);
                            node = side_effects;
                        }
                        return node;
                    }
                    if (node instanceof AST_For) {
                        descend(node, this);

                        if (node.init instanceof AST_BlockStatement) {
                            // certain combination of unused name + side effect leads to:
                            //    https://github.com/mishoo/UglifyJS2/issues/44
                            // that's an invalid AST.
                            // We fix it at this stage by moving the `var` outside the `for`.

                            var body = node.init.body.slice(0, -1);
                            node.init = node.init.body.slice(-1)[0].body;
                            body.push(node);

                            return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
                                body: body
                            });
                        }
                    }
                    if (node instanceof AST_Scope && node !== self)
                        return node;
                }
            );
            self.transform(tt);
        }
    });

    AST_Scope.DEFMETHOD("hoist_declarations", function(compressor){
        var hoist_funs = compressor.option("hoist_funs");
        var hoist_vars = compressor.option("hoist_vars");
        var self = this;
        if (hoist_funs || hoist_vars) {
            var dirs = [];
            var hoisted = [];
            var vars = new Dictionary(), vars_found = 0, var_decl = 0;
            // let's count var_decl first, we seem to waste a lot of
            // space if we hoist `var` when there's only one.
            self.walk(new TreeWalker(function(node){
                if (node instanceof AST_Scope && node !== self)
                    return true;
                if (node instanceof AST_Var) {
                    ++var_decl;
                    return true;
                }
            }));
            hoist_vars = hoist_vars && var_decl > 1;
            var tt = new TreeTransformer(
                function before(node) {
                    if (node !== self) {
                        if (node instanceof AST_Directive) {
                            dirs.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Defun && hoist_funs) {
                            hoisted.push(node);
                            return make_node(AST_EmptyStatement, node);
                        }
                        if (node instanceof AST_Var && hoist_vars) {
                            node.definitions.forEach(function(def){
                                vars.set(def.name.name, def);
                                ++vars_found;
                            });
                            var seq = node.to_assignments();
                            var p = tt.parent();
                            if (p instanceof AST_ForIn && p.init === node) {
                                if (seq == null) return node.definitions[0].name;
                                return seq;
                            }
                            if (p instanceof AST_For && p.init === node) {
                                return seq;
                            }
                            if (!seq) return make_node(AST_EmptyStatement, node);
                            return make_node(AST_SimpleStatement, node, {
                                body: seq
                            });
                        }
                        if (node instanceof AST_Scope)
                            return node; // to avoid descending in nested scopes
                    }
                }
            );
            self = self.transform(tt);
            if (vars_found > 0) {
                // collect only vars which don't show up in self's arguments list
                var defs = [];
                vars.each(function(def, name){
                    if (self instanceof AST_Lambda
                        && find_if(function(x){ return x.name == def.name.name },
                                   self.argnames)) {
                        vars.del(name);
                    } else {
                        def = def.clone();
                        def.value = null;
                        defs.push(def);
                        vars.set(name, def);
                    }
                });
                if (defs.length > 0) {
                    // try to merge in assignments
                    for (var i = 0; i < self.body.length;) {
                        if (self.body[i] instanceof AST_SimpleStatement) {
                            var expr = self.body[i].body, sym, assign;
                            if (expr instanceof AST_Assign
                                && expr.operator == "="
                                && (sym = expr.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = expr.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body.splice(i, 1);
                                continue;
                            }
                            if (expr instanceof AST_Seq
                                && (assign = expr.car) instanceof AST_Assign
                                && assign.operator == "="
                                && (sym = assign.left) instanceof AST_Symbol
                                && vars.has(sym.name))
                            {
                                var def = vars.get(sym.name);
                                if (def.value) break;
                                def.value = assign.right;
                                remove(defs, def);
                                defs.push(def);
                                self.body[i].body = expr.cdr;
                                continue;
                            }
                        }
                        if (self.body[i] instanceof AST_EmptyStatement) {
                            self.body.splice(i, 1);
                            continue;
                        }
                        if (self.body[i] instanceof AST_BlockStatement) {
                            var tmp = [ i, 1 ].concat(self.body[i].body);
                            self.body.splice.apply(self.body, tmp);
                            continue;
                        }
                        break;
                    }
                    defs = make_node(AST_Var, self, {
                        definitions: defs
                    });
                    hoisted.push(defs);
                };
            }
            self.body = dirs.concat(hoisted, self.body);
        }
        return self;
    });

    OPT(AST_SimpleStatement, function(self, compressor){
        if (compressor.option("side_effects")) {
            if (!self.body.has_side_effects(compressor)) {
                compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                return make_node(AST_EmptyStatement, self);
            }
        }
        return self;
    });

    OPT(AST_DWLoop, function(self, compressor){
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (!compressor.option("loops")) return self;
        if (cond.length > 1) {
            if (cond[1]) {
                return make_node(AST_For, self, {
                    body: self.body
                });
            } else if (self instanceof AST_While) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        return self;
    });

    function if_break_in_loop(self, compressor) {
        function drop_it(rest) {
            rest = as_statement_array(rest);
            if (self.body instanceof AST_BlockStatement) {
                self.body = self.body.clone();
                self.body.body = rest.concat(self.body.body.slice(1));
                self.body = self.body.transform(compressor);
            } else {
                self.body = make_node(AST_BlockStatement, self.body, {
                    body: rest
                }).transform(compressor);
            }
            if_break_in_loop(self, compressor);
        }
        var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
        if (first instanceof AST_If) {
            if (first.body instanceof AST_Break
                && compressor.loopcontrol_target(first.body.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition.negate(compressor),
                    });
                } else {
                    self.condition = first.condition.negate(compressor);
                }
                drop_it(first.alternative);
            }
            else if (first.alternative instanceof AST_Break
                     && compressor.loopcontrol_target(first.alternative.label) === self) {
                if (self.condition) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        left: self.condition,
                        operator: "&&",
                        right: first.condition,
                    });
                } else {
                    self.condition = first.condition;
                }
                drop_it(first.body);
            }
        }
    };

    OPT(AST_While, function(self, compressor) {
        if (!compressor.option("loops")) return self;
        self = AST_DWLoop.prototype.optimize.call(self, compressor);
        if (self instanceof AST_While) {
            if_break_in_loop(self, compressor);
            self = make_node(AST_For, self, self).transform(compressor);
        }
        return self;
    });

    OPT(AST_For, function(self, compressor){
        var cond = self.condition;
        if (cond) {
            cond = cond.evaluate(compressor);
            self.condition = cond[0];
        }
        if (!compressor.option("loops")) return self;
        if (cond) {
            if (cond.length > 1 && !cond[1]) {
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.init instanceof AST_Statement) {
                        a.push(self.init);
                    }
                    else if (self.init) {
                        a.push(make_node(AST_SimpleStatement, self.init, {
                            body: self.init
                        }));
                    }
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    return make_node(AST_BlockStatement, self, { body: a });
                }
            }
        }
        if_break_in_loop(self, compressor);
        return self;
    });

    OPT(AST_If, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        // if condition can be statically determined, warn and drop
        // one of the blocks.  note, statically determined implies
        // “has no side effects”; also it doesn't work for cases like
        // `x && true`, though it probably should.
        var cond = self.condition.evaluate(compressor);
        self.condition = cond[0];
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    if (self.alternative) {
                        extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                    }
                    a.push(self.body);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                if (compressor.option("dead_code")) {
                    var a = [];
                    extract_declarations_from_unreachable_code(compressor, self.body, a);
                    if (self.alternative) a.push(self.alternative);
                    return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);
                }
            }
        }
        if (is_empty(self.alternative)) self.alternative = null;
        var negated = self.condition.negate(compressor);
        var negated_is_best = best_of(self.condition, negated) === negated;
        if (self.alternative && negated_is_best) {
            negated_is_best = false; // because we already do the switch here.
            self.condition = negated;
            var tmp = self.body;
            self.body = self.alternative || make_node(AST_EmptyStatement);
            self.alternative = tmp;
        }
        if (is_empty(self.body) && is_empty(self.alternative)) {
            return make_node(AST_SimpleStatement, self.condition, {
                body: self.condition
            }).transform(compressor);
        }
        if (self.body instanceof AST_SimpleStatement
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.body,
                    alternative : self.alternative.body
                })
            }).transform(compressor);
        }
        if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
            if (negated_is_best) return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : negated,
                    right    : self.body.body
                })
            }).transform(compressor);
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "&&",
                    left     : self.condition,
                    right    : self.body.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_EmptyStatement
            && self.alternative
            && self.alternative instanceof AST_SimpleStatement) {
            return make_node(AST_SimpleStatement, self, {
                body: make_node(AST_Binary, self, {
                    operator : "||",
                    left     : self.condition,
                    right    : self.alternative.body
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_Exit
            && self.alternative instanceof AST_Exit
            && self.body.TYPE == self.alternative.TYPE) {
            return make_node(self.body.CTOR, self, {
                value: make_node(AST_Conditional, self, {
                    condition   : self.condition,
                    consequent  : self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
                    alternative : self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
                })
            }).transform(compressor);
        }
        if (self.body instanceof AST_If
            && !self.body.alternative
            && !self.alternative) {
            self.condition = make_node(AST_Binary, self.condition, {
                operator: "&&",
                left: self.condition,
                right: self.body.condition
            }).transform(compressor);
            self.body = self.body.body;
        }
        if (aborts(self.body)) {
            if (self.alternative) {
                var alt = self.alternative;
                self.alternative = null;
                return make_node(AST_BlockStatement, self, {
                    body: [ self, alt ]
                }).transform(compressor);
            }
        }
        if (aborts(self.alternative)) {
            var body = self.body;
            self.body = self.alternative;
            self.condition = negated_is_best ? negated : self.condition.negate(compressor);
            self.alternative = null;
            return make_node(AST_BlockStatement, self, {
                body: [ self, body ]
            }).transform(compressor);
        }
        return self;
    });

    OPT(AST_Switch, function(self, compressor){
        if (self.body.length == 0 && compressor.option("conditionals")) {
            return make_node(AST_SimpleStatement, self, {
                body: self.expression
            }).transform(compressor);
        }
        for(;;) {
            var last_branch = self.body[self.body.length - 1];
            if (last_branch) {
                var stat = last_branch.body[last_branch.body.length - 1]; // last statement
                if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self)
                    last_branch.body.pop();
                if (last_branch instanceof AST_Default && last_branch.body.length == 0) {
                    self.body.pop();
                    continue;
                }
            }
            break;
        }
        var exp = self.expression.evaluate(compressor);
        out: if (exp.length == 2) try {
            // constant expression
            self.expression = exp[0];
            if (!compressor.option("dead_code")) break out;
            var value = exp[1];
            var in_if = false;
            var in_block = false;
            var started = false;
            var stopped = false;
            var ruined = false;
            var tt = new TreeTransformer(function(node, descend, in_list){
                if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {
                    // no need to descend these node types
                    return node;
                }
                else if (node instanceof AST_Switch && node === self) {
                    node = node.clone();
                    descend(node, this);
                    return ruined ? node : make_node(AST_BlockStatement, node, {
                        body: node.body.reduce(function(a, branch){
                            return a.concat(branch.body);
                        }, [])
                    }).transform(compressor);
                }
                else if (node instanceof AST_If || node instanceof AST_Try) {
                    var save = in_if;
                    in_if = !in_block;
                    descend(node, this);
                    in_if = save;
                    return node;
                }
                else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
                    var save = in_block;
                    in_block = true;
                    descend(node, this);
                    in_block = save;
                    return node;
                }
                else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {
                    if (in_if) {
                        ruined = true;
                        return node;
                    }
                    if (in_block) return node;
                    stopped = true;
                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
                }
                else if (node instanceof AST_SwitchBranch && this.parent() === self) {
                    if (stopped) return MAP.skip;
                    if (node instanceof AST_Case) {
                        var exp = node.expression.evaluate(compressor);
                        if (exp.length < 2) {
                            // got a case with non-constant expression, baling out
                            throw self;
                        }
                        if (exp[1] === value || started) {
                            started = true;
                            if (aborts(node)) stopped = true;
                            descend(node, this);
                            return node;
                        }
                        return MAP.skip;
                    }
                    descend(node, this);
                    return node;
                }
            });
            tt.stack = compressor.stack.slice(); // so that's able to see parent nodes
            self = self.transform(tt);
        } catch(ex) {
            if (ex !== self) throw ex;
        }
        return self;
    });

    OPT(AST_Case, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    OPT(AST_Try, function(self, compressor){
        self.body = tighten_body(self.body, compressor);
        return self;
    });

    AST_Definitions.DEFMETHOD("remove_initializers", function(){
        this.definitions.forEach(function(def){ def.value = null });
    });

    AST_Definitions.DEFMETHOD("to_assignments", function(){
        var assignments = this.definitions.reduce(function(a, def){
            if (def.value) {
                var name = make_node(AST_SymbolRef, def.name, def.name);
                a.push(make_node(AST_Assign, def, {
                    operator : "=",
                    left     : name,
                    right    : def.value
                }));
            }
            return a;
        }, []);
        if (assignments.length == 0) return null;
        return AST_Seq.from_array(assignments);
    });

    OPT(AST_Definitions, function(self, compressor){
        if (self.definitions.length == 0)
            return make_node(AST_EmptyStatement, self);
        return self;
    });

    OPT(AST_Function, function(self, compressor){
        self = AST_Lambda.prototype.optimize.call(self, compressor);
        if (compressor.option("unused")) {
            if (self.name && self.name.unreferenced()) {
                self.name = null;
            }
        }
        return self;
    });

    OPT(AST_Call, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Array":
                    if (self.args.length != 1) {
                        return make_node(AST_Array, self, {
                            elements: self.args
                        }).transform(compressor);
                    }
                    break;
                  case "Object":
                    if (self.args.length == 0) {
                        return make_node(AST_Object, self, {
                            properties: []
                        });
                    }
                    break;
                  case "String":
                    if (self.args.length == 0) return make_node(AST_String, self, {
                        value: ""
                    });
                    if (self.args.length <= 1) return make_node(AST_Binary, self, {
                        left: self.args[0],
                        operator: "+",
                        right: make_node(AST_String, self, { value: "" })
                    }).transform(compressor);
                    break;
                  case "Number":
                    if (self.args.length == 0) return make_node(AST_Number, self, {
                        value: 0
                    });
                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                        expression: self.args[0],
                        operator: "+"
                    }).transform(compressor);
                  case "Boolean":
                    if (self.args.length == 0) return make_node(AST_False, self);
                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                        expression: make_node(AST_UnaryPrefix, null, {
                            expression: self.args[0],
                            operator: "!"
                        }),
                        operator: "!"
                    }).transform(compressor);
                    break;
                  case "Function":
                    if (all(self.args, function(x){ return x instanceof AST_String })) {
                        // quite a corner-case, but we can handle it:
                        //   https://github.com/mishoo/UglifyJS2/issues/203
                        // if the code argument is a constant, then we can minify it.
                        try {
                            var code = "(function(" + self.args.slice(0, -1).map(function(arg){
                                return arg.value;
                            }).join(",") + "){" + self.args[self.args.length - 1].value + "})()";
                            var ast = parse(code);
                            ast.figure_out_scope({ screw_ie8: compressor.option("screw_ie8") });
                            var comp = new Compressor(compressor.options);
                            ast = ast.transform(comp);
                            ast.figure_out_scope({ screw_ie8: compressor.option("screw_ie8") });
                            ast.mangle_names();
                            var fun;
                            try {
                                ast.walk(new TreeWalker(function(node){
                                    if (node instanceof AST_Lambda) {
                                        fun = node;
                                        throw ast;
                                    }
                                }));
                            } catch(ex) {
                                if (ex !== ast) throw ex;
                            };
                            var args = fun.argnames.map(function(arg, i){
                                return make_node(AST_String, self.args[i], {
                                    value: arg.print_to_string()
                                });
                            });
                            var code = OutputStream();
                            AST_BlockStatement.prototype._codegen.call(fun, fun, code);
                            code = code.toString().replace(/^\{|\}$/g, "");
                            args.push(make_node(AST_String, self.args[self.args.length - 1], {
                                value: code
                            }));
                            self.args = args;
                            return self;
                        } catch(ex) {
                            if (ex instanceof JS_Parse_Error) {
                                compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                compressor.warn(ex.toString());
                            } else {
                                console.log(ex);
                                throw ex;
                            }
                        }
                    }
                    break;
                }
            }
            else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
                return make_node(AST_Binary, self, {
                    left: make_node(AST_String, self, { value: "" }),
                    operator: "+",
                    right: exp.expression
                }).transform(compressor);
            }
            else if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && exp.property == "join") EXIT: {
                var separator = self.args.length == 0 ? "," : self.args[0].evaluate(compressor)[1];
                if (separator == null) break EXIT; // not a constant
                var elements = exp.expression.elements.reduce(function(a, el){
                    el = el.evaluate(compressor);
                    if (a.length == 0 || el.length == 1) {
                        a.push(el);
                    } else {
                        var last = a[a.length - 1];
                        if (last.length == 2) {
                            // it's a constant
                            var val = "" + last[1] + separator + el[1];
                            a[a.length - 1] = [ make_node_from_constant(compressor, val, last[0]), val ];
                        } else {
                            a.push(el);
                        }
                    }
                    return a;
                }, []);
                if (elements.length == 0) return make_node(AST_String, self, { value: "" });
                if (elements.length == 1) return elements[0][0];
                if (separator == "") {
                    var first;
                    if (elements[0][0] instanceof AST_String
                        || elements[1][0] instanceof AST_String) {
                        first = elements.shift()[0];
                    } else {
                        first = make_node(AST_String, self, { value: "" });
                    }
                    return elements.reduce(function(prev, el){
                        return make_node(AST_Binary, el[0], {
                            operator : "+",
                            left     : prev,
                            right    : el[0],
                        });
                    }, first).transform(compressor);
                }
                // need this awkward cloning to not affect original element
                // best_of will decide which one to get through.
                var node = self.clone();
                node.expression = node.expression.clone();
                node.expression.expression = node.expression.expression.clone();
                node.expression.expression.elements = elements.map(function(el){
                    return el[0];
                });
                return best_of(self, node);
            }
        }
        if (compressor.option("side_effects")) {
            if (self.expression instanceof AST_Function
                && self.args.length == 0
                && !AST_Block.prototype.has_side_effects.call(self.expression, compressor)) {
                return make_node(AST_Undefined, self).transform(compressor);
            }
        }
        if (compressor.option("drop_console")) {
            if (self.expression instanceof AST_PropAccess &&
                self.expression.expression instanceof AST_SymbolRef &&
                self.expression.expression.name == "console" &&
                self.expression.expression.undeclared()) {
                return make_node(AST_Undefined, self).transform(compressor);
            }
        }
        return self.evaluate(compressor)[0];
    });

    OPT(AST_New, function(self, compressor){
        if (compressor.option("unsafe")) {
            var exp = self.expression;
            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                switch (exp.name) {
                  case "Object":
                  case "RegExp":
                  case "Function":
                  case "Error":
                  case "Array":
                    return make_node(AST_Call, self, self).transform(compressor);
                }
            }
        }
        return self;
    });

    OPT(AST_Seq, function(self, compressor){
        if (!compressor.option("side_effects"))
            return self;
        if (!self.car.has_side_effects(compressor)) {
            // we shouldn't compress (1,eval)(something) to
            // eval(something) because that changes the meaning of
            // eval (becomes lexical instead of global).
            var p;
            if (!(self.cdr instanceof AST_SymbolRef
                  && self.cdr.name == "eval"
                  && self.cdr.undeclared()
                  && (p = compressor.parent()) instanceof AST_Call
                  && p.expression === self)) {
                return self.cdr;
            }
        }
        if (compressor.option("cascade")) {
            if (self.car instanceof AST_Assign
                && !self.car.left.has_side_effects(compressor)) {
                if (self.car.left.equivalent_to(self.cdr)) {
                    return self.car;
                }
                if (self.cdr instanceof AST_Call
                    && self.cdr.expression.equivalent_to(self.car.left)) {
                    self.cdr.expression = self.car;
                    return self.cdr;
                }
            }
            if (!self.car.has_side_effects(compressor)
                && !self.cdr.has_side_effects(compressor)
                && self.car.equivalent_to(self.cdr)) {
                return self.car;
            }
        }
        if (self.cdr instanceof AST_UnaryPrefix
            && self.cdr.operator == "void"
            && !self.cdr.expression.has_side_effects(compressor)) {
            self.cdr.operator = self.car;
            return self.cdr;
        }
        if (self.cdr instanceof AST_Undefined) {
            return make_node(AST_UnaryPrefix, self, {
                operator   : "void",
                expression : self.car
            });
        }
        return self;
    });

    AST_Unary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.expression instanceof AST_Seq) {
                var seq = this.expression;
                var x = seq.to_array();
                this.expression = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    OPT(AST_UnaryPostfix, function(self, compressor){
        return self.lift_sequences(compressor);
    });

    OPT(AST_UnaryPrefix, function(self, compressor){
        self = self.lift_sequences(compressor);
        var e = self.expression;
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            switch (self.operator) {
              case "!":
                if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                    // !!foo ==> foo, if we're in boolean context
                    return e.expression;
                }
                break;
              case "typeof":
                // typeof always returns a non-empty string, thus it's
                // always true in booleans
                compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (e instanceof AST_Binary && self.operator == "!") {
                self = best_of(self, e.negate(compressor));
            }
        }
        return self.evaluate(compressor)[0];
    });

    function has_side_effects_or_prop_access(node, compressor) {
        var save_pure_getters = compressor.option("pure_getters");
        compressor.options.pure_getters = false;
        var ret = node.has_side_effects(compressor);
        compressor.options.pure_getters = save_pure_getters;
        return ret;
    }

    AST_Binary.DEFMETHOD("lift_sequences", function(compressor){
        if (compressor.option("sequences")) {
            if (this.left instanceof AST_Seq) {
                var seq = this.left;
                var x = seq.to_array();
                this.left = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
            if (this.right instanceof AST_Seq
                && this instanceof AST_Assign
                && !has_side_effects_or_prop_access(this.left, compressor)) {
                var seq = this.right;
                var x = seq.to_array();
                this.right = x.pop();
                x.push(this);
                seq = AST_Seq.from_array(x).transform(compressor);
                return seq;
            }
        }
        return this;
    });

    var commutativeOperators = makePredicate("== === != !== * & | ^");

    OPT(AST_Binary, function(self, compressor){
        var reverse = compressor.has_directive("use asm") ? noop
            : function(op, force) {
                if (force || !(self.left.has_side_effects(compressor) || self.right.has_side_effects(compressor))) {
                    if (op) self.operator = op;
                    var tmp = self.left;
                    self.left = self.right;
                    self.right = tmp;
                }
            };
        if (commutativeOperators(self.operator)) {
            if (self.right instanceof AST_Constant
                && !(self.left instanceof AST_Constant)) {
                // if right is a constant, whatever side effects the
                // left side might have could not influence the
                // result.  hence, force switch.

                if (!(self.left instanceof AST_Binary
                      && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
                    reverse(null, true);
                }
            }
            if (/^[!=]==?$/.test(self.operator)) {
                if (self.left instanceof AST_SymbolRef && self.right instanceof AST_Conditional) {
                    if (self.right.consequent instanceof AST_SymbolRef
                        && self.right.consequent.definition() === self.left.definition()) {
                        if (/^==/.test(self.operator)) return self.right.condition;
                        if (/^!=/.test(self.operator)) return self.right.condition.negate(compressor);
                    }
                    if (self.right.alternative instanceof AST_SymbolRef
                        && self.right.alternative.definition() === self.left.definition()) {
                        if (/^==/.test(self.operator)) return self.right.condition.negate(compressor);
                        if (/^!=/.test(self.operator)) return self.right.condition;
                    }
                }
                if (self.right instanceof AST_SymbolRef && self.left instanceof AST_Conditional) {
                    if (self.left.consequent instanceof AST_SymbolRef
                        && self.left.consequent.definition() === self.right.definition()) {
                        if (/^==/.test(self.operator)) return self.left.condition;
                        if (/^!=/.test(self.operator)) return self.left.condition.negate(compressor);
                    }
                    if (self.left.alternative instanceof AST_SymbolRef
                        && self.left.alternative.definition() === self.right.definition()) {
                        if (/^==/.test(self.operator)) return self.left.condition.negate(compressor);
                        if (/^!=/.test(self.operator)) return self.left.condition;
                    }
                }
            }
        }
        self = self.lift_sequences(compressor);
        if (compressor.option("comparisons")) switch (self.operator) {
          case "===":
          case "!==":
            if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
                (self.left.is_boolean() && self.right.is_boolean())) {
                self.operator = self.operator.substr(0, 2);
            }
            // XXX: intentionally falling down to the next case
          case "==":
          case "!=":
            if (self.left instanceof AST_String
                && self.left.value == "undefined"
                && self.right instanceof AST_UnaryPrefix
                && self.right.operator == "typeof"
                && compressor.option("unsafe")) {
                if (!(self.right.expression instanceof AST_SymbolRef)
                    || !self.right.expression.undeclared()) {
                    self.right = self.right.expression;
                    self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                    if (self.operator.length == 2) self.operator += "=";
                }
            }
            break;
        }
        if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
          case "&&":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && !ll[1]) || (rr.length > 1 && !rr[1])) {
                compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                return make_node(AST_False, self);
            }
            if (ll.length > 1 && ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && rr[1]) {
                return ll[0];
            }
            break;
          case "||":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[1]) || (rr.length > 1 && rr[1])) {
                compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            if (ll.length > 1 && !ll[1]) {
                return rr[0];
            }
            if (rr.length > 1 && !rr[1]) {
                return ll[0];
            }
            break;
          case "+":
            var ll = self.left.evaluate(compressor);
            var rr = self.right.evaluate(compressor);
            if ((ll.length > 1 && ll[0] instanceof AST_String && ll[1]) ||
                (rr.length > 1 && rr[0] instanceof AST_String && rr[1])) {
                compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                return make_node(AST_True, self);
            }
            break;
        }
        if (compressor.option("comparisons")) {
            if (!(compressor.parent() instanceof AST_Binary)
                || compressor.parent() instanceof AST_Assign) {
                var negated = make_node(AST_UnaryPrefix, self, {
                    operator: "!",
                    expression: self.negate(compressor)
                });
                self = best_of(self, negated);
            }
            switch (self.operator) {
              case "<": reverse(">"); break;
              case "<=": reverse(">="); break;
            }
        }
        if (self.operator == "+" && self.right instanceof AST_String
            && self.right.getValue() === "" && self.left instanceof AST_Binary
            && self.left.operator == "+" && self.left.is_string(compressor)) {
            return self.left;
        }
        if (compressor.option("evaluate")) {
            if (self.operator == "+") {
                if (self.left instanceof AST_Constant
                    && self.right instanceof AST_Binary
                    && self.right.operator == "+"
                    && self.right.left instanceof AST_Constant
                    && self.right.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_String, null, {
                            value: "" + self.left.getValue() + self.right.left.getValue(),
                            start: self.left.start,
                            end: self.right.left.end
                        }),
                        right: self.right.right
                    });
                }
                if (self.right instanceof AST_Constant
                    && self.left instanceof AST_Binary
                    && self.left.operator == "+"
                    && self.left.right instanceof AST_Constant
                    && self.left.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: self.left.left,
                        right: make_node(AST_String, null, {
                            value: "" + self.left.right.getValue() + self.right.getValue(),
                            start: self.left.right.start,
                            end: self.right.end
                        })
                    });
                }
                if (self.left instanceof AST_Binary
                    && self.left.operator == "+"
                    && self.left.is_string(compressor)
                    && self.left.right instanceof AST_Constant
                    && self.right instanceof AST_Binary
                    && self.right.operator == "+"
                    && self.right.left instanceof AST_Constant
                    && self.right.is_string(compressor)) {
                    self = make_node(AST_Binary, self, {
                        operator: "+",
                        left: make_node(AST_Binary, self.left, {
                            operator: "+",
                            left: self.left.left,
                            right: make_node(AST_String, null, {
                                value: "" + self.left.right.getValue() + self.right.left.getValue(),
                                start: self.left.right.start,
                                end: self.right.left.end
                            })
                        }),
                        right: self.right.right
                    });
                }
            }
        }
        // x * (y * z)  ==>  x * y * z
        if (self.right instanceof AST_Binary
            && self.right.operator == self.operator
            && (self.operator == "*" || self.operator == "&&" || self.operator == "||"))
        {
            self.left = make_node(AST_Binary, self.left, {
                operator : self.operator,
                left     : self.left,
                right    : self.right.left
            });
            self.right = self.right.right;
            return self.transform(compressor);
        }
        return self.evaluate(compressor)[0];
    });

    OPT(AST_SymbolRef, function(self, compressor){
        if (self.undeclared()) {
            var defines = compressor.option("global_defs");
            if (defines && defines.hasOwnProperty(self.name)) {
                return make_node_from_constant(compressor, defines[self.name], self);
            }
            switch (self.name) {
              case "undefined":
                return make_node(AST_Undefined, self);
              case "NaN":
                return make_node(AST_NaN, self);
              case "Infinity":
                return make_node(AST_Infinity, self);
            }
        }
        return self;
    });

    OPT(AST_Undefined, function(self, compressor){
        if (compressor.option("unsafe")) {
            var scope = compressor.find_parent(AST_Scope);
            var undef = scope.find_variable("undefined");
            if (undef) {
                var ref = make_node(AST_SymbolRef, self, {
                    name   : "undefined",
                    scope  : scope,
                    thedef : undef
                });
                ref.reference();
                return ref;
            }
        }
        return self;
    });

    var ASSIGN_OPS = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
    OPT(AST_Assign, function(self, compressor){
        self = self.lift_sequences(compressor);
        if (self.operator == "="
            && self.left instanceof AST_SymbolRef
            && self.right instanceof AST_Binary
            && self.right.left instanceof AST_SymbolRef
            && self.right.left.name == self.left.name
            && member(self.right.operator, ASSIGN_OPS)) {
            self.operator = self.right.operator + "=";
            self.right = self.right.right;
        }
        return self;
    });

    OPT(AST_Conditional, function(self, compressor){
        if (!compressor.option("conditionals")) return self;
        if (self.condition instanceof AST_Seq) {
            var car = self.condition.car;
            self.condition = self.condition.cdr;
            return AST_Seq.cons(car, self);
        }
        var cond = self.condition.evaluate(compressor);
        if (cond.length > 1) {
            if (cond[1]) {
                compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                return self.consequent;
            } else {
                compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                return self.alternative;
            }
        }
        var negated = cond[0].negate(compressor);
        if (best_of(cond[0], negated) === negated) {
            self = make_node(AST_Conditional, self, {
                condition: negated,
                consequent: self.alternative,
                alternative: self.consequent
            });
        }
        var consequent = self.consequent;
        var alternative = self.alternative;
        if (consequent instanceof AST_Assign
            && alternative instanceof AST_Assign
            && consequent.operator == alternative.operator
            && consequent.left.equivalent_to(alternative.left)
           ) {
            /*
             * Stuff like this:
             * if (foo) exp = something; else exp = something_else;
             * ==>
             * exp = foo ? something : something_else;
             */
            return make_node(AST_Assign, self, {
                operator: consequent.operator,
                left: consequent.left,
                right: make_node(AST_Conditional, self, {
                    condition: self.condition,
                    consequent: consequent.right,
                    alternative: alternative.right
                })
            });
        }
        if (consequent instanceof AST_Call
            && alternative.TYPE === consequent.TYPE
            && consequent.args.length == alternative.args.length
            && consequent.expression.equivalent_to(alternative.expression)) {
            if (consequent.args.length == 0) {
                return make_node(AST_Seq, self, {
                    car: self.condition,
                    cdr: consequent
                });
            }
            if (consequent.args.length == 1) {
                consequent.args[0] = make_node(AST_Conditional, self, {
                    condition: self.condition,
                    consequent: consequent.args[0],
                    alternative: alternative.args[0]
                });
                return consequent;
            }
        }
        // x?y?z:a:a --> x&&y?z:a
        if (consequent instanceof AST_Conditional
            && consequent.alternative.equivalent_to(alternative)) {
            return make_node(AST_Conditional, self, {
                condition: make_node(AST_Binary, self, {
                    left: self.condition,
                    operator: "&&",
                    right: consequent.condition
                }),
                consequent: consequent.consequent,
                alternative: alternative
            });
        }
        return self;
    });

    OPT(AST_Boolean, function(self, compressor){
        if (compressor.option("booleans")) {
            var p = compressor.parent();
            if (p instanceof AST_Binary && (p.operator == "=="
                                            || p.operator == "!=")) {
                compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                    operator : p.operator,
                    value    : self.value,
                    file     : p.start.file,
                    line     : p.start.line,
                    col      : p.start.col,
                });
                return make_node(AST_Number, self, {
                    value: +self.value
                });
            }
            return make_node(AST_UnaryPrefix, self, {
                operator: "!",
                expression: make_node(AST_Number, self, {
                    value: 1 - self.value
                })
            });
        }
        return self;
    });

    OPT(AST_Sub, function(self, compressor){
        var prop = self.property;
        if (prop instanceof AST_String && compressor.option("properties")) {
            prop = prop.getValue();
            if (RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) {
                return make_node(AST_Dot, self, {
                    expression : self.expression,
                    property   : prop
                }).optimize(compressor);
            }
            var v = parseFloat(prop);
            if (!isNaN(v) && v.toString() == prop) {
                self.property = make_node(AST_Number, self.property, {
                    value: v
                });
            }
        }
        return self;
    });

    OPT(AST_Dot, function(self, compressor){
        return self.evaluate(compressor)[0];
    });

    function literals_in_boolean_context(self, compressor) {
        if (compressor.option("booleans") && compressor.in_boolean_context()) {
            return make_node(AST_True, self);
        }
        return self;
    };
    OPT(AST_Array, literals_in_boolean_context);
    OPT(AST_Object, literals_in_boolean_context);
    OPT(AST_RegExp, literals_in_boolean_context);

})();

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

// a small wrapper around fitzgen's source-map library
function SourceMap(options) {
    options = defaults(options, {
        file : null,
        root : null,
        orig : null,

        orig_line_diff : 0,
        dest_line_diff : 0,
    });
    var generator = new MOZ_SourceMap.SourceMapGenerator({
        file       : options.file,
        sourceRoot : options.root
    });
    var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
    function add(source, gen_line, gen_col, orig_line, orig_col, name) {
        if (orig_map) {
            var info = orig_map.originalPositionFor({
                line: orig_line,
                column: orig_col
            });
            if (info.source === null) {
                return;
            }
            source = info.source;
            orig_line = info.line;
            orig_col = info.column;
            name = info.name;
        }
        generator.addMapping({
            generated : { line: gen_line + options.dest_line_diff, column: gen_col },
            original  : { line: orig_line + options.orig_line_diff, column: orig_col },
            source    : source,
            name      : name
        });
    };
    return {
        add        : add,
        get        : function() { return generator },
        toString   : function() { return generator.toString() }
    };
};

/***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

(function(){

    var MOZ_TO_ME = {
        TryStatement : function(M) {
            return new AST_Try({
                start    : my_start_token(M),
                end      : my_end_token(M),
                body     : from_moz(M.block).body,
                bcatch   : from_moz(M.handlers ? M.handlers[0] : M.handler),
                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
            });
        },
        CatchClause : function(M) {
            return new AST_Catch({
                start   : my_start_token(M),
                end     : my_end_token(M),
                argname : from_moz(M.param),
                body    : from_moz(M.body).body
            });
        },
        ObjectExpression : function(M) {
            return new AST_Object({
                start      : my_start_token(M),
                end        : my_end_token(M),
                properties : M.properties.map(function(prop){
                    var key = prop.key;
                    var name = key.type == "Identifier" ? key.name : key.value;
                    var args = {
                        start    : my_start_token(key),
                        end      : my_end_token(prop.value),
                        key      : name,
                        value    : from_moz(prop.value)
                    };
                    switch (prop.kind) {
                      case "init":
                        return new AST_ObjectKeyVal(args);
                      case "set":
                        args.value.name = from_moz(key);
                        return new AST_ObjectSetter(args);
                      case "get":
                        args.value.name = from_moz(key);
                        return new AST_ObjectGetter(args);
                    }
                })
            });
        },
        SequenceExpression : function(M) {
            return AST_Seq.from_array(M.expressions.map(from_moz));
        },
        MemberExpression : function(M) {
            return new (M.computed ? AST_Sub : AST_Dot)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                property   : M.computed ? from_moz(M.property) : M.property.name,
                expression : from_moz(M.object)
            });
        },
        SwitchCase : function(M) {
            return new (M.test ? AST_Case : AST_Default)({
                start      : my_start_token(M),
                end        : my_end_token(M),
                expression : from_moz(M.test),
                body       : M.consequent.map(from_moz)
            });
        },
        Literal : function(M) {
            var val = M.value, args = {
                start  : my_start_token(M),
                end    : my_end_token(M)
            };
            if (val === null) return new AST_Null(args);
            switch (typeof val) {
              case "string":
                args.value = val;
                return new AST_String(args);
              case "number":
                args.value = val;
                return new AST_Number(args);
              case "boolean":
                return new (val ? AST_True : AST_False)(args);
              default:
                args.value = val;
                return new AST_RegExp(args);
            }
        },
        UnaryExpression: From_Moz_Unary,
        UpdateExpression: From_Moz_Unary,
        Identifier: function(M) {
            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
            return new (M.name == "this" ? AST_This
                        : p.type == "LabeledStatement" ? AST_Label
                        : p.type == "VariableDeclarator" && p.id === M ? (p.kind == "const" ? AST_SymbolConst : AST_SymbolVar)
                        : p.type == "FunctionExpression" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)
                        : p.type == "FunctionDeclaration" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)
                        : p.type == "CatchClause" ? AST_SymbolCatch
                        : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef
                        : AST_SymbolRef)({
                            start : my_start_token(M),
                            end   : my_end_token(M),
                            name  : M.name
                        });
        }
    };

    function From_Moz_Unary(M) {
        var prefix = "prefix" in M ? M.prefix
            : M.type == "UnaryExpression" ? true : false;
        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
            start      : my_start_token(M),
            end        : my_end_token(M),
            operator   : M.operator,
            expression : from_moz(M.argument)
        });
    };

    var ME_TO_MOZ = {};

    map("Node", AST_Node);
    map("Program", AST_Toplevel, "body@body");
    map("Function", AST_Function, "id>name, params@argnames, body%body");
    map("EmptyStatement", AST_EmptyStatement);
    map("BlockStatement", AST_BlockStatement, "body@body");
    map("ExpressionStatement", AST_SimpleStatement, "expression>body");
    map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
    map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
    map("BreakStatement", AST_Break, "label>label");
    map("ContinueStatement", AST_Continue, "label>label");
    map("WithStatement", AST_With, "object>expression, body>body");
    map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
    map("ReturnStatement", AST_Return, "argument>value");
    map("ThrowStatement", AST_Throw, "argument>value");
    map("WhileStatement", AST_While, "test>condition, body>body");
    map("DoWhileStatement", AST_Do, "test>condition, body>body");
    map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
    map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
    map("DebuggerStatement", AST_Debugger);
    map("FunctionDeclaration", AST_Defun, "id>name, params@argnames, body%body");
    map("VariableDeclaration", AST_Var, "declarations@definitions");
    map("VariableDeclarator", AST_VarDef, "id>name, init>value");

    map("ThisExpression", AST_This);
    map("ArrayExpression", AST_Array, "elements@elements");
    map("FunctionExpression", AST_Function, "id>name, params@argnames, body%body");
    map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
    map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
    map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
    map("NewExpression", AST_New, "callee>expression, arguments@args");
    map("CallExpression", AST_Call, "callee>expression, arguments@args");

    /* -----[ tools ]----- */

    function my_start_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.start.line,
            col    : moznode.loc && moznode.loc.start.column,
            pos    : moznode.start,
            endpos : moznode.start
        });
    };

    function my_end_token(moznode) {
        return new AST_Token({
            file   : moznode.loc && moznode.loc.source,
            line   : moznode.loc && moznode.loc.end.line,
            col    : moznode.loc && moznode.loc.end.column,
            pos    : moznode.end,
            endpos : moznode.end
        });
    };

    function map(moztype, mytype, propmap) {
        var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
        moz_to_me += "return new mytype({\n" +
            "start: my_start_token(M),\n" +
            "end: my_end_token(M)";

        if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop){
            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
            if (!m) throw new Error("Can't understand property map: " + prop);
            var moz = "M." + m[1], how = m[2], my = m[3];
            moz_to_me += ",\n" + my + ": ";
            if (how == "@") {
                moz_to_me += moz + ".map(from_moz)";
            } else if (how == ">") {
                moz_to_me += "from_moz(" + moz + ")";
            } else if (how == "=") {
                moz_to_me += moz;
            } else if (how == "%") {
                moz_to_me += "from_moz(" + moz + ").body";
            } else throw new Error("Can't understand operator in propmap: " + prop);
        });
        moz_to_me += "\n})}";

        // moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });
        // console.log(moz_to_me);

        moz_to_me = new Function("mytype", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
            mytype, my_start_token, my_end_token, from_moz
        );
        return MOZ_TO_ME[moztype] = moz_to_me;
    };

    var FROM_MOZ_STACK = null;

    function from_moz(node) {
        FROM_MOZ_STACK.push(node);
        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
        FROM_MOZ_STACK.pop();
        return ret;
    };

    AST_Node.from_mozilla_ast = function(node){
        var save_stack = FROM_MOZ_STACK;
        FROM_MOZ_STACK = [];
        var ast = from_moz(node);
        FROM_MOZ_STACK = save_stack;
        return ast;
    };

})();


exports.sys = sys;
exports.MOZ_SourceMap = MOZ_SourceMap;
exports.UglifyJS = UglifyJS;
exports.array_to_hash = array_to_hash;
exports.slice = slice;
exports.characters = characters;
exports.member = member;
exports.find_if = find_if;
exports.repeat_string = repeat_string;
exports.DefaultsError = DefaultsError;
exports.defaults = defaults;
exports.merge = merge;
exports.noop = noop;
exports.MAP = MAP;
exports.push_uniq = push_uniq;
exports.string_template = string_template;
exports.remove = remove;
exports.mergeSort = mergeSort;
exports.set_difference = set_difference;
exports.set_intersection = set_intersection;
exports.makePredicate = makePredicate;
exports.all = all;
exports.Dictionary = Dictionary;
exports.DEFNODE = DEFNODE;
exports.AST_Token = AST_Token;
exports.AST_Node = AST_Node;
exports.AST_Statement = AST_Statement;
exports.AST_Debugger = AST_Debugger;
exports.AST_Directive = AST_Directive;
exports.AST_SimpleStatement = AST_SimpleStatement;
exports.walk_body = walk_body;
exports.AST_Block = AST_Block;
exports.AST_BlockStatement = AST_BlockStatement;
exports.AST_EmptyStatement = AST_EmptyStatement;
exports.AST_StatementWithBody = AST_StatementWithBody;
exports.AST_LabeledStatement = AST_LabeledStatement;
exports.AST_IterationStatement = AST_IterationStatement;
exports.AST_DWLoop = AST_DWLoop;
exports.AST_Do = AST_Do;
exports.AST_While = AST_While;
exports.AST_For = AST_For;
exports.AST_ForIn = AST_ForIn;
exports.AST_With = AST_With;
exports.AST_Scope = AST_Scope;
exports.AST_Toplevel = AST_Toplevel;
exports.AST_Lambda = AST_Lambda;
exports.AST_Accessor = AST_Accessor;
exports.AST_Function = AST_Function;
exports.AST_Defun = AST_Defun;
exports.AST_Jump = AST_Jump;
exports.AST_Exit = AST_Exit;
exports.AST_Return = AST_Return;
exports.AST_Throw = AST_Throw;
exports.AST_LoopControl = AST_LoopControl;
exports.AST_Break = AST_Break;
exports.AST_Continue = AST_Continue;
exports.AST_If = AST_If;
exports.AST_Switch = AST_Switch;
exports.AST_SwitchBranch = AST_SwitchBranch;
exports.AST_Default = AST_Default;
exports.AST_Case = AST_Case;
exports.AST_Try = AST_Try;
exports.AST_Catch = AST_Catch;
exports.AST_Finally = AST_Finally;
exports.AST_Definitions = AST_Definitions;
exports.AST_Var = AST_Var;
exports.AST_Const = AST_Const;
exports.AST_VarDef = AST_VarDef;
exports.AST_Call = AST_Call;
exports.AST_New = AST_New;
exports.AST_Seq = AST_Seq;
exports.AST_PropAccess = AST_PropAccess;
exports.AST_Dot = AST_Dot;
exports.AST_Sub = AST_Sub;
exports.AST_Unary = AST_Unary;
exports.AST_UnaryPrefix = AST_UnaryPrefix;
exports.AST_UnaryPostfix = AST_UnaryPostfix;
exports.AST_Binary = AST_Binary;
exports.AST_Conditional = AST_Conditional;
exports.AST_Assign = AST_Assign;
exports.AST_Array = AST_Array;
exports.AST_Object = AST_Object;
exports.AST_ObjectProperty = AST_ObjectProperty;
exports.AST_ObjectKeyVal = AST_ObjectKeyVal;
exports.AST_ObjectSetter = AST_ObjectSetter;
exports.AST_ObjectGetter = AST_ObjectGetter;
exports.AST_Symbol = AST_Symbol;
exports.AST_SymbolAccessor = AST_SymbolAccessor;
exports.AST_SymbolDeclaration = AST_SymbolDeclaration;
exports.AST_SymbolVar = AST_SymbolVar;
exports.AST_SymbolConst = AST_SymbolConst;
exports.AST_SymbolFunarg = AST_SymbolFunarg;
exports.AST_SymbolDefun = AST_SymbolDefun;
exports.AST_SymbolLambda = AST_SymbolLambda;
exports.AST_SymbolCatch = AST_SymbolCatch;
exports.AST_Label = AST_Label;
exports.AST_SymbolRef = AST_SymbolRef;
exports.AST_LabelRef = AST_LabelRef;
exports.AST_This = AST_This;
exports.AST_Constant = AST_Constant;
exports.AST_String = AST_String;
exports.AST_Number = AST_Number;
exports.AST_RegExp = AST_RegExp;
exports.AST_Atom = AST_Atom;
exports.AST_Null = AST_Null;
exports.AST_NaN = AST_NaN;
exports.AST_Undefined = AST_Undefined;
exports.AST_Hole = AST_Hole;
exports.AST_Infinity = AST_Infinity;
exports.AST_Boolean = AST_Boolean;
exports.AST_False = AST_False;
exports.AST_True = AST_True;
exports.TreeWalker = TreeWalker;
exports.KEYWORDS = KEYWORDS;
exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
exports.RESERVED_WORDS = RESERVED_WORDS;
exports.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;
exports.OPERATOR_CHARS = OPERATOR_CHARS;
exports.RE_HEX_NUMBER = RE_HEX_NUMBER;
exports.RE_OCT_NUMBER = RE_OCT_NUMBER;
exports.RE_DEC_NUMBER = RE_DEC_NUMBER;
exports.OPERATORS = OPERATORS;
exports.WHITESPACE_CHARS = WHITESPACE_CHARS;
exports.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;
exports.PUNC_CHARS = PUNC_CHARS;
exports.REGEXP_MODIFIERS = REGEXP_MODIFIERS;
exports.UNICODE = UNICODE;
exports.is_letter = is_letter;
exports.is_digit = is_digit;
exports.is_alphanumeric_char = is_alphanumeric_char;
exports.is_unicode_combining_mark = is_unicode_combining_mark;
exports.is_unicode_connector_punctuation = is_unicode_connector_punctuation;
exports.is_identifier = is_identifier;
exports.is_identifier_start = is_identifier_start;
exports.is_identifier_char = is_identifier_char;
exports.is_identifier_string = is_identifier_string;
exports.parse_js_number = parse_js_number;
exports.JS_Parse_Error = JS_Parse_Error;
exports.js_error = js_error;
exports.is_token = is_token;
exports.EX_EOF = EX_EOF;
exports.tokenizer = tokenizer;
exports.UNARY_PREFIX = UNARY_PREFIX;
exports.UNARY_POSTFIX = UNARY_POSTFIX;
exports.ASSIGNMENT = ASSIGNMENT;
exports.PRECEDENCE = PRECEDENCE;
exports.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;
exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
exports.parse = parse;
exports.TreeTransformer = TreeTransformer;
exports.SymbolDef = SymbolDef;
exports.base54 = base54;
exports.OutputStream = OutputStream;
exports.Compressor = Compressor;
exports.SourceMap = SourceMap;

exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }

exports.minify = function (files, options) {
    options = UglifyJS.defaults(options, {
        spidermonkey : false,
        outSourceMap : null,
        sourceRoot   : null,
        inSourceMap  : null,
        fromString   : false,
        warnings     : false,
        mangle       : {},
        output       : null,
        compress     : {}
    });
    UglifyJS.base54.reset();

    // 1. parse
    var toplevel = null,
        sourcesContent = {};

    if (options.spidermonkey) {
        toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
    } else {
        if (typeof files == "string")
            files = [ files ];
        files.forEach(function(file){
            var code = options.fromString
                ? file
                : fs.readFileSync(file, "utf8");
            sourcesContent[file] = code;
            toplevel = UglifyJS.parse(code, {
                filename: options.fromString ? "?" : file,
                toplevel: toplevel
            });
        });
    }

    // 2. compress
    if (options.compress) {
        var compress = { warnings: options.warnings };
        UglifyJS.merge(compress, options.compress);
        toplevel.figure_out_scope();
        var sq = UglifyJS.Compressor(compress);
        toplevel = toplevel.transform(sq);
    }

    // 3. mangle
    if (options.mangle) {
        toplevel.figure_out_scope();
        toplevel.compute_char_frequency();
        toplevel.mangle_names(options.mangle);
    }

    // 4. output
    var inMap = options.inSourceMap;
    var output = {};
    if (typeof options.inSourceMap == "string") {
        inMap = fs.readFileSync(options.inSourceMap, "utf8");
    }
    if (options.outSourceMap) {
        output.source_map = UglifyJS.SourceMap({
            file: options.outSourceMap,
            orig: inMap,
            root: options.sourceRoot
        });
        if (options.sourceMapIncludeSources) {
            for (var file in sourcesContent) {
                if (sourcesContent.hasOwnProperty(file)) {
                    output.source_map.get().setSourceContent(file, sourcesContent[file]);
                }
            }
        }

    }
    if (options.output) {
        UglifyJS.merge(output, options.output);
    }
    var stream = UglifyJS.OutputStream(output);
    toplevel.print(stream);

    if(options.outSourceMap){
        stream += "\n//# sourceMappingURL=" + options.outSourceMap;
    }

    return {
        code : stream + "",
        map  : output.source_map + ""
    };
};

exports.describe_ast = function () {
    var out = UglifyJS.OutputStream({ beautify: true });
    function doitem(ctor) {
        out.print("AST_" + ctor.TYPE);
        var props = ctor.SELF_PROPS.filter(function(prop){
            return !/^\$/.test(prop);
        });
        if (props.length > 0) {
            out.space();
            out.with_parens(function(){
                props.forEach(function(prop, i){
                    if (i) out.space();
                    out.print(prop);
                });
            });
        }
        if (ctor.documentation) {
            out.space();
            out.print_string(ctor.documentation);
        }
        if (ctor.SUBCLASSES.length > 0) {
            out.space();
            out.with_block(function(){
                ctor.SUBCLASSES.forEach(function(ctor, i){
                    out.indent();
                    doitem(ctor);
                    out.newline();
                });
            });
        }
    };
    doitem(UglifyJS.AST_Node);
    return out + "";
};
},{"source-map":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\node_modules\\source-map\\lib\\source-map.js","util":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\browserify\\node_modules\\util\\util.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\am.css":[function(require,module,exports){
module.exports = "/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n}\n\n.CodeMirror-scroll {\n  /* Set scrolling behaviour here */\n  overflow: auto;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0;\n  /* Vertical padding around content */\n}\n\n.CodeMirror pre {\n  padding: 0 4px;\n  /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler,\n.CodeMirror-gutter-filler {\n  background-color: white;\n  /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n\n\n\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-guttermarker {\n  color: black;\n}\n\n.CodeMirror-guttermarker-subtle {\n  color: #999;\n}\n\n/* CURSOR */\n\n.CodeMirror div.CodeMirror-cursor {\n  border-left: 1px solid black;\n}\n\n/* Shown when moving in bi-directional text */\n\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n\n.CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {\n  width: auto;\n  border: 0;\n  background: #7e7;\n}\n\n.cm-animate-fat-cursor {\n  width: auto;\n  border: 0;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n\n@-moz-keyframes blink {\n  0% {\n    background: #7e7;\n  }\n\n  50% {\n    background: none;\n  }\n\n  100% {\n    background: #7e7;\n  }\n}\n\n@-webkit-keyframes blink {\n  0% {\n    background: #7e7;\n  }\n\n  50% {\n    background: none;\n  }\n\n  100% {\n    background: #7e7;\n  }\n}\n\n@keyframes blink {\n  0% {\n    background: #7e7;\n  }\n\n  50% {\n    background: none;\n  }\n\n  100% {\n    background: #7e7;\n  }\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n\n\n\n.cm-tab {\n  display: inline-block;\n}\n\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-keyword {\n  color: #708;\n}\n\n.cm-s-default .cm-atom {\n  color: #219;\n}\n\n.cm-s-default .cm-number {\n  color: #164;\n}\n\n.cm-s-default .cm-def {\n  color: #00f;\n}\n\n\n\n.cm-s-default .cm-variable-2 {\n  color: #05a;\n}\n\n.cm-s-default .cm-variable-3 {\n  color: #085;\n}\n\n.cm-s-default .cm-comment {\n  color: #a50;\n}\n\n.cm-s-default .cm-string {\n  color: #a11;\n}\n\n.cm-s-default .cm-string-2 {\n  color: #f50;\n}\n\n.cm-s-default .cm-meta {\n  color: #555;\n}\n\n.cm-s-default .cm-qualifier {\n  color: #555;\n}\n\n.cm-s-default .cm-builtin {\n  color: #30a;\n}\n\n.cm-s-default .cm-bracket {\n  color: #997;\n}\n\n.cm-s-default .cm-tag {\n  color: #170;\n}\n\n.cm-s-default .cm-attribute {\n  color: #00c;\n}\n\n.cm-s-default .cm-header {\n  color: blue;\n}\n\n.cm-s-default .cm-quote {\n  color: #090;\n}\n\n.cm-s-default .cm-hr {\n  color: #999;\n}\n\n.cm-s-default .cm-link {\n  color: #00c;\n}\n\n.cm-negative {\n  color: #d44;\n}\n\n.cm-positive {\n  color: #292;\n}\n\n.cm-header,\n.cm-strong {\n  font-weight: bold;\n}\n\n.cm-em {\n  font-style: italic;\n}\n\n.cm-link {\n  text-decoration: underline;\n}\n\n.cm-s-default .cm-error {\n  color: #f00;\n}\n\n.cm-invalidchar {\n  color: #f00;\n}\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {\n  color: #0f0;\n}\n\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {\n  color: #f22;\n}\n\n.CodeMirror-matchingtag {\n  background: rgba(255, 150, 0, .3);\n}\n\n.CodeMirror-activeline-background {\n  background: #e8f2ff;\n}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  line-height: 1;\n  position: relative;\n  overflow: hidden;\n  background: white;\n  color: black;\n}\n\n.CodeMirror-scroll {\n  /* 30px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -30px;\n  margin-right: -30px;\n  padding-bottom: 30px;\n  height: 100%;\n  outline: none;\n  /* Prevent dragging from highlighting the element */\n  position: relative;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 30px solid transparent;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actuall scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n\n.CodeMirror-vscrollbar,\n.CodeMirror-hscrollbar,\n.CodeMirror-scrollbar-filler,\n.CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n}\n\n.CodeMirror-vscrollbar {\n  right: 0;\n  top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n\n.CodeMirror-hscrollbar {\n  bottom: 0;\n  left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n\n.CodeMirror-scrollbar-filler {\n  right: 0;\n  bottom: 0;\n}\n\n.CodeMirror-gutter-filler {\n  left: 0;\n  bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute;\n  left: 0;\n  top: 0;\n  padding-bottom: 30px;\n  z-index: 3;\n}\n\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n  padding-bottom: 30px;\n  margin-bottom: -32px;\n  display: inline-block;\n  /* Hack to make IE7 behave */\n  *zoom: 1;\n  *display: inline;\n}\n\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n\n.CodeMirror-lines {\n  cursor: text;\n}\n\n.CodeMirror pre {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0;\n  -webkit-border-radius: 0;\n  border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n}\n\n.CodeMirror-wrap pre {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  overflow: auto;\n}\n\n\n\n.CodeMirror-wrap .CodeMirror-scroll {\n  overflow-x: hidden;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-measure pre {\n  position: static;\n}\n\n.CodeMirror div.CodeMirror-cursor {\n  position: absolute;\n  border-right: none;\n  width: 0;\n}\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 1;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected {\n  background: #d9d9d9;\n}\n\n.CodeMirror-focused .CodeMirror-selected {\n  background: #d7d4f0;\n}\n\n.CodeMirror-crosshair {\n  cursor: crosshair;\n}\n\n.cm-searching {\n  background: #ffa;\n  background: rgba(255, 255, 0, .4);\n}\n\n/* IE7 hack to prevent it from returning funny offsetTops on the spans */\n\n.CodeMirror span {\n  *vertical-align: text-bottom;\n}\n\n/* Used to force a border model for a node */\n\n.cm-force-border {\n  padding-right: .1px;\n}\n\n@media print {\n  /* Hide the cursor when printing */\n\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n/**\n * Pastel On Dark theme ported from ACE editor\n * @license MIT\n * @copyright AtomicPages LLC 2014\n * @author Dennis Thompson, AtomicPages LLC\n * @version 1.1\n * @source https://github.com/atomicpages/codemirror-pastel-on-dark-theme\n */\n\n.cm-s-pastel-on-dark.CodeMirror {\n  background: #2c2827;\n  color: #8F938F;\n  line-height: 1.5;\n  font-size: 14px;\n}\n\n.cm-s-pastel-on-dark div.CodeMirror-selected {\n  background: rgba(221,240,255,0.2) !important;\n}\n\n.cm-s-pastel-on-dark .CodeMirror-gutters {\n  background: #34302f;\n  border-right: 0px;\n  padding: 0 3px;\n}\n\n.cm-s-pastel-on-dark .CodeMirror-guttermarker {\n  color: white;\n}\n\n.cm-s-pastel-on-dark .CodeMirror-guttermarker-subtle {\n  color: #8F938F;\n}\n\n.cm-s-pastel-on-dark .CodeMirror-linenumber {\n  color: #8F938F;\n}\n\n.cm-s-pastel-on-dark .CodeMirror-cursor {\n  border-left: 1px solid #A7A7A7 !important;\n}\n\n.cm-s-pastel-on-dark span.cm-comment {\n  color: #A6C6FF;\n}\n\n.cm-s-pastel-on-dark span.cm-atom {\n  color: #DE8E30;\n}\n\n.cm-s-pastel-on-dark span.cm-number {\n  color: #CCCCCC;\n}\n\n.cm-s-pastel-on-dark span.cm-property {\n  color: #8F938F;\n}\n\n.cm-s-pastel-on-dark span.cm-attribute {\n  color: #a6e22e;\n}\n\n.cm-s-pastel-on-dark span.cm-keyword {\n  color: #AEB2F8;\n}\n\n.cm-s-pastel-on-dark span.cm-string {\n  color: #66A968;\n}\n\n.cm-s-pastel-on-dark span.cm-variable {\n  color: #AEB2F8;\n}\n\n.cm-s-pastel-on-dark span.cm-variable-2 {\n  color: #BEBF55;\n}\n\n.cm-s-pastel-on-dark span.cm-variable-3 {\n  color: #DE8E30;\n}\n\n.cm-s-pastel-on-dark span.cm-def {\n  color: #757aD8;\n}\n\n.cm-s-pastel-on-dark span.cm-bracket {\n  color: #f8f8f2;\n}\n\n.cm-s-pastel-on-dark span.cm-tag {\n  color: #C1C144;\n}\n\n.cm-s-pastel-on-dark span.cm-link {\n  color: #ae81ff;\n}\n\n.cm-s-pastel-on-dark span.cm-qualifier,\n.cm-s-pastel-on-dark span.cm-builtin {\n  color: #C1C144;\n}\n\n.cm-s-pastel-on-dark span.cm-error {\n  background: #757aD8;\n  color: #f8f8f0;\n}\n\n.cm-s-pastel-on-dark .CodeMirror-activeline-background {\n  background: rgba(255, 255, 255, 0.031) !important;\n}\n\n.cm-s-pastel-on-dark .CodeMirror-matchingbracket {\n  border: 1px solid rgba(255,255,255,0.25);\n  color: #8F938F !important;\n  margin: -1px -1px 0 -1px;\n}";

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.bezierEditor.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createBezierEditor: createBezierEditor,

        EASE2BEZIER: {
            'ease': 'cubic-bezier(.25,.1,.25,1)',
            'linear': 'cubic-bezier(0,0,1,1)',
            'ease-in': 'cubic-bezier(.42,0,1,1)',
            'ease-out': 'cubic-bezier(0,0,.58,1)',
            'ease-in-out': 'cubic-bezier(.42,0,.58,1)',
        },
    };
};


function createBezierEditor(opt) {

    opt = opt || {};

    var p0 = {x: 0.3, y: 0.3},
        p1 = {x: 0.7, y: 0.7},
        w = opt.width || 312,
        h = opt.height || 312;

    var de = document.createElement('div');
    de.style.position = 'relative';
    de.style.width = w + 'px';
    de.style.height = h + 'px';

    var c = document.createElement('canvas');
    c.width = w;
    c.height = h;
    de.appendChild(c);

    var ctx = c.getContext('2d');
  
    var deCp0 = createCp(p0);
    var deCp1 = createCp(p1);

    de.getValue = function () {

        return 'cubic-bezier('+p0.x+','+p0.y+','+p1.x+','+p1.y+')';
    };

    de.setValue = function (points) {

        if (amgui.EASE2BEZIER.hasOwnProperty(points)) {

            points = amgui.EASE2BEZIER[points];
        }

        if (typeof(points) === 'string') {

            var rx = /cubic-bezier\(\s*([\d\.]+)\s*,\s*([\d\.-]+)\s*,\s*([\d\.]+)\s*,\s*([\d\.-]+)\s*\)/,
                m = rx.exec(points);

            if (m) {
                points = {
                    cp0x: m[1],
                    cp0y: m[2],
                    cp1x: m[3],
                    cp1y: m[4],
                };
            }
            else {
                points = {
                    cp0x: 0.3,
                    cp0y: 0.3,
                    cp1x: 0.7,
                    cp1y: 0.7,
                };
            }
        }

        p0.x = points.cp0x;
        p0.y = points.cp0y;
        p1.x = points.cp1x;
        p1.y = points.cp1y;
        
        render();
    };
    
    render();

    if (opt.onChange) {
        de.addEventListener('change', opt.onChange);
    }

    if (opt.parent) {
        opt.parent.appendChild(de);
    }
  
    return de;
  

  
  

    function render() {

        ctx.clearRect(0, 0, w, h);
        ctx.beginPath();
        ctx.moveTo(x(p0.x), y(p0.y));
        ctx.lineTo(0, y(0));
        ctx.bezierCurveTo(
            x(p0.x), y(p0.y),
            x(p1.x), y(p1.y),
            x(1), y(1));
        ctx.lineTo(x(p1.x), y(p1.y));
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.rect(x(0), y(0), x(1), y(1) - y(0));
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.stroke();
      
        deCp0.refreshPosition();
        deCp1.refreshPosition();
    }

    function x (p) {
        return p * w;
    }

    function y (p) {

        var min = minY(),
            max = maxY(),
            full = max - min;

        return h - (((p - min) / full) * h);
    }
  
    function minY() {
    
        return Math.min(0, p0.y, p1.y);
    }
  
    function maxY() {
    
        return Math.max(1, p0.y, p1.y);
    }

    function createCp(point) {

        var r = 6;

        var deCp = document.createElement('div');
        deCp.style.position = 'absolute';
        deCp.style.cursor = 'grab';
        deCp.style.boxSizing = 'border-box';
        deCp.style.width = r*2 + 'px';
        deCp.style.height = r*2 + 'px';
        deCp.style.transform = 'translate(-'+r+'px,-'+r+'px)';
        deCp.style.borderRadius = r + 'px';
        deCp.style.background = 'rgba(256, 256, 256, 1)';
        de.appendChild(deCp);
      
        amgui.makeDraggable({
            deTarget: deCp,
            onDown: function () {

                deCp.style.cursor = 'grabbing';

                var md = {};
                md.minY = minY();
                md.fullY = maxY() - md.minY;    
                return md;
            },
            onMove: function (md, mx, my) {

                var br = de.getBoundingClientRect();

                point.x = Math.max(0, Math.min(1, (mx - br.left) / w));
                point.y = (((br.bottom - my) / h) * md.fullY) - md.minY;
                
                var fix = 1000;
                point.x = parseInt(point.x * fix) / fix;
                point.y = parseInt(point.y * fix) / fix;

                render();
              
                de.dispatchEvent(new CustomEvent('change', {detail: {value: de.getValue()}}));
            },
            onUp: function () {

                deCp.style.cursor = 'grab';
            }
        });
      
        deCp.refreshPosition = function () {
            
            deCp.style.left = x(point.x) + 'px';
            deCp.style.top = y(point.y) + 'px';
        };
        deCp.refreshPosition();
      
        return deCp;
    }
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.button.js":[function(require,module,exports){
'use strict';

var fontelloConf = require('../assets/fontello/config.json');
var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createIcon: createIcon,
        createLabel: createLabel,
        createBtn: createBtn,
        createIconBtn: createIconBtn,
        createToggleIconBtn: createToggleIconBtn,
        createLinebreak: createLinebreak,
    };
};


function createLinebreak(opt) {

    var de = document.createElement('br');
    de.innerHTML = opt.caption || 'label';
    
    if (opt.parent) {
        opt.parent.appendChild(de);
    }

    return de;
}

function createLabel(opt) {

    var de = document.createElement('span');
    de.innerHTML = opt.caption || 'label';

    if ('fontSize' in opt) de.style.fontSize = opt.fontSize;
    if ('display' in opt) de.style.display = opt.display;
    if ('position' in opt) de.style.position = opt.position;
    
    if (opt.parent) {
        opt.parent.appendChild(de);
    }

    return de;
}

function createBtn(opt) {

    opt.backgroundColor = opt.backgroundColor || amgui.color.bg0;

    var de = document.createElement('div');
    de.style.height = (opt.height || 21) + 'px';
    de.style.padding = '0 15px';
    de.style.cursor = 'pointer';
    de.style.color = amgui.color.text;
    de.style.backgroundColor = opt.backgroundColor;

    de.setCaption = function (caption) {

        de.textContent = caption;
    };
    
    de.setCaption(opt.caption || 'button');

    de.addEventListener('mouseenter', onMOver);
    de.addEventListener('mouseleave', onMOut);

    function onMOver() {

        this.style.background = amgui.color.bgHover;
    }

    function onMOut() {
        
        this.style.background = opt.backgroundColor;
    }

    if (opt.parent) {
        opt.parent.appendChild(de);
    }

    return de;
}

function createIconBtn(opt) {

    var isFixedHighlight = false;

    var de = amgui.createIcon({
        size: opt.height, 
        icon: opt.icon,
        parent: opt.parent,
        tooltip: opt.tooltip,
        display: opt.display,
    });
    de.style.width = (opt.width || 21) + 'px';
    de.style.cursor = 'pointer';
    de.style.color = 'white';
    de.style.overflow = 'hidden';

    de.addEventListener('mouseenter', onMOver);
    de.addEventListener('mouseleave', onMOut);

    if ('onClick' in opt) {
        de.addEventListener('click', opt.onClick);
    }

    function onMOver() {

        de.style.background = amgui.color.bgHover;
    }

    function onMOut() {
        
        if (isFixedHighlight) return;

        de.style.background = 'none';
    }

    de.fixHighlight = function () {

        isFixedHighlight = true;
        onMOver();
    };

    de.removeFixHighlight = function () {

        isFixedHighlight = false;
        onMOut();
    };

    return de;
}

function createToggleIconBtn(opt) {

    opt.iconOn = opt.iconOn || opt.icon;
    opt.iconOff = opt.iconOff || opt.icon;
    opt.color = opt.color || amgui.color.text;
    opt.colorInactive = opt.colorInactive || amgui.color.textInactive;

    var isOn = opt.defaultToggle || false;
    var de = amgui.createIconBtn(opt);
    setIcon();

    if ('autoToggle' in opt ? opt.autoToggle : !opt.onClick) {
        
        de.addEventListener('click', onClick);
    }

    if ('onToggle' in opt) {

        de.addEventListener('toggle', opt.onToggle);
    }

    de.setToggle = function (on) {

        on = !!on;
        if (on === isOn) {
            return;
        }
        
        isOn = on;
        setIcon();

        de.dispatchEvent(new CustomEvent('toggle', {detail: {state: isOn}}));
        de.dispatchEvent(new Event(isOn ? 'toggleOn' : 'toggleOff'));
    };

    de.state = function () {

        return isOn;
    };


    function onClick() {
        
        de.setToggle(!isOn);
    }

    function setIcon() {

        de.setIcon(isOn ? opt.iconOn : opt.iconOff);

        if (opt.changeColor) {
            de.style.color = isOn ? opt.color : opt.colorInactive;
        }
    }

    return de;
}

function createIcon(opt) {

    opt = opt || {};
    opt.size = opt.size || 23;
    
    var de = document.createElement('div');
    de.style.color = '#fff';
    de.style.width = opt.size + 'px';
    de.style.height = opt.size + 'px';
    de.style.lineHeight = opt.size + 'px';
    de.style.textAlign = 'center';
    de.style.fontFamily = 'amgui';
    de.style.fontSize = Math.round(opt.size * 0.72) + 'px';
    de.style.display = opt.display || 'block';

    de.setIcon = function (icon) {

        var glyph = fontelloConf.glyphs.find(function (glyph) {

            return glyph.css === icon;
        });

        var code = glyph ? glyph.code : 59407;
        de.textContent = String.fromCharCode(code);
    };

    de.setIcon(opt.icon);

    if (opt.tooltip) {
        amgui.addTooltip({
            deTarget: de,
            text: opt.tooltip
        });
    }

    if (opt.parent) {
        opt.parent.appendChild(de);
    }

    return de;
}
},{"../assets/fontello/config.json":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\assets\\fontello\\config.json"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.dialog.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createDialog: createDialog,
    };
};



function createDialog(opt) {

    var de, deTitle, deTitleText, deTitleIcon, titleEnd,
        contentCont, buttonsCont, buttonsEnd;

    de = document.createElement('dialog');
    (opt.parent || document.body).appendChild(de);

    de.style.background = 'none';
    de.style.border = 'none';
    de.style.pointerEvents = 'auto';
    de.style.fontFamily = amgui.FONT_FAMILY;
    de.style.color = amgui.color.text;


    deTitle = document.createElement('div');
    deTitle.style.display = 'inline-block';
    deTitle.style.padding = '0 18px';
    deTitle.style.height = '34px';
    deTitle.style.fontSize = '23px';
    deTitle.style.fontWeight = 'bold';
    deTitle.style.background = amgui.color.overlay;
    deTitle.style.color = amgui.color.text;
    de.appendChild(deTitle);

    deTitleText = document.createElement('span');
    deTitle.appendChild(deTitleText);

    if (opt.titleIcon) {

        deTitleIcon = amgui.createIcon({
            icon: opt.titleIcon,
            parent: deTitle,
            display: 'inline-block',
        });
    }

    titleEnd = document.createElement('div');
    titleEnd.style.display = 'inline-block';
    titleEnd.style.width = '0';
    titleEnd.style.height = '0';
    titleEnd.style.verticalAlign = 'bottom';
    titleEnd.style.borderStyle = 'solid';
    titleEnd.style.borderWidth = '34px 0 0 8px';
    titleEnd.style.borderColor = 'transparent transparent transparent ' + amgui.color.overlay;
    de.appendChild(titleEnd);

    

    contentCont = document.createElement('div');
    contentCont.style.background = amgui.color.overlay;
    de.appendChild(contentCont);

    buttonsCont = document.createElement('div');
    buttonsCont.style.background = amgui.color.overlay;
    buttonsCont.style.display = 'inline-block';
    buttonsCont.style.float = 'right';
    de.appendChild(buttonsCont);


    de.setTitle = function (title) {

        deTitleText.textContent = title || 'Dialog';
    };

    de.setContent = function (content) {

        if (!content) {
            return;
        }

        contentCont.innerHTML = '';
        contentCont.appendChild(content);
    };

    de.setButtons = function (buttons) {

        if (!buttons) {
            return;
        }

        buttonsCont.innerHTML = '';

        buttons.forEach(function (caption) {

            var btn = amgui.createBtn({caption: caption});
            btn.style.display = 'inline-block';
            btn.style.fontWeight = 'bold';
            btn.style.fontSize = '18px';
            btn.style.background = 'none';
            buttonsCont.appendChild(btn);

            btn.addEventListener('click', function () {
                de.dispatchEvent(new Event('click_' + caption.toLowerCase()));
            });
        });
    };

    de.setTitle(opt.title);
    de.setContent(opt.content);
    de.setButtons(opt.buttons);

    buttonsEnd = document.createElement('div');
    buttonsEnd.style.display = 'inline-block';
    buttonsEnd.style.float = 'right';
    buttonsEnd.style.width = '0';
    buttonsEnd.style.height = '0';
    buttonsEnd.style.verticalAlign = 'top';
    buttonsEnd.style.borderStyle = 'solid';
    buttonsEnd.style.borderWidth = '0 6px 21px 0';
    buttonsEnd.style.borderColor = 'transparent '+amgui.color.overlay+' transparent transparent';
    de.appendChild(buttonsEnd);

    return de;
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.dropdown.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createDropdown: createDropdown,
        bindDropdown: bindDropdown,
    };
};



function createDropdown(opt) {

    var options = opt.options || [];

    var de = document.createElement('ul');
    de.style.listStyleType = 'none';
    de.style.margin = 0;
    de.style.padding = 0;

    options.forEach(function (opt) {

        if (typeof(opt) === 'string') {

            opt = {text: opt};
        }

        var li = document.createElement('li');
        li.textContent = opt.text;
        li.style.textAlign = 'left';
        li.style.fontFamily = amgui.FONT_FAMILY;
        li.style.fontSize = '14px';
        li.style.padding = '0 3px';
        li.style.cursor = 'pointer';
        li.style.color = amgui.color.text;
        li.style.background = amgui.color.bg2;

        li.addEventListener('click', function (e) {

            e.stopPropagation();

            if (opt.onSelect) {
                opt.onSelect();
            }

            de.dispatchEvent(new CustomEvent('select', {detail: {selection: opt.text}}));
        });
        de.appendChild(li);
    });

    if (opt.onSelect) {

        de.addEventListener('select', opt.onSelect);
    }

    return de;
}

function bindDropdown(opt) {

    var isOpened = false;
    var deBtn = opt.deTarget;
    var deDropdown = opt.deMenu;

    if (opt.asContextMenu) {

        deBtn.addEventListener('contextmenu', function (e) {

            e.stopPropagation();
            e.preventDefault();
            isOpened ? close(e) : open(e);
        });
    }
    else {
        
        deBtn.addEventListener('click', function (e) {

            e.stopPropagation();
            isOpened ? close(e) : open(e);
        });
    }

    deDropdown.style.position = 'fixed';
    deDropdown.style.pointerEvents = 'auto';
    
    deDropdown.addEventListener('select', close);

    function open(e) {

        if (isOpened) return;
        isOpened = true;

        
        amgui.placeToPoint(deDropdown, e.clientX, e.clientY, opt.side);

        var deCont = opt.menuParent || amgui.deOverlayCont || deBtn;

        deCont.appendChild(deDropdown);
        window.addEventListener('click', close);
    }

    function close() {

        if (!isOpened) return;
        isOpened = false;
        
        if (deDropdown.parentElement) {
            deDropdown.parentElement.removeChild(deDropdown);
        }
        window.removeEventListener('click', close);
    }
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.input.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createInput: createInput,
    };
};


function createInput(opt) {

    opt = opt || {};

    var inp = document.createElement('input');
    inp.type = opt.type || 'text';
    inp.style.width = opt.width || '245px';
    inp.style.height = opt.height || '14px';
    inp.style.fontSize = opt.fontSize || '14px';
    inp.style.fontFamily = amgui.FONT_FAMILY;
    inp.style.color = amgui.color.text;
    inp.style.background = 'none';
    inp.style.border = 'none';

    if ('palceholder' in opt) inp.palceholder = opt.palceholder;
    if ('value' in opt) inp.value = opt.value;

    if (opt.parent) {
        opt.parent.appendChild(inp);
    }

    return inp;
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;

WebFont.load({
    google: {
      families: ['Open Sans']
    }
});

var amgui = new EventEmitter();

_.extend(amgui,
    require('./amgui.bezierEditor')(amgui),
    require('./amgui.button')(amgui),
    require('./amgui.dialog')(amgui),
    require('./amgui.dropdown')(amgui),
    require('./amgui.input')(amgui),
    require('./amgui.keys')(amgui),
    require('./amgui.keyValueInput')(amgui),
    require('./amgui.makeDraggable')(amgui),
    require('./amgui.scroll')(amgui),
    require('./amgui.tooltip')(amgui),
    require('./amgui.utils')(amgui),
    {

        FONT_FAMILY: '"Open Sans", sans-serif',
        FONT_SIZE: '15px',

        color: {
            bg0: '#000',
            bg1: '#222',
            bg2: '#444',
            bg3: '#666',
            text: '#efe',
            textInactive: 'rgba(255,255,255,.23)',
            overlay: 'rgba(0,0,0,.785)',
            bgHover: 'rgba(255,255,255,0.12)',
        },

        getStyleSheet: function () {

            var style = document.createElement('style');

            style.innerHTML = 'dialog::backdrop { background:'+amgui.color.bgHover+' }';

            return style;
        }
    }
);


amgui.setMaxListeners(0);

module.exports = amgui;
},{"./amgui.bezierEditor":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.bezierEditor.js","./amgui.button":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.button.js","./amgui.dialog":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.dialog.js","./amgui.dropdown":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.dropdown.js","./amgui.input":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.input.js","./amgui.keyValueInput":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.keyValueInput.js","./amgui.keys":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.keys.js","./amgui.makeDraggable":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.makeDraggable.js","./amgui.scroll":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.scroll.js","./amgui.tooltip":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.tooltip.js","./amgui.utils":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.utils.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.keyValueInput.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createKeyValueInput: createKeyValueInput,
    };
};



function createKeyValueInput(opt) {

        opt = opt || {};

        var de = document.createElement('div');
        de.style.margin = '0 1px';

        var keyOn = false;

        var oldKey, oldValue;

        var inpKey = createInput('parameter name');
        inpKey.addEventListener('keypress', onKeyPress);

        var divider = createDivider();

        var inpValue = createInput('value');
        // inpValue.style.color = 'lightblue';
        inpValue.style.textAlign = 'right';
        inpValue.style.right = '0px';

        showHideValue(keyOn);

        de.getKey = function () {
            return inpKey.value;
        };

        de.setKey = function (v) {
            
            if (v === oldKey) return;
            
            oldKey = v;
            inpKey.value = v;
            checkKeyOn();
        };

        de.getValue = function () {
            return inpValue.value;
        };

        de.setValue = function (v) {
            
            if (v === oldValue) return;

            oldValue = v;
            inpValue.value = v;
        };

        if (opt.parent) {
            opt.parent.appendChild(de);
        }

        if (opt.key) {
            de.setKey(opt.key);
        }

        if (opt.value) {
            de.setValue(opt.value);
        }

        if (opt.onChange) {
            de.addEventListener('change', opt.onChange);
        }

        function onChange(e) {

            e.preventDefault();
            e.stopPropagation();
            
            checkKeyOn();

            var detail = {};
            
            if (de.getKey() !== oldKey) {
                oldKey = detail.key = de.getKey();
            }
            if (de.getValue() !== oldValue) {
                oldValue = detail.value = de.getValue();
            }

            if ('value' in detail || 'key' in detail) {

                de.dispatchEvent(new CustomEvent('change', {detail: detail}));
            }
        }

        function onKeyPress(e) {
            
            if (e.keyCode === 13) {
                
                e.preventDefault();
                e.stopPropagation();

                inpValue.focus();
            }
        }

        function checkKeyOn() {

            var on = !!inpKey.value;

            if (on !== keyOn) {
                
                keyOn = on;
                showHideValue(keyOn);
            }
        }

        function showHideValue(show) {
            
            divider.style.display = show ? 'inline' : 'none';
            inpValue.style.display = show ? 'inline-block' : 'none';
            inpKey.style.width = show ? 'calc(50% - 5px)' : '100%';
        }

        function createInput(placeholder) {

            var inp = document.createElement('input');
            inp.type = 'text';
            inp.placeholder = placeholder;
            inp.style.width = '50%';
            inp.style.height = '100%';
            inp.style.fontSize = amgui.FONT_SIZE;
            inp.style.fontFamily = amgui.FONT_FAMILY;
            inp.style.background = 'none';
            inp.style.border = 'none';
            inp.style.color = amgui.color.text;
            inp.addEventListener('change', onChange);
            inp.addEventListener('keyup', onChange);
            // $(inp).autosizeInput({space: 0});
            de.appendChild(inp);
            return inp;
        }

        function createDivider () {

            var divider = document.createElement('span');
            divider.textContent = ':';
            divider.style.color = amgui.color.text;
            divider.style.width = '2px';
            divider.style.fontSize = amgui.FONT_SIZE;
            divider.style.fontFamily = amgui.FONT_FAMILY;
            de.appendChild(divider);

            return divider;
        }

        return de;
    }
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.keys.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createKeyline: createKeyline,
        createKey: createKey
    };
};


function createKeyline(opt) {

    var deKeys = [];

    var de = document.createElement('div');
    de.style.width = '100%';
    de.style.height = (opt.height || 21) + 'px';
    de.style.background = opt.background || 'grey';
    de.style.position = 'relative';

    var svgEase = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgEase.style.width = '100%';
    svgEase.style.height = '100%';
    svgEase.style.fill = 'none';
    svgEase.style.stroke = 'white';
    svgEase.style.position = 'absolute';
    de.appendChild(svgEase);

    amgui.callOnAdded(de, renderEase);

    de.addKey = function (opt) {

        var deKey = amgui.createKey(opt);
        deKeys.push(deKey);

        de.appendChild(deKey);

        deKey.addEventListener('change', renderEase);
        deKey.addEventListener('remove', onKeyRemove);
        renderEase();

        return deKey;
    };

    function sortKeys() {

        deKeys.sort(function (a, b) {
        
            return a.offsetLeft - b.offsetLeft;
        });
    }

    function onKeyRemove () {

        var deKey = this,
            idx = deKeys.indexOf(deKey);

        if (idx === -1) {
            return;
        }

        deKeys.splice(idx, 1);
        
        deKey.removeEventListener('change', renderEase);
        deKey.removeEventListener('remove', onKeyRemove);

        if (deKey.parentNode) {
            deKey.parentNode.removeChild(deKey);
        }

        renderEase();
    }

    function renderEase() {

        sortKeys();

        svgEase.innerHTML = '';

        deKeys.forEach(function (deKey, idx) {

            if (idx === deKeys.length-1) {
                return;
            }

            var ease = deKey.ease;

            if (amgui.EASE2BEZIER.hasOwnProperty(ease)) {
                ease = amgui.EASE2BEZIER[ease];
            }

            var rx = /cubic-bezier\(\s*([\d\.]+)\s*,\s*([\d\.-]+)\s*,\s*([\d\.]+)\s*,\s*([\d\.-]+)\s*\)/,
                m = rx.exec(ease),
                x = deKey.offsetLeft,
                w = deKeys[idx+1].offsetLeft - x,
                h = de.offsetHeight,
                path = document.createElementNS('http://www.w3.org/2000/svg', 'path'),
                d = '';

            if (m) {
                d += 'M' + x + ',' + h + ' ';
                d += 'C' + (x + w*m[1]) + ',' + (h - h*m[2]) + ' ';
                d += (x + w*m[3]) + ',' + (h - h*m[4]) + ' ';
                d += (x + w) + ',' + 0;
            }
            else {
                return;
                //TODO steps()
                // d += 'M' + x + ',' + h + ' ';
                // d += 'L' + (x + w) + ',0';
            }

            path.setAttribute('d', d);
            svgEase.appendChild(path);
        });
    }

    return de;
}

function createKey(opt) {

    opt = opt || {};

    opt.color = opt.color || '#7700ff';

    var isUserSelected = false,
        time = opt.time || 0, 
        timescale = opt.timescale || 1;

    var de = document.createElement('div');
    de.style.position = 'absolute';
    de.style.transform = 'translateX(-4px)';

    var key = document.createElement('div');
    key.style.width = '0';
    key.style.height = '0';
    key.style.borderStyle = 'solid';
    key.style.borderWidth = '21px 4px 0 4px';
    key.style.borderColor = opt.color + ' transparent transparent transparent';
    de.appendChild(key);

    amgui.makeDraggable({
        deTarget: de,
        onDown: function (e) {

            if (!e.shiftKey && !e.ctrlKey) {
                amgui.emit('deselectAllKeys');
            }

            if (e.ctrlKey) {
                toggleUserSelected();
            }
            else {
                userSelect(true);
            }
            
            return {
                dragged: 0,
            };
        },
        onMove: function (md, mx) {

            var diff = mx - md.mx,
                diffTime = (diff / timescale) - md.dragged;
                
            md.dragged += diffTime;

            amgui.emit('translateSelectedKeys', diffTime);
        }
    });

    amgui.on('deselectAllKeys', onDeselectAllKeys);
    amgui.on('translateSelectedKeys', onTranslateSelectedKeys);

    de.setTime = function(t) {

        if (time === t) return;

        time = t;
        setLeft();
        de.dispatchEvent(new Event('change'));

        de.dispatchEvent(new CustomEvent('changeTime', {detail: {time: time}}));
    };
    de.setTimescale = function(ts) {

        if (timescale === ts) return;

        timescale = ts;
        setLeft();
        de.dispatchEvent(new Event('change'));
    };

    de.setEase = function(ease) {

        if (de.ease === ease) {
            return;
        }   

        de.ease = ease;

        de.dispatchEvent(new Event('change'));
    };

    de.remove = function() {

        amgui.removeListener('deselectAllKeys', onDeselectAllKeys);
        amgui.removeListener('translateSelectedKeys', onTranslateSelectedKeys);

        de.dispatchEvent(new Event('remove'));
    };

    setLeft();
    de.setEase(opt.ease);

    return de;

    ///////////////////////////////////////////////////////


    function setLeft() {

        de.style.left = (time * timescale) + 'px';
    }

    function toggleUserSelected() {

        userSelect(!isUserSelected);
    }

    function userSelect(on) {

        isUserSelected = on;
        de.style.background = isUserSelected ? 'white' : 'none';
    }

    function onDeselectAllKeys() {

        userSelect(false);
    }

    function onTranslateSelectedKeys(offset) {

        if (isUserSelected) {

            de.setTime(time + offset);
        }
    }
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.makeDraggable.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        makeDraggable: makeDraggable,
    };
};

function makeDraggable(opt) {

    opt = opt || {};

    var md;

    opt.deTarget.addEventListener('mousedown', onDown);
    opt.deTarget.addEventListener('mouseenter', onEnter);
    opt.deTarget.addEventListener('mouseleave', onLeave);

    function onDown(e) {

        if (e.button !== 0) {
            
            return;
        }

        e.stopPropagation();
        e.preventDefault();

        md = call('onDown', [e]) || {};

        md.mx = e.clientX;
        md.my = e.clientY;

        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('mouseleave', onUp);
    }

    function onMove(e) {

        call('onMove', [md, e.clientX, e.clientY, e]);
    }

    function onUp(e) {

        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        window.removeEventListener('mouseleave', onUp);

        call('onUp', [md, e.clientX, e.clientY, e]);
    }

    function onEnter() {

        call('onEnter');
    }

    function onLeave() {
        
        call('onLeave');
    }

    function call(name, args) {

        if (name in opt) {

            return opt[name].apply(opt.thisArg, args);
        }
    }
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.scroll.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        createRange: createRange,
        makeScrollable: makeScrollable,
    };
};



function makeScrollable(opt) {

    var pos = 0,
        deConts = opt.deCont,
        deTargets = opt.deTarget,
        deRange = opt.deRange,
        ret = {dispose: dispose};

    if (!Array.isArray(deConts)) deConts = [deConts];
    if (!Array.isArray(deTargets)) deTargets = [deTargets];

    deConts.forEach(function (deC) {

        deC.addEventListener('wheel', onWheel);
    });

    if (deRange) {
        initRange();
    }

    return ret;

    function onWheel(e) {

        var way = e.deltaY/3,
            maxH = getTargetMaxH();
        
        pos = Math.max(0, Math.min(maxH, pos + way));

        if (deRange) {

            deRange.setValue(pos / maxH);
        }

        scroll();

    }

    function onChangeRange(e) {

        pos = getTargetMaxH() * e.detail.value;
        scroll();
    }

    function scroll() {

        deTargets.forEach(function (deT) {

            deT.style.top = -pos + 'px';
        });
    }

    function getTargetMaxH() {

        var contH = Math.max.apply(null, deConts.slice().map(getH)),
            targetH = Math.max.apply(null, deTargets.slice().map(getH));

        return targetH - contH;
    }

    function getH(de) {

        return de.getBoundingClientRect().height;
    }

    function initRange() {

        var saveDisplay = deRange.style.display,
            isShowing = false,
            refreshSetI;

        deRange.style.display = 'none';

        deRange.addEventListener('change', onChangeRange);

        refreshSetI = setInterval(function () {

            var needsRange = getTargetMaxH() > 0;

            if (isShowing !== needsRange) {

                isShowing = needsRange;

                deRange.style.display = isShowing ? saveDisplay : 'none';
            }
        }, 312); 

        var saveDispose = ret.dispose;
        ret.dispose = function dispose () {

            saveDispose();

            clearInterval(refreshSetI);

            deRange.removeEventListener('change', onChangeRange);
        };
    }

    function dispose() {

        deConts.forEach(function (deC) {

            deC.removeEventListener('wheel', onWheel);
        });
    }
}




function createRange(opt) {

    opt = opt || {};
  
    var value = 0, cursorWidth = 0, isVertical = !!opt.vertical;

    var de = document.createElement('div');
    de.style.position = 'relative';
    de.style.width = opt.width || '12px';
    de.style.height = opt.height || '140px';
    de.style.background = amgui.color.bg1;
    de.style.cursor = 'pointer';

    var deCursor = document.createElement('div');
    deCursor.style.position = 'absolute';
    deCursor.style[d('left','top')] = '0';
    deCursor.style[d('right','bottom')] = '0';
    deCursor.style.margin = d('auto 0','0 auto');
    deCursor.style.background = amgui.color.bg3;
    deCursor.style[d('width','height')] = opt.cursorHeight || '100%';
    de.appendChild(deCursor);

    if (opt.parent) {
        opt.parent.appendChild(de);
    }

    de.setCursorWidth = function (w) {

        deCursor.style[d('height','width')] = w + 'px';
        cursorWidth = w;
    };
    de.setCursorWidth(opt.cursorWidth || 12);   

    amgui.makeDraggable({
        deTarget: de,
        onMove: function (md, mx, my) {

            var br = de.getBoundingClientRect(),
                p = d(my, mx) - (d(br.top, br.left) + cursorWidth/2),
                fw = d(br.height, br.width) - cursorWidth,
                pos = Math.max(0, Math.min(1, p / fw));

            de.setValue(pos);
        }
    });

    de.setValue = function (v) {

        if (v === value) return;

        value = v;
        
        var width = de.getBoundingClientRect()[d('height','width')];
        deCursor.style[d('top','left')] = ((width - cursorWidth) * value) + 'px';

        de.dispatchEvent(new CustomEvent('change', {detail: {value: value}}));
    };

    de.getValue = function () {

        return value;
    };

    function d (vertical, horisontal) {

        return isVertical ? vertical : horisontal;
    }

    return de;
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.tooltip.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        addTooltip: addTooltip,
    };
};



function addTooltip(opt) {

    var showSetT, delay = 423, mx = 0, my = 0;

    var de = document.createElement('div');
    de.textContent = opt.text;
    de.style.position = 'fixed';
    de.style.padding = '12px';
    de.style.display = 'inline-block';
    de.style.background = amgui.color.overlay;
    de.style.color = amgui.color.text;

    opt.deTarget.addEventListener('mouseenter', onMEnter);

    function onMEnter(e) {

        opt.deTarget.addEventListener('mousemove', onMMove);
        opt.deTarget.addEventListener('mouseleave', onMLeave);
        opt.deTarget.addEventListener('mousedown', onMLeave);

        onMMove(e);
    }

    function onMLeave() {

        opt.deTarget.removeEventListener('mousemove', onMMove);
        opt.deTarget.removeEventListener('mouseleave', onMLeave);
        opt.deTarget.removeEventListener('mousedown', onMLeave);

        hide();
        clearShowSetT();
    }

    function onMMove(e) {

        hide();
        refreshShowSetT();
        mx = e.clientX;
        my = e.clientY;
    }

    function refreshShowSetT() {

        clearShowSetT();
        showSetT = setTimeout(show, delay);
    }

    function clearShowSetT() {

        clearTimeout(showSetT);
    }

    function show() {

        amgui.deOverlayCont.appendChild(de);
        amgui.placeToPoint(de, mx, my, opt.side);
    }

    function hide() {

        if (de.parentElement) {
            de.parentElement.removeChild(de);
        }
    }
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.utils.js":[function(require,module,exports){
'use strict';

var amgui;

module.exports = function (_amgui) {

    amgui = _amgui;

    return {
        placeToPoint: placeToPoint,
        callOnAdded: callOnAdded,
    };
};


function placeToPoint(de, mx, my, way) {

    amgui.callOnAdded(de, function () {

        var px = 0, py = 0,
            br = de.getBoundingClientRect(),
            w = br.width,
            h = br.height,
            ww = window.innerWidth,
            wh = window.innerHeight;

        way = way || 'left';

        switch (way) {

            case 'top':
                px = mx - (w / 2);
                py = my - h;
                break;

            case 'right':
                px = mx;
                py = my - (h / 2);
                break;

            case 'bottom':
                px = mx - (w / 2);
                py = my;
                break;

            default:
            case 'left':
                px = mx - w;
                py = my - (h / 2);
        }

        if (py < 0) py = 0;
        if (px + w > ww) px -= (px + w) - ww;
        if (py + h > wh) py -= (py + h) - wh;
        if (px < 0) px = 0;

        de.style.left = px + 'px';
        de.style.top = py + 'px';
    });
}

function callOnAdded(de, cb, thisArg) {

    var setI = setInterval(function () {

        if (check(de)) {

            clearInterval(setI);

            cb.call(thisArg);
        }
        
    }, 234);
    
    function check (node) {

        while (node.parentNode) {

            node = node.parentNode;
            
            if (node.nodeType === 9 || node.nodeType === 11) {

                return true;
            }
        }
    }
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\assets\\fontello\\config.json":[function(require,module,exports){
module.exports={
  "name": "amgui",
  "css_prefix_text": "icon-",
  "css_use_suffix": false,
  "hinting": true,
  "units_per_em": 1000,
  "ascent": 850,
  "glyphs": [
    {
      "uid": "53ed8570225581269cd7eff5795e8bea",
      "css": "emo-unhappy",
      "code": 59412,
      "src": "fontelico"
    },
    {
      "uid": "68e298ff2d8b25dd7f647ed64f5ae690",
      "css": "emo-surprised",
      "code": 59432,
      "src": "fontelico"
    },
    {
      "uid": "8ce732688587909ad0a9d8323eaca8ad",
      "css": "marquee",
      "code": 59413,
      "src": "fontelico"
    },
    {
      "uid": "5211af474d3a9848f67f945e2ccaf143",
      "css": "cancel",
      "code": 59427,
      "src": "fontawesome"
    },
    {
      "uid": "44e04715aecbca7f266a17d5a7863c68",
      "css": "plus",
      "code": 59431,
      "src": "fontawesome"
    },
    {
      "uid": "1a5cfa186647e8c929c2b17b9fc4dac1",
      "css": "plus-squared",
      "code": 59398,
      "src": "fontawesome"
    },
    {
      "uid": "c5fd349cbd3d23e4ade333789c29c729",
      "css": "eye",
      "code": 59438,
      "src": "fontawesome"
    },
    {
      "uid": "7fd683b2c518ceb9e5fa6757f2276faa",
      "css": "eye-off",
      "code": 59439,
      "src": "fontawesome"
    },
    {
      "uid": "9a76bc135eac17d2c8b8ad4a5774fc87",
      "css": "download",
      "code": 59414,
      "src": "fontawesome"
    },
    {
      "uid": "f5999a012fc3752386635ec02a858447",
      "css": "download-cloud",
      "code": 115,
      "src": "fontawesome"
    },
    {
      "uid": "de2fc7a5c986ab8c622f63455d7cf814",
      "css": "upload-cloud",
      "code": 117,
      "src": "fontawesome"
    },
    {
      "uid": "7034e4d22866af82bef811f52fb1ba46",
      "css": "code",
      "code": 59417,
      "src": "fontawesome"
    },
    {
      "uid": "f48ae54adfb27d8ada53d0fd9e34ee10",
      "css": "trash",
      "code": 59396,
      "src": "fontawesome"
    },
    {
      "uid": "1b5a5d7b7e3c71437f5a26befdd045ed",
      "css": "doc",
      "code": 59405,
      "src": "fontawesome"
    },
    {
      "uid": "26613a2e6bc41593c54bead46f8c8ee3",
      "css": "file-code",
      "code": 59400,
      "src": "fontawesome"
    },
    {
      "uid": "b091a8bd0fdade174951f17d936f51e4",
      "css": "folder-empty",
      "code": 59403,
      "src": "fontawesome"
    },
    {
      "uid": "6533bdc16ab201eb3f3b27ce989cab33",
      "css": "folder-open-empty",
      "code": 59404,
      "src": "fontawesome"
    },
    {
      "uid": "559647a6f430b3aeadbecd67194451dd",
      "css": "menu",
      "code": 59440,
      "src": "fontawesome"
    },
    {
      "uid": "e99461abfef3923546da8d745372c995",
      "css": "cog",
      "code": 59393,
      "src": "fontawesome"
    },
    {
      "uid": "5bb103cd29de77e0e06a52638527b575",
      "css": "wrench",
      "code": 59415,
      "src": "fontawesome"
    },
    {
      "uid": "21b42d3c3e6be44c3cc3d73042faa216",
      "css": "sliders",
      "code": 59416,
      "src": "fontawesome"
    },
    {
      "uid": "e594fc6e5870b4ab7e49f52571d52577",
      "css": "resize-full",
      "code": 59437,
      "src": "fontawesome"
    },
    {
      "uid": "3c24ee33c9487bbf18796ca6dffa1905",
      "css": "resize-small",
      "code": 59436,
      "src": "fontawesome"
    },
    {
      "uid": "c53068fe21c8410b0a098b4c52c3d37e",
      "css": "down-circled2",
      "code": 59433,
      "src": "fontawesome"
    },
    {
      "uid": "f3f90c8c89795da30f7444634476ea4f",
      "css": "angle-left",
      "code": 59434,
      "src": "fontawesome"
    },
    {
      "uid": "7bf14281af5633a597f85b061ef1cfb9",
      "css": "angle-right",
      "code": 59394,
      "src": "fontawesome"
    },
    {
      "uid": "5de9370846a26947e03f63142a3f1c07",
      "css": "angle-up",
      "code": 59435,
      "src": "fontawesome"
    },
    {
      "uid": "e4dde1992f787163e2e2b534b8c8067d",
      "css": "angle-down",
      "code": 59395,
      "src": "fontawesome"
    },
    {
      "uid": "bc71f4c6e53394d5ba46b063040014f1",
      "css": "cw",
      "code": 59425,
      "src": "fontawesome"
    },
    {
      "uid": "f9c3205df26e7778abac86183aefdc99",
      "css": "ccw",
      "code": 59426,
      "src": "fontawesome"
    },
    {
      "uid": "d4816c0845aa43767213d45574b3b145",
      "css": "history",
      "code": 59418,
      "src": "fontawesome"
    },
    {
      "uid": "ce06b5805120d0c2f8d60cd3f1a4fdb5",
      "css": "play",
      "code": 59397,
      "src": "fontawesome"
    },
    {
      "uid": "0b28050bac9d3facf2f0226db643ece0",
      "css": "pause",
      "code": 59399,
      "src": "fontawesome"
    },
    {
      "uid": "8772331a9fec983cdb5d72902a6f9e0e",
      "css": "scissors",
      "code": 59424,
      "src": "fontawesome"
    },
    {
      "uid": "130380e481a7defc690dfb24123a1f0c",
      "css": "circle",
      "code": 59442,
      "src": "fontawesome"
    },
    {
      "uid": "422e07e5afb80258a9c4ed1706498f8a",
      "css": "circle-empty",
      "code": 59441,
      "src": "fontawesome"
    },
    {
      "uid": "266d5d9adf15a61800477a5acf9a4462",
      "css": "chart-bar",
      "code": 59419,
      "src": "fontawesome"
    },
    {
      "uid": "f4445feb55521283572ee88bc304f928",
      "css": "floppy",
      "code": 59401,
      "src": "fontawesome"
    },
    {
      "uid": "3e674995cacc2b09692c096ea7eb6165",
      "css": "megaphone",
      "code": 59430,
      "src": "fontawesome"
    },
    {
      "uid": "795efd07cd5205b589c883916a76cff0",
      "css": "hdd",
      "code": 59411,
      "src": "fontawesome"
    },
    {
      "uid": "fa10777b2d88cc64cd6e4f26ef0e5264",
      "css": "terminal",
      "code": 59429,
      "src": "fontawesome"
    },
    {
      "uid": "c92ad3028acce9d51bae0ac82f5de8a2",
      "css": "bullseye",
      "code": 59408,
      "src": "fontawesome"
    },
    {
      "uid": "55605ca79a65def1a9c300037ff1d0d5",
      "css": "paw",
      "code": 59420,
      "src": "fontawesome"
    },
    {
      "uid": "fbede3c5584282a0e9b131926dff71da",
      "css": "cube",
      "code": 59428,
      "src": "fontawesome"
    },
    {
      "uid": "c53415fbd2695033bd7180d7a9ed4934",
      "css": "rebel",
      "code": 59421,
      "src": "fontawesome"
    },
    {
      "uid": "6632ce1019f9115842335622cb55f4e7",
      "css": "empire",
      "code": 59422,
      "src": "fontawesome"
    },
    {
      "uid": "9e34a047fee949eae9b6e613d790d6cf",
      "css": "dropbox",
      "code": 59409,
      "src": "fontawesome"
    },
    {
      "uid": "e7cb72a17f3b21e3576f35c3f0a7639b",
      "css": "git",
      "code": 59406,
      "src": "fontawesome"
    },
    {
      "uid": "2c2ca8a96b31781c9c8056d05c0a8980",
      "css": "blank",
      "code": 59407,
      "src": "fontawesome"
    },
    {
      "uid": "9c7fd7637a41b59a358cb70893f945a5",
      "css": "rocket",
      "code": 59423,
      "src": "entypo"
    },
    {
      "uid": "e536c80e011366046360f5ffe669dbfd",
      "css": "folder-add",
      "code": 59402,
      "src": "typicons"
    },
    {
      "uid": "366510ecfb08cd0110134b1ea907fb81",
      "css": "evernote",
      "code": 59410,
      "src": "zocial"
    },
    {
      "uid": "272e08e0e16226aadf94dcbf33aab2b2",
      "css": "key",
      "code": 59392,
      "src": "elusive"
    }
  ]
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\chronicler\\Chronicler.js":[function(require,module,exports){
'use strict';

function Chronicler() {

    this._stack = [], 
    this._pointer = -1;
    this._chains = [];
    this._flagCounter = 0;
}

var p = Chronicler.prototype;

p.undo = function () {

    if (this._pointer > -1) {

        call(this._stack[this._pointer--].undo);
    }
};

p.redo = function () {

    if (this._pointer < this._stack.length - 1) {

        call(this._stack[++this._pointer].redo);
    }
};

p.undo = function() {

    if (this._pointer < 0) {

        return false;
    }

    var rec = this._stack[this._pointer--];

    if (typeof(rec) === 'number') {

        var startFlagIdx = this._stack.indexOf(rec - 1);

        if (startFlagIdx !== -1) {

            while (this._pointer !== startFlagIdx) {

                call(this._stack[this._pointer--].undo);
            }

            this._pointer--;
        }
    }
    else {
        call(rec.undo);
    }
};

p.redo = function() {

    if (this._pointer >= this._stack.length - 1) {

        return false;
    }

    var rec = this._stack[++this._pointer];
    
    if (typeof(rec) === 'number') {

        var endFlagIdx = this._stack.indexOf(rec + 1);

        if (endFlagIdx !== -1) {

            while (++this._pointer !== endFlagIdx) {

                call(this._stack[this._pointer].redo);
            }
        }
    }
    else {
        call(rec.redo);
    }
};

function call(reg) {

    if (typeof reg === 'function') {

        reg();
    }
    else {
        reg[0].apply(reg[1], reg.slice(2));
    }
}

p.save = function (undo, redo) {

    var reg = {undo: undo, redo: redo};

    this._saveReg(reg);

    return reg;
};


p._saveReg = function (reg) {

    this._stack.splice(++this._pointer, this._stack.length, reg);
};








p.startFlag = function () {

    this._saveReg(this._flagCounter++);
    return this._flagCounter++;
};

p.endFlag = function (flag) {

    this._saveReg(flag);
};

p.wrap = function (fn, ctx) {

    return function () {

        var endFlag = this.startFlag();

        fn.apply(ctx, Array.prototype.slice.call(arguments,  2));

        this.endFlag(endFlag);
    }.bind(this);
};








p.saveChain = function (id, undo, redo, delay) {

    var chain = this.getChain(id);

    if (chain) {
        
        chain.reg.redo = redo;
    }
    else {

        chain = {
            id: id,
            reg: this.save(undo, redo)
        };
        this._chains.push(chain);
    }

    if (delay === undefined) {
        delay = 312;
    }

    clearTimeout(chain.tid);
    chain.tid = setTimeout(this.closeChain.bind(this, id), delay);
};

p.closeChain = function (id) {

    var chain = this.getChain(id);

    if (!chain) {
        return;
    }

    clearTimeout(chain.tid);
    this._chains.splice(this._chains.indexOf(chain), 1);
};

p.clear = function () {

    while (this._chains.length) {
        this.closeChain(this._chains[0].id);
    }
    
    this._stack.length = 0, 
    this._pointer = -1;
};

p.getChain = function (id) {

    return this._chains.find(function (chain) {

        return chain.id === id;
    });
};

module.exports = Chronicler;
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\commonDialogs\\dialogFeatureDoesntExits.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../amgui');

function DialogFeatureDoesntExits () {

    EventEmitter.call(this);

    this._name = '';
    this._selectors = [];

    this._onClickOk = this._onClickOk.bind(this); 
}

inherits(DialogFeatureDoesntExits, EventEmitter);
var p = DialogFeatureDoesntExits.prototype;

p.show = function (opt) {

    opt = opt || {};

    this._createDialog();

    this.domElem.showModal();
};

p.hide = function () {

    this.domElem.close();
};

p._createDialog = function () {

    if (this._isDialogCreated) return;
    this._isDialogCreated = true;

    this._createContent();
    
    this.domElem = amgui.createDialog({
        titleIcon: 'emo-unhappy',
        title: 'Sorry',
        content: this._deContent,
        parent: am.deDialogCont,
        buttons: ['ok'],
    });

    this.domElem.addEventListener('click_ok', this._onClickOk);
};

p._onClickOk = function () {

    this.hide();
};


p._createContent = function () {

    this._deContent = document.createElement('div');
    this._deContent.style.width = '330px';
    this._deContent.style.padding = '30px 12px';

    amgui.createLabel({
        caption: 'This feature doesn\'t exits yet. (But it\'s on the way!)',
        fontSize: '18px',
        display: 'block',
        parent: this._deContent
    });
};

module.exports = new DialogFeatureDoesntExits();

},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\commonDialogs\\dialogFeedback.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../amgui');

function DialogFeedback () {

    EventEmitter.call(this);

    this._name = '';
    this._selectors = [];

    this._onClickOk = this._onClickOk.bind(this); 
}

inherits(DialogFeedback, EventEmitter);
var p = DialogFeedback.prototype;

p.show = function (opt) {

    opt = opt || {};

    this._createDialog();

    this.domElem.showModal();
};

p.hide = function () {

    this.domElem.close();
};

p._createDialog = function () {

    if (this._isDialogCreated) return;
    this._isDialogCreated = true;

    this._createContent();
    
    this.domElem = amgui.createDialog({
        title: 'Feedback',
        content: this._deContent,
        parent: am.deDialogCont,
        buttons: ['ok'],
    });

    this.domElem.addEventListener('click_ok', this._onClickOk);
};

p._onClickOk = function () {

    this.hide();
};


p._createContent = function () {

    this._deContent = document.createElement('div');
    this._deContent.style.width = '450px';
    this._deContent.style.padding = '30px 12px';

    amgui.createLabel({
        caption: 'Hi! This program is in alpha state, so most of the things will change and most of the bugs are known. But if you have any question, feedback, feature request, bug report or just feel the need for contact, you can use the azazdeaz@gmail.com or the <a style="color:white;" href="https://github.com/animachine/animachine/issues">github issues</a>.',
        fontSize: '18px',
        display: 'block',
        parent: this._deContent
    });
};

module.exports = new DialogFeedback();

},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\dom-picker\\DomPicker.js":[function(require,module,exports){
"use strict";

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../amgui');

function DomPicker() {

    EventEmitter.call(this);

    this._isMouseOver = false;
    this._crumbs = [];

    this._onMMove = this._onMMove.bind(this);
    this._render = this._render.bind(this);
    window.addEventListener('mousemove', this._onMMove);

    this._createBase();
}

inherits(DomPicker, EventEmitter);
var p = DomPicker.prototype;

module.exports = DomPicker;

p.focusElem = function (target) {

    var oldTarget = this._deTarget,
        crumbs = this._crumbs,
        lastCrumb = crumbs[crumbs.length-1];

    if (oldTarget && oldTarget.parentElement === target) {

        crumbs.push(oldTarget);
    }
    else if (target === lastCrumb) {
        
        crumbs.pop();
    }
    else if (target.parentElement === lastCrumb) {

        crumbs.length = 0;
    }

    this._deTarget = target;


    var p = am.isPickableDomElem,
        top = p(target.parentElement),
        right = p(target.nextElementSibling),
        bottom = p(target.firstElementChild),
        left = p(target.previousElementSibling);

    this._btnTop.style.display = top ? 'block' : 'none';
    this._btnRight.style.display = right ? 'block' : 'none';
    this._btnBottom.style.display = bottom ? 'block' : 'none';
    this._btnLeft.style.display = left ? 'block' : 'none';

    this.domElem.style.display = 'block';

    this._render();

    this._rerenderSetI = setInterval(this._render, 123);
    window.addEventListener('resize', this._render);

    this.emit('pick', target);
};

p.hide = function () {

    clearInterval(this._rerenderSetI);
    window.removeEventListener('resize', this._render);

    this.domElem.style.display = 'none';
};

p._render = function () {

    var br = this._deTarget.getBoundingClientRect();

    this.domElem.style.left = br.left + 'px';
    this.domElem.style.top = br.top + 'px';
    this.domElem.style.width = br.width + 'px';
    this.domElem.style.height = br.height + 'px';
};

p._onMMove =  function (e) {

    var br = this.domElem.getBoundingClientRect(),
        mx = e.clientX,
        my = e.clientY,
        s = this._isMouseOver ? 21 : 0,
        over = mx >= br.left-s && mx <= br.right+s &&
            my >= br.top-s && my <= br.bottom+s;

    if (over !== this._isMouseOver) {

        this._isMouseOver = over;

        var v = over ? 'visible' : 'hidden';

        this._btnTop.style.visibility = v;
        this._btnRight.style.visibility = v;
        this._btnBottom.style.visibility = v;
        this._btnLeft.style.visibility = v;
        this._btnClose.style.visibility = v;
    }
};

p._createBase = function () {

    var btnSize = 21;

    var de = document.createElement('div');
    de.style.position = 'fixed';
    de.style.boxSizing = 'border-box';
    de.style.boxShadow = '0px 0px 1px 0px rgba(50, 50, 50, 0.75)';
    de.style.display = 'none';
    de.style.pointerEvents = 'none';
    de.style.border = '2px dashed #eee';
    de.style.pointerEvents = 'none';
    am.deHandlerCont.appendChild(de);

    de.addEventListener('mouseenter', this._onMEnter);
    de.addEventListener('mouseleave', this._onMLeave);
    
    this.domElem = de;

    this._btnTop = createBtn('angle-up', 'up one level', function () {

        this.focusElem(this._deTarget.parentElement);
    }.bind(this));
    this._btnTop.style.top = -btnSize + 'px';
    this._btnTop.style.left = '0';
    this._btnTop.style.right = '0';
    this._btnTop.style.margin = '0 auto';


    this._btnRight = createBtn('angle-right', 'next sibling', function () {

        this.focusElem(this._deTarget.nextElementSibling);
    }.bind(this));
    this._btnRight.style.right = -btnSize + 'px';
    this._btnRight.style.top = '0';
    this._btnRight.style.bottom = '0';
    this._btnRight.style.margin = 'auto 0';

    this._btnBottom = createBtn('angle-down', 'down one level', function () {

        this.focusElem(this._crumbs[this._crumbs.length-1] || this._deTarget.firstElementChild);

    }.bind(this));
    this._btnBottom.style.bottom = -btnSize + 'px';
    this._btnBottom.style.left = '0';
    this._btnBottom.style.right = '0';
    this._btnBottom.style.margin = '0 auto';

    this._btnLeft = createBtn('angle-left', 'previous sibling', function () { 

        this.focusElem(this._deTarget.previousElementSibling);
    }.bind(this));
    this._btnLeft.style.left = -btnSize + 'px';
    this._btnLeft.style.top = '0';
    this._btnLeft.style.bottom = '0';
    this._btnLeft.style.margin = 'auto 0';

    this._btnClose = createBtn('cancel', 'close', function () {

        this.hide();
    }.bind(this));
    this._btnClose.style.right = -btnSize + 'px';
    this._btnClose.style.top = -btnSize + 'px';

    function createBtn(icon, tooltip, onClick) {

        var deIcon = amgui.createIconBtn({
            icon: icon,
            widht: btnSize,
            height: btnSize,
            onClick: function (e) {
                e.stopPropagation();
                onClick();
            },
            parent: de
        });

        amgui.addTooltip({
            deTarget: deIcon,
            text: tooltip
        });

        deIcon.style.position = 'absolute';
        deIcon.style.pointerEvents = 'auto';

        return deIcon;
    }
};
},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\CssParameter.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var uncalc = require('./uncalc');
var Key = require('./Key');
var amgui = require('../../amgui');

function CssParameter (opt) {

    EventEmitter.call(this);

    this._keys = [];
    this._lineH =  21;

    this.deOptions = this._createParameterOptions();
    this.deKeyline = amgui.createKeyline({
        timescale: am.timeline.timescale
    });

    this._onChangeInput = this._onChangeInput.bind(this);
    this._onChangeTime = this._onChangeTime.bind(this);
    this._onChangeKeyTime = this._onChangeKeyTime.bind(this);
    this._onToggleKey = this._onToggleKey.bind(this);
    this._onDeleteKey = this._onDeleteKey.bind(this);

    if (!this._noBaseKeyValueInput) {

        this._input = amgui.createKeyValueInput({
            parent: this.deOptions,
            onChange: this._onChangeInput,
            height: this._lineH
        });
        this._input.style.flex = 1;
    }

    this._btnToggleKey = amgui.createIconBtn({
        icon: 'key',
        height: 21,
        parent: this.deOptions,
        onClick: this._onToggleKey,
    });
    this._refreshBtnToggleKey();

    am.timeline.on('changeTime', this._onChangeTime);

    if (opt) {
        this.useSave(opt);
    }
}

inherits(CssParameter, EventEmitter);
var p = CssParameter.prototype;









Object.defineProperty(p, 'height', {

    get: function () {
        
        return this._lineH;
    }
});





p.getSave = function () {

    var save = {
        name: this.name,
        keys: [],
    };

    this._keys.forEach(function (key) {

        save.keys.push(key.getSave());
    });

    return save;
};

p.useSave = function(save) {

    this.name = save.name;

    if (save.keys) {

        save.keys.forEach(this.addKey, this);
    }
};

p.getScriptKeys = function () {

    var keys = [];

    this._keys.forEach(function (key) {

        var k = {
            offset: key.time / am.timeline.length,
        };

        k[this.name] = this.getValue(key.time);
        
        if (key.ease && key.ease !== 'linear') {

           k.easing = key.ease; 
        }

        keys.push(k);
    }, this);

    keys.sort(function (a, b) {

        return a.offset - b.offset;
    });

    return keys;
};

p.getValue = function (time) {

    if (!_.isNumber(time)) {
        time = am.timeline.currTime;
    }

    var before, after, same;

    this._keys.forEach(function (key) {

        if (key.time === time) {
        
            same = key;
        }

        if (key.time < time && (!before || before.time < key.time)) {
        
            before = key;
        }

        if (key.time > time && (!after || after.time > key.time)) {
        
            after = key;
        }
    });

    if (same) {

        return same.value;
    }
    else {

        if (after && before) {

            var p = (time - before.time) / (after.time - before.time), 
                av = uncalc(after.value), bv = uncalc(before.value);

            p = this._applyEase(before.ease, p);

            return createCalc(av, bv, p);
        }
        else if (before) {
            
            return before.value;
        }
        else if (after) {
            
            return after.value;
        }
    }

    function createCalc(av, bv, p) {

        var avs = _.compact(av.split(' ')),
            bvs = _.compact(bv.split(' ')),
            avl = avs.length,
            bvl = bvs.length,
            ret = [];

        if (avl !== bvl) {

            if (avl < bvl) {

                avs = avs.concat(bvs.slice(avl));
            }
            else {
                bvs = bvs.concat(avs.slice(bvl));
            }         
        }

        avs.forEach(function (a, idx) {

            ret.push(calc(a, bvs[idx]));
        });

        return ret.join(' ');

        function calc(a, b) {

            return 'calc(' + b + ' + (' + a + ' - ' + b + ')*' + p + ')';
        }
    }
};

p.addKey = function (opt, skipHistory) {
    
    var key = this.getKey(opt.time);

    if (key) {

        if ('value' in opt) {

            if (!skipHistory) {
                am.history.saveChain(key, [this.addKey, this, key, true], [this.addKey, this, opt, true]);
            }

            key.value = opt.value;
        }
    }
    else {

        key = new Key(_.extend({deKeyline: this.deKeyline}, opt));
        key.value = opt.value || this.getValue(opt.time);

        key.on('changeTime', this._onChangeKeyTime);
        key.on('delete', this._onDeleteKey);

        this._keys.push(key);

        if (!skipHistory) {
            am.history.closeChain(key);
            am.history.save([this.removeKey, this, opt.time, true], [this.addKey, this, opt, true]);
        }
    }

    this._refreshInput();
    this._refreshBtnToggleKey();

    this.emit('change');

    return key;
};

p.removeKey = function (key, skipHistory) {

    if (typeof(key) === 'number') {

        key = this.getKey(key);
    }

    var idx = this._keys.indexOf(key);

    if (idx === -1) {

        return;
    }

    if (!skipHistory) {
        am.history.save([this.addKey, this, key, true],
            [this.removeKey, this, key, true]);
    }

    this._keys.splice(idx, 1);

    key.dispose();

    key.removeListener('changeTime', this._onChangeKeyTime);
    key.removeListener('delete', this._onDeleteKey);

    this._refreshBtnToggleKey();

    this.emit('change');
};

p.getKey = function (time) {

    return this._keys.find(function(key) {

        return key.time === time;
    });
};

p.getPrevKey = function (time) {

    var retKey;
    
    this._keys.forEach(function(key) {

        if (key.time < time && (!retKey || retKey.time < key.time)) {

            retKey = key;
        }
    });

    return retKey;
};

p.getNextKey = function (time) {

    var retKey;
    
    this._keys.forEach(function(key) {

        if (key.time > time && (!retKey || retKey.time > key.time)) {

            retKey = key;
        }
    });

    return retKey;
};

p.getKeyTimes = function () {

    var times = [];

    this._keys.forEach(function (key) {

        times.push(key.time);
    });

    return times;
};

p.isValid = function () {

    return !!(this.name && this._keys.length);
};









p._applyEase = function (ease, value) {

    var rx = /cubic-bezier\(\s*([\d\.]+)\s*,\s*([\d\.-]+)\s*,\s*([\d\.]+)\s*,\s*([\d\.-]+)\s*\)/,
        m = rx.exec(ease);

    if (!m) {
        return value;
    }
    
    var p = [0, 0, parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), 1, 1];

    count(0);
    count(2);
    count(4);
    count(0);
    count(2);
    count(0);

    return p[1];


    function count(i) {

        p[i+0] = p[i+0] + (p[i+2] - p[i+0]) * value;
        p[i+1] = p[i+1] + (p[i+3] - p[i+1]) * value;
    }
};








p._onChangeInput = function (e) {

    if ('key' in e.detail) {
        this.name = e.detail.key;
    }

    if ('value' in e.detail) {
        this.addKey({
            time: am.timeline.currTime,
            value: e.detail.value
        });
    }

    this.emit('change');
};

p._onChangeKeyTime = function () {

    this.emit('change');
};

p._onDeleteKey = function (key) {

    this.removeKey(key);
};

p._onChangeTime = function () {

    this._refreshInput();
    this._refreshBtnToggleKey();
};

p._onToggleKey = function () {

    var key = this.getKey(am.timeline.currTime);

    if (key) {
        this.removeKey(key);
    }
    else {
        this.addKey({time: am.timeline.currTime});
    }
};









p._refreshInput = function () {

    this._input.setKey(this.name);
    this._input.setValue(this.getValue());
};

p._refreshBtnToggleKey = function () {

    var key = this.getKey(am.timeline.currTime);
    this._btnToggleKey.style.color = key ? amgui.color.text : amgui.color.textInactive;
};












p._createParameterOptions = function () {

    var de = document.createElement('div');
    de.style.display = 'flex';
    de.style.width = '100%';
    de.style.height = this._lineH + 'px';
    de.style.background = 'linear-gradient(to bottom, #184F12 18%,#1B4417 96%)';

    amgui.bindDropdown({
        asContextMenu: true,
        deTarget: de,
        deMenu: amgui.createDropdown({
            options: [
                {text: 'move up', onSelect: this.emit.bind(this, 'move', this, -1)},
                {text: 'move down', onSelect: this.emit.bind(this, 'move', this, 1)},
                {text: 'delete', onSelect: this.emit.bind(this, 'delete', this)},
            ]
        })
    });

    return de;
};

p.dispose = function () {

    //TODO
};

module.exports = CssParameter;

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./Key":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\Key.js","./uncalc":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\uncalc.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\CssSequence.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../../amgui');
var CssParameter = require('./CssParameter');
var CssTransformParameter = require('./CssTransformParameter');
var Key = require('./Key');
var Transhand = require('../../transhand/Transhand');
var mstPlayer = require('./script.player.mst');
var dialogSequOptions = require('./dialogSequOptions');

function CssSequence(opt) {

    EventEmitter.call(this);

    this._selectors = [];
    this._parameters = [];
    this._fill = 'forward';
    this._name = 'unnamed';
    this._iterations = 1;

    this._baseH = 21;
    this._selectedElems = [];
    this._headKeys = [];
    this._isShowingParams = false;
    this._isHidingSelectedElems = false;
    this._isPlaying = false;

    this._onSelectClick = this._onSelectClick.bind(this);
    this._onChangeHandler = this._onChangeHandler.bind(this);
    this._onChangeTime = this._onChangeTime.bind(this);
    this._onChangeParameter = this._onChangeParameter.bind(this);
    this._onDeleteParameter = this._onDeleteParameter.bind(this);
    this._onMoveParameter = this._onMoveParameter.bind(this);
    this._onChangeBlankParameter = this._onChangeBlankParameter.bind(this);
    this._onClickTgglKey = this._onClickTgglKey.bind(this);
    this._onClickTgglHide = this._onClickTgglHide.bind(this);
    this._onClickTgglShowParams = this._onClickTgglShowParams.bind(this);
    this._onClickName = this._onClickName.bind(this);
    this._onChangeName = this._onChangeName.bind(this);
    this._onChangeName = this._onChangeName.bind(this);
    this._onChangeFill = this._onChangeFill.bind(this);
    this._onChangeIterations = this._onChangeIterations.bind(this);
    this._onChangeSelectors = this._onChangeSelectors.bind(this);
    this._onWindowResize = this._onWindowResize.bind(this);
    this._animPlay = this._animPlay.bind(this);

    this.deOptions = document.createElement('div');
    this.deKeys = document.createElement('div');

    this._deHeadOptinos = this._createHeadOptions();
    this._deHeadKeyline = amgui.createKeyline({});
    this.deKeys.appendChild(this._deHeadKeyline);

    am.timeline.on('changeTime', this._onChangeTime);
    this.deOptions.addEventListener('click', this._onSelectClick);
    this.deKeys.addEventListener('click', this._onSelectClick);

    this._onChangeBlankParameter();

    if (opt) {
        this.useSave(opt);
    }
}

inherits(CssSequence, EventEmitter);
var p = CssSequence.prototype;

p.type = 'css_sequ_type';






Object.defineProperties(p, {

    height: {

        get: function () {

            var ret = this._baseH;

            if (this._isShowingParams) {

                this._parameters.forEach(function (param) {

                    ret += param.height;
                });
            }

            return ret;
        }
    },

    name: {
        set: function (v) {

            if (v === this._name) return;

            this._name = v;
            this._deName.textContent = this._name;
        },
        get: function () {

            return this._name;
        }
    },

    fill: {
        set: function (v) {

            if (v === this._fill) return;

            this._fill = v;
        },
        get: function () {

            return this._fill;
        }
    },

    iterations: {
        set: function (v) {

            if (v === this._iterations) return;

            this._iterations = v;
        },
        get: function () {

            return this._iterations;
        }
    }
});






p.getSave = function () {

    var save = {
        name: this.name,
        fill: this.fill,
        iterations: this.iterations,
        selectors: _.clone(this._selectors),
        parameters: [],
        isShowingParams: this._isShowingParams,
    };

    this._parameters.forEach(function (param) {

        save.parameters.push(param.getSave());
    });

    return save;
};

p.useSave = function (save) {

    if (!save) {
        return;
    }

    this._selectors = save.selectors || [];

    if ('name' in save) this.name = save.name;
    if ('fill' in save) this.fill = save.fill;
    if ('iterations' in save) this.iterations = save.iterations;

    if (save.parameters) {

        save.parameters.forEach(this.addParameter, this);
    }

    this._selectElements();
    this._refreshHeadKeyline();
    this._refreshTgglKey();

    if (save.isShowingParams) {

        this._showParams();
    }
};

p.getScript = function () {

    var paramKeys = [], code = '', options, selectors;

    this._parameters.forEach(function (param) {

        paramKeys.push(param.getScriptKeys());
    });

    options = {
      direction: "normal",
      duration: am.timeline.length,
      iterations: this.iterations,
      fill: this.fill,
    };

    selectors = this._selectors.join(',').replace('\\','\\\\');

    code = Mustache.render(mstPlayer, {
        paramKeys: JSON.stringify(paramKeys),
        options: JSON.stringify(options),
        selectors: selectors
    });

    return code;
};

p.addParameter = function (opt, skipHistory) {

    opt = opt || {};

    var param = this._getParameter(opt.name);
    

    if (param) {

        return param;
    }
    else {

        if (opt.name === 'transform') {

            param = new CssTransformParameter(opt);
        }
        else {

            param = new CssParameter(opt);
        }

        if (!skipHistory) {
            am.history.save([this.removeParameter, this, param, true],
                [this.addParameter, this, param, true]);
        }

        this._parameters.push(param);
        param.on('change', this._onChangeParameter);
        param.on('delete', this._onDeleteParameter);
        param.on('move', this._onMoveParameter);

        this._refreshParameterOrdering();
        this._moveBlankParameterDown();
        this.emit('changeHeight', this);

        return param;
    }
};

p.removeParameter = function (param, skipHistory) {

    if (!skipHistory) {
        am.history.save([this.addParameter, this, param, true],
            [this.removeParameter, this, param, true]);
    }

    var idx = this._parameters.indexOf(param);

    if (idx === -1) {
        return;
    }

    this._parameters.splice(idx, 1);

    param.removeListener('change', this._onChangeParameter);
    param.removeListener('delete', this._onDeleteParameter);
    param.removeListener('move', this._onMoveParameter);

    $(param.deOptions).remove();
    $(param.deKeyline).remove();
};

p.moveParameter = function (param, way) {

    var idx = this._parameters.indexOf(param);

    this._parameters.splice(idx, 1);
    idx = Math.min(this._parameters.length, Math.max(0, idx + way));
    this._parameters.splice(idx, 0, param);

    this._refreshParameterOrdering();
};

p.select = function (opt) {

    opt = opt || {};

    if (this._isSelected) return;
    this._isSelected = true;


    if (!this._handler) {
        this._handler = new Transhand();
    }

    this._handler.on('change', this._onChangeHandler);
    window.addEventListener('resize', this._onWindowResize);

    this._selectElements();

    if (this._selectedElems.length) {

        this._focusHandler(opt.focusElem || this._selectedElems[0]);
    }

    this.deHighlight.style.opacity = 1;

    this.emit('select', this);
};

p.deselect = function () {

    if (!this._isSelected) return;
    this._isSelected = false;

    this._blurHandler();

    this.deHighlight.style.opacity = 0;

    window.removeEventListener('resize', this._onWindowResize);

    if (this._handler) {

        this._handler.removeListener('change', this._onChangeHandler);
    }
};

p.renderTime = function (time) {

    if (this._selectors.length === 0) {
        return;
    }

    var selection = _.toArray(am.deRoot.querySelectorAll(this._selectors.join(',')));

    this._parameters.forEach(function (param) {

        selection.forEach(function (de) {

            de.style[param.name] = param.getValue(time);
        });
    });
};

p._onPick = function (de) {

    var items = am.deRoot.querySelectorAll(this.selectors.join(','));

    if (items.indexOf(de)) {

        this.select();
    }
};

p.play = function () {

    this._isPlaying = true;

    this._animPlay();
};

p.pause = function () {

    this._isPlaying = false;

    window.cancelAnimationFrame(this._animPlayRafid);
};

p.getMagnetPoints = function () {

    var times = [];

    this._headKeys.forEach(function (key) {

        times.push(key.time);
    });

    return times;
};










p._animPlay = function () {

    this._animPlayRafid = window.requestAnimationFrame(this._animPlay);

    this.renderTime(am.timeline.currTime);
};

p._focusHandler = function (de) {

    de = de || this._currHandledDe;
    this._currHandledDe = de;

    if (!this._currHandledDe) return this._blurHandler();

    var transformSave;
    if (de.style.transform) {
        transformSave = de.style.transform;
        de.style.transform = '';
    }

    var br = de.getBoundingClientRect();

    de.style.transform = transformSave;

    var handOpt = {
        type: 'transformer',
        base: {
            x: br.left,
            y: br.top,
            w: br.width,
            h: br.height,
        },
        params: {}
    };
    var transformParam = this._getParameter('transform');
    var transformOriginParam = this._getParameter('transform-origin');

    if (transformParam instanceof CssTransformParameter) {

        _.extend(handOpt.params, transformParam.getRawValue());
    }

    if (transformOriginParam) {

        var val = transformOriginParam.getValue(),
            match = /\s*([\d\.]+)%\s*([\d\.]+)%/.exec(val);

        if (match) {
            handOpt.params.ox = match[1] / 100;
            handOpt.params.oy = (match[2] || match[1]) / 100;
        }
    }

    this._handler.setup({
        hand: handOpt
    });
    this._handler.activate();

    am.deHandlerCont.appendChild(this._handler.domElem);
};

p._blurHandler = function () {

    this._currHandledDe = undefined;

    if (this._handler && this._handler.domElem && this._handler.domElem.parentNode) {

        this._handler.deactivate();
        this._handler.domElem.parentNode.removeChild(this._handler.domElem);
    }
};

p._moveBlankParameterDown = function () {

    if (!this._blankParameter) {
        return;
    }

    var idx = this._parameters.indexOf(this._blankParameter);

    if (idx < this._parameters.length - 1) {

        this.moveParameter(this._blankParameter, (this._parameters.length - 1) - idx);
    }
};

p._hideSelectedElems = function () {

    if (this._isHidingSelectedElems) return;
    this._isHidingSelectedElems = true;

    this._tgglHide.setToggle(true);

    this._selectedElems.forEach(function (de) {

        de._amVisibilitySave = de.style.visibility;
        de.style.visibility = 'hidden';
    });
};

p._showSelectedElems = function () {

    if (!this._isHidingSelectedElems) return;
    this._isHidingSelectedElems = false;

    this._tgglHide.setToggle(false);

    this._selectedElems.forEach(function (de) {

        de.style.visibility = de._amVisibilitySave;
    });
};

p._showParams = function () {

    if (this._isShowingParams) return;
    this._isShowingParams = true;

    this._tgglParams.setToggle(true);
    this.emit('changeHeight', this);
};

p._hideParams = function () {

    if (!this._isShowingParams) return;
    this._isShowingParams = false;

    this._tgglParams.setToggle(false);
    this.emit('changeHeight', this);
};








p._onSelectClick = function () {

    this.select();
};

p._onChangeHandler = function(params, type) {

    var time = am.timeline.currTime, 
        prop, value;

    if (type === 'transform') {

        Object.keys(params).forEach(function (name) {

            if (name === 'tx' || name === 'ty' || name === 'tz' ||
                name === 'rx' || name === 'ry' || name === 'rz' ||
                name === 'sx' || name === 'sy' || name === 'sz')
            {
                value = {};
                value[name] = params[name];

                prop = this.addParameter({name: 'transform'});
                prop.addKey({
                    time: time,
                    value: value
                });
            }
        }, this);

        if ('ox' in params && 'oy' in params) {

            prop = this.addParameter({name: 'transform-origin'});
            prop.addKey({
                time: time,
                value: (params.ox*100).toFixed(2) + '% ' + (params.oy*100).toFixed(2) + '%'
            });
        }
    }

    this.renderTime(time);
    this._focusHandler();
};

p._onChangeTime = function (time) {

    if (this._isPlaying) {
        return;
    }

    this.renderTime(time);
    this._focusHandler();
    this._refreshTgglKey();
};

p._onChangeParameter = function () {

    this.renderTime();
    this._focusHandler();
    this._refreshHeadKeyline();
    this._refreshTgglKey();

    this.emit('change');
};


p._onWindowResize = function () {

    this._focusHandler();
};

p._onDeleteParameter = function (param) {

    this.removeParameter(param);
};

p._onMoveParameter = function (param, way) {

    this.moveParameter(param, way);
};

p._onChangeBlankParameter = function () {

    if (this._blankParameter) {

        this._blankParameter.removeListener('change', this._onChangeBlankParameter);
        this._blankParameter = undefined;
    }

    this._blankParameter = this.addParameter();
    this._blankParameter.on('change', this._onChangeBlankParameter);
};

p._onClickTgglKey = function () {

    var time = am.timeline.currTime,
        allHaveKey = this._isAllParamsHaveKey(time),
        flag = am.history.startFlag();

    this._parameters.forEach(function (param) {

        if (param.isValid()) {

            if (allHaveKey) {
                param.removeKey(param.getKey(time));
            }
            else {
                param.addKey({time: time});
            }
        }
    });

    this._refreshTgglKey();

    am.history.endFlag(flag);
};

p._onClickTgglShowParams = function () {

    if (this._isShowingParams) {
        this._hideParams();
    }
    else {
        this._showParams();
    }
};

p._onClickTgglHide = function () {

    if (this._isHidingSelectedElems) {
        this._showSelectedElems();
    }
    else {
        this._hideSelectedElems();
    }
};

p._onClickName = function () {

    dialogSequOptions.show({
        name: this._name,
        selectors: this._selectors,
        fill: this.fill,
        iterations: this.iterations,
        onChangeName: this._onChangeName,
        onChangeFill: this._onChangeFill,
        onChangeIterations: this._onChangeIterations,
        onChangeSelectors: this._onChangeSelectors
    });
};

p._onChangeName = function (name) {

    this.name = name;
};

p._onChangeFill = function (fill) {

    this.fill = fill;
};

p._onChangeIterations = function (itarations) {

    this.iterations = itarations;
};

p._onChangeSelectors = function (selectors) {

    this._selectors.length = 0;
    this._selectors = this._selectors.concat(selectors);

    this._selectElements();

    if (this._selectedElems.indexOf(this._currHandledDe) === -1) {

        this._currHandledDe = undefined;
    }

    this._focusHandler(this._currHandledDe || this._selectedElems[0]);
};











p._isAllParamsHaveKey = function (time) {

    return this._parameters.every(function (param) {

        return param.getKey(time) || !param.isValid();
    });
};

p._getParameter = function (name) {

    return this._parameters.find(function(param) {

        return param.name === name;
    });
};

p._refreshTgglKey = function () {

    this._tgglKey.setToggle( this._isAllParamsHaveKey(am.timeline.currTime));
};


p._refreshHeadKeyline = function () {

    var times = [], oldKeys = this._headKeys.splice(0);

    this._parameters.forEach(function (param) {

        times = times.concat(param.getKeyTimes());
    });

    times = _.uniq(times);

    times.forEach(function (time) {

        var key = oldKeys.pop() || new Key({
            deKeyline: this._deHeadKeyline,
            ease: 'none',
            color: '#063501'
        });

        key.domElem.style.pointerEvents = 'none';//hack! until finish the control with head keys

        key.time = time;

        this._headKeys.push(key);
    }, this);

    _.invoke(_.difference(oldKeys, this._headKeys), 'dispose');
};

p._refreshParameterOrdering = function () {

    this._parameters.forEach(function (param) {

        this.deOptions.appendChild(param.deOptions);
        this.deKeys.appendChild(param.deKeyline);
    }, this);
};











p._createHeadOptions = function (){

    var de = document.createElement('div');
    de.style.position = 'relative';
    de.style.width = '100%';
    de.style.display = 'flex';
    de.style.height = this._baseH + 'px';
    de.style.background = 'linear-gradient(to bottom, #063501 18%,#064100 96%)';
    this.deOptions.appendChild(de);

    this.deHighlight = document.createElement('div');
    this.deHighlight.style.display = 'inline-block';
    this.deHighlight.style.width = '2px';
    this.deHighlight.style.height = this._baseH + 'px';
    this.deHighlight.style.background = 'gold';
    this.deHighlight.style.opacity = 0;
    de.appendChild(this.deHighlight);

    this._tgglParams = amgui.createToggleIconBtn({
        iconOn: 'angle-down',
        iconOff: 'angle-right',
        height: this._baseH,
        onClick: this._onClickTgglShowParams,
        parent: de
    });

    this._deName = amgui.createLabel({caption: this._name, parent: de});
    this._deName.style.height = this._baseH  + 'px';
    this._deName.style.cursor = 'pointer';
    this._deName.addEventListener('click', this._onClickName);

    var deNameIcon = amgui.createIcon({
        icon: 'cog',
        parent: de
    });
    deNameIcon.style.display = 'none';
    this._deName.addEventListener('mouseenter', function () {deNameIcon.style.display = 'inline-block';});
    this._deName.addEventListener('mouseleave', function () {deNameIcon.style.display = 'none';});

    var space = document.createElement('div');
    space.style.display = 'inline-block';
    space.style.flex = '1';
    space.style.pointerEvents = 'none';
    de.appendChild(space);

    this._tgglHide = amgui.createToggleIconBtn({
        iconOn: 'eye-off', 
        iconOff: 'eye', 
        height: this._baseH,
        defaultToggle: false,
        onClick: this._onClickTgglHide,
        changeColor: true,
        parent: de
    });

    this._tgglKey = amgui.createToggleIconBtn({
        icon: 'key',
        height: this._baseH,
        onClick: this._onClickTgglKey,
        changeColor: true,
        parent: de
    });
    this._refreshTgglKey();

    amgui.bindDropdown({
        asContextMenu: true,
        deTarget: de,
        deMenu: amgui.createDropdown({
            options: [
                {text: 'move up', onSelect: this.emit.bind(this, 'move', this, -1)},
                {text: 'move down', onSelect: this.emit.bind(this, 'move', this, 1)},
                {text: 'delete', onSelect: this.emit.bind(this, 'delete', this)},
            ]
        })
    });

    return de;
};

p.isOwnedDomElem = function (de) {

    return this._selectedElems.indexOf(de) !== -1;
};

p._selectElements = function () {

    var list = [];

    this._selectors.forEach(function (selector) {

        var items = am.deRoot.querySelectorAll(selector);
        items = Array.prototype.slice.call(items);
        list = list.concat(items);
    });

    this._selectedElems = list;
};

p.dispose = function () {

    am.timeline.removeListener('changeTime', this._onChangeTime);

    //TODO
};

module.exports = CssSequence;





},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","../../transhand/Transhand":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\transhand\\Transhand.js","./CssParameter":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\CssParameter.js","./CssTransformParameter":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\CssTransformParameter.js","./Key":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\Key.js","./dialogSequOptions":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\dialogSequOptions.js","./script.player.mst":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\script.player.mst","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\CssTransformParameter.js":[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var CssParameter = require('./CssParameter');
var Key = require('./Key');
var amgui = require('../../amgui');

var BASE_VALUES = {
    tx: 0, ty: 0, tz: 0,
    rx: 0, ry: 0, rz: 0,
    sx: 1, sy: 1, sz: 1,
    skewX: 0, skewY: 0,
    perspective: 0
};

var PRECISIONS = { 
    tx: 0, ty: 0, tz: 0,
    rx: 2, ry: 2, rz: 2,
    sx: 2, sy: 2, sz: 2,
    skewX: 2, skewY: 2,
    perspective: 0
};

function CssTransformParameter (opt) {

    this._noBaseKeyValueInput = true;

    this._inputs = {};
    this._inputs3d = [];
    this._lineCount = 6;

    CssParameter.call(this, _.extend({name: 'transform'}, opt));

    this._onToggle3d = this._onToggle3d.bind(this);

    this._createTransformInputs();

    this._btnToggle3d = amgui.createIconBtn({
        icon: 'cube',
        height: 21,
        parent: this.deOptions,
        onClick: this._onToggle3d,
    });
    this.deOptions.insertBefore(this._btnToggle3d, this._btnToggleKey);
    
    this._showing3d = !this._showing3d;//TODO do this somehow else!
    this._showHide3d(!this._showing3d);
}

inherits(CssTransformParameter, CssParameter);
var p = CssTransformParameter.prototype;


p.getSave = function () {

    var save = CssParameter.prototype.getSave.call(this);

    save.showing3d = this._showing3d;

    return save;
};

p.useSave = function(save) {

    CssParameter.prototype.useSave.call(this, save);

    this._showing3d = !!save.showing3d;
};

p.getValue = function (time) {

    return convertTransformValue(this.getRawValue(time));
};

p.getRawValue = function (time) {

    if (!_.isNumber(time)) {
        time = am.timeline.currTime;
    }

    var before, after, same;

    this._keys.forEach(function (key) {

        if (key.time === time) {
        
            same = key;
        }

        if (key.time < time && (!before || before.time < key.time)) {
        
            before = key;
        }

        if (key.time > time && (!after || after.time > key.time)) {
        
            after = key;
        }
    });

    if (same) {

        return same.value;
    }
    else {

        if (after && before) {

            var calculated = {},
                p = (time - before.time) / (after.time - before.time),
                av = after.value,
                bv = before.value;

            p = this._applyEase(before.ease, p);

            Object.keys(bv).forEach(function (name) {

                if (name in av) {

                    calculated[name] = bv[name] + (av[name] - bv[name]) * p;
                }
                else {
                    calculated[name] = bv[name];
                }
            });

            return calculated;
        }
        else if (before) {
            
            return _.clone(before.value);
        }
        else if (after) {
            
            return _.clone(after.value);
        }
        else {
            return _.clone(BASE_VALUES);
        }
    }
};

p.addKey = function (opt, skipHistory) {

    var key = this.getKey(opt.time);

    if (key) {

        if ('value' in opt) {

            if (!skipHistory) {
                am.history.saveChain(key, 
                    [this.addKey, this, _.cloneDeep(key.getSave()), true], 
                    [this.addKey, this, _.cloneDeep(opt), true]);
            }
            
            key.value = _.extend(key.value, opt.value);
        }
    }
    else {
        key = new Key(_.extend({deKeyline: this.deKeyline}, opt));
        key.value = _.extend(this.getRawValue(opt.time), opt.value);

        key.on('changeTime', this._onChangeKeyTime);
        key.on('delete', this._onDeleteKey);

        this._keys.push(key);

        if (!skipHistory) {
            am.history.closeChain(key);
            am.history.save(
                [this.removeKey, this, opt.time, true], 
                [this.addKey, this, opt, true]);
        }
    }

    this._refreshInput();
    this._refreshBtnToggleKey();

    this.emit('change');

    return key;
};

p._refreshInput = function () {

    var inputs = this._inputs,
        values = this.getRawValue();

    Object.keys(inputs).forEach(function (key) {

        if (inputs[key].value !== values[key]) {

            inputs[key].value = values[key].toFixed(PRECISIONS[key]);
        }
    });
};

Object.defineProperty(p, 'height', {

    get: function () {
        
        return this._lineH * this._lineCount;
    }
});

p._onChangeInput = function (e) {

    var inp = e.currentTarget,
        value = {};

    value[inp._key] = parseFloat(inp.value);

    this.addKey({
        time: am.timeline.currTime,
        value: value,
    });
};

p._onToggle3d = function () {

    this._showHide3d(!this._showing3d);
};

p._showHide3d = function (show) {

    if (this._showHide3d === show) {
        return;
    }

    this._showing3d = show;

    this._btnToggle3d.style.color = show ? amgui.color.text : amgui.color.textInactive;

    this._inputs3d.forEach(function (de) {

        de.style.visibility = show ? $(de).show() : $(de).hide();
    });
};

p._createTransformInputs = function () {

    var deOptions = this.deOptions,
        lineH = this._lineH,
        inputs = this._inputs,
        inputs3d = this._inputs3d,
        onChangeInput = this._onChangeInput;

    deOptions.style.height = (lineH * this._lineCount) + 'px';
    deOptions.style.flexWrap = 'wrap';

    this.deKeyline.style.height = lineH + 'px';
    this.deKeyline.style.marginBottom = (lineH * (this._lineCount-1)) + 'px';

    var label = document.createElement('span');
    label.textContent = 'transform';
    label.style.flex = '1';
    label.style.height = lineH + 'px';
    $(deOptions).prepend(label);

    var row = createRow();
    createInput('tx', 'tx', row);
    createInput('ty', 'y', row);
    createInput('tz', 'z', row, true);
    row = createRow();
    createInput('rx', 'rx', row, true);
    createInput('ry', 'y', row, true);
    createInput('rz', 'rz', row);
    row = createRow();
    createInput('sx', 'sx', row);
    createInput('sy', 'y', row);
    createInput('sz', 'z', row, true);
    row = createRow();
    createInput('skewX', 'skewX', row);
    createInput('skewY', 'skewY', row);
    row = createRow(true);
    createInput('perspective', 'perspective', row);

    function createRow(i3d) {

        var de = document.createElement('div');
        de.style.display = 'flex';
        de.style.width = '100%';
        de.style.height = lineH + 'px';
        // de.style.background = 'linear-gradient(to bottom, #184F12 18%,#1B4417 96%)';
        if (i3d) {
            inputs3d.push(de);
        }
        deOptions.appendChild(de);
        return de;
    }

    function createInput(key, caption, parent, i3d) {

        var label = document.createElement('span');
        label.textContent = caption;
        parent.appendChild(label);

        var inp = document.createElement('input');
        inp._key = key;
        inp.type = 'number';
        inp.value = BASE_VALUES[key];
        inp.style.flex = '1';
        inp.style.fontFamily = amgui.FONT_FAMILY;
        inp.style.background = 'rgba(255,255,255,.12)';
        inp.style.border = 'none';
        inp.style.margin = '0 0 0 3px';
        inp.style.color = amgui.color.text;
        inp.addEventListener('change', onChangeInput);
        parent.appendChild(inp);

        if (i3d) {
            inputs3d.push(label, inp);
        }
        inputs[key] = inp;
    }
};

function convertTransformValue(v) {

    var tx = 'tx' in v && v.tx !== BASE_VALUES.tx,
        ty = 'ty' in v && v.ty !== BASE_VALUES.ty,
        tz = 'tz' in v && v.tz !== BASE_VALUES.tz,
        rx = 'rx' in v && v.rx !== BASE_VALUES.rx,
        ry = 'ry' in v && v.ry !== BASE_VALUES.ry,
        rz = 'rz' in v && v.rz !== BASE_VALUES.rz,
        sx = 'sx' in v && v.sx !== BASE_VALUES.sx,
        sy = 'sy' in v && v.sy !== BASE_VALUES.sy,
        sz = 'sz' in v && v.sz !== BASE_VALUES.sz,
        skewX = 'skeewX' in v && v.skewX !== BASE_VALUES.skewX,
        skewY = 'skeewY' in v && v.skewY !== BASE_VALUES.skewY,
        perspective = 'perspective' in v && v.perspective !== BASE_VALUES.perspective,
        ret = '';

    if (tx && ty && tz) ret += 'translate3d('+v.tx+'px,'+v.ty+'px,'+v.tz+'px) ';
    else if (tx && ty) ret += 'translate('+v.tx+'px,'+v.ty+'px) ';
    else {
        if (tx) ret += 'translateX('+v.tx+'px) ';
        if (ty) ret += 'translateY('+v.ty+'px) ';
        if (tz) ret += 'translateZ('+v.tz+'px) ';
    }

    // if (rx && ry && rz) ret += 'rotate3d('+v.rx+'rad,'+v.ry+'rad,'+v.rz+'rad) ';
    // else {
        if (rx) ret += 'rotateX('+v.rx+'rad) ';
        if (ry) ret += 'rotateY('+v.ry+'rad) ';
        if (rz) ret += 'rotate('+v.rz+'rad) ';
    // }

    if (sx && sy && sz) ret += 'scale3d('+v.sx+','+v.sy+','+v.sz+') ';
    else if (sx && sy) ret += 'scale('+v.sx+','+v.sy+') ';
    else {
        if (sx) ret += 'scaleX('+v.sx+') ';
        if (sy) ret += 'scaleY('+v.sy+') ';
        if (sz) ret += 'scaleZ('+v.sz+') ';
    }

    if (skewX && skewY) ret += 'skew('+v.skewx+'rad,'+v.skewY+'rad) ';
    else if (skewX) ret += 'skewX('+v.skewX+'rad) ';
    else if (skewY) ret += 'skewY('+v.skewY+'rad) ';

    if(perspective) ret += 'perspective('+v.perspective+'px) ';
// console.log(ret)
    return ret;
}

module.exports = CssTransformParameter;

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./CssParameter":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\CssParameter.js","./Key":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\Key.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\Key.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var dialogKeyOptions = require('./dialogKeyOptions');
var amgui = require('../../amgui');

function Key (opt) {

    EventEmitter.call(this);
    
    this._time =  0;
    this._value =  '';
    this._ease = 'linear';
    this._deKeyline = opt.deKeyline;

    this._onChangeDeTime = this._onChangeDeTime.bind(this);
    this._onSelectDropdown = this._onSelectDropdown.bind(this);
    this._onChangeEase = this._onChangeEase.bind(this);
    this._onChangeTape = this._onChangeTape.bind(this);

    this.domElem = this._deKeyline.addKey({
        timescale: am.timeline.timescale,
        time: this.time,
        ease: this.ease,
        color: opt.color
    });

    this._deMenu = amgui.createDropdown({
        options: ['ease', 'delete']
    });
    this._deMenu.addEventListener('select', this._onSelectDropdown);

    this.domElem.addEventListener('changeTime', this._onChangeDeTime);
    am.timeline.on('changeTape', this._onChangeTape);

    amgui.bindDropdown({
        deTarget: this.domElem,
        deMenu: this._deMenu,
        asContextMenu: true
    });

    if (opt) {
        this.useSave(opt);
    }
}

inherits(Key, EventEmitter);
var p = Key.prototype;

Object.defineProperties(p, {

    time: {
        set: function (v) {

            if (!Number.isFinite(v) || this._time === v) return;

            this._time = parseInt(v);

            this.domElem.setTime(this._time);
        },
        get: function () {

            return this._time;
        }
    },
    value: {
        set: function (v) {

            if (this._value === v) return;

            this._value = v;
        },
        get: function () {

            return this._value;
        }
    },
    ease: {
        set: function (v) {

            if (!v || this._ease === v) return;

            this._ease = v;

            this.domElem.setEase(v);

            this.emit('changeEase', v);
        },
        get: function () {

            return this._ease;
        }
    }
});


p.getSave = function () {

    return {
        value: this.value,
        time: this.time,
        ease: this.ease
    };
};

p.useSave = function (save) {

    this.value = save.value;
    this.time = save.time;
    this.ease = save.ease;
};

p._onChangeDeTime = function (e) {

    this.time = e.detail.time;

    this.emit('changeTime');
};

p._onSelectDropdown = function (e) {
    
    var selection = e.detail.selection;

    if (selection === 'ease') {

        dialogKeyOptions.show({
            ease: this.ease,
        });
        
        dialogKeyOptions.on('changeEase', this._onChangeEase);
    }
    else if (selection === 'delete') {

        this.emit('delete', this);
    }
};

p._onChangeEase = function (ease) {

    this.ease = ease;
};

p._onChangeTape = function () {

    this.domElem.setTimescale(am.timeline.timescale);
};

p.dispose = function () {

    this.domElem.removeEventListener('changeTime', this._onChangeDeTime);
    this._deMenu.removeEventListener('select', this._onSelectDropdown);
    am.timeline.removeListener('changeTape', this._onChangeTape);

    this.domElem.remove();
    if (this._deMenu.parentNode) this._deMenu.parentNode.removeChild(this._deMenu); 
};

module.exports = Key;

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./dialogKeyOptions":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\dialogKeyOptions.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\cssModule.js":[function(require,module,exports){
'use strict';

var CssSequence = require('./CssSequence');
var qsgen = require('../../qsgen');

var am, iconNew;

exports.init = function (_am) {

    am = _am;

    am.registerSequenceType(CssSequence, CssSequence.prototype.type);

    am.on('selectDomElement', onSelectDomElement);
};

function onSelectDomElement(de) {

    if (!am.timeline.sequences.some(testSequ)) {

        var iconOpt;

        if (iconNew) {

            iconOpt = { deIcon: iconNew };
        }
        else {
            iconOpt = {
            
                icon: 'plus-squared',
                backgound: '#063501',
                tooltip: 'new sequence with selected elem',

                onClick: function () {

                    am.toolbar.removeIcon(iconNew);
                    am.domPicker.hide();

                    var selector = qsgen(am.selectedElement);
                    console.log('selector:', selector);

                    var sequ = new CssSequence({
                        selectors: [selector],
                        name: selector
                    });

                    am.timeline.addSequence(sequ);

                    sequ.select();
                }
            };
        }

        iconNew = am.toolbar.addIcon(iconOpt);
    }

    function testSequ(sequ) {

        if (sequ instanceof CssSequence && sequ.isOwnedDomElem(de)) {

            console.log('is owned', de);
            sequ.select({focusElem: de});
            am.domPicker.hide();
            return true;
        }
    }
}
},{"../../qsgen":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\qsgen.js","./CssSequence":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\CssSequence.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\dialogKeyOptions.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../../amgui');

function DialogKeyOptions () {

    EventEmitter.call(this);

    this._onSelectEase = this._onSelectEase.bind(this);
    this._onChangeEase = this._onChangeEase.bind(this);
    this._onChangeBezier = this._onChangeBezier.bind(this);
    this._onClickOk = this._onClickOk.bind(this); 
}

inherits(DialogKeyOptions, EventEmitter);
var p = DialogKeyOptions.prototype;

Object.defineProperties(p, {

    ease: {

        set: function (v) {

            if (this._ease === v) return;
            
            this._inpEase.value = v;
            this._beizerEditor.setValue(v);

            this.emit('changeEase', v);
        },
        get: function () {

            return this._ease;
        }
    }
});


p.show = function (opt) {

    opt = opt || {};

    this._createDialog();

    this.ease = opt.ease;

    this.domElem.showModal();
};

p.hide = function () {

    this.domElem.close();

    this.removeAllListeners('changeEase');
};

p._createDialog = function () {

    if (this._isDialogCreated) return;
    this._isDialogCreated = true;

    this._createContent();
    
    this.domElem = amgui.createDialog({
        title: 'Key',
        content: this._deContent,
        parent: am.deDialogCont,
        buttons: ['ok'],
    });

    this.domElem.addEventListener('click_ok', this._onClickOk);
};

p._createContent = function () {

    this._deContent = document.createElement('div');
    this._deContent.style.width = '330px';
    this._deContent.style.padding = '30px 12px';

    this._deLabelEase = document.createElement('span');
    this._deLabelEase.textContent = 'ease: ';
    this._deContent.appendChild(this._deLabelEase);

    this._inpEase = document.createElement('input');
    this._inpEase.type = 'text';
    this._inpEase.value = 'linear';
    this._inpEase.style.width = '245px';
    this._inpEase.style.fontSize = '14px';
    this._inpEase.style.fontFamily = amgui.FONT_FAMILY;
    this._inpEase.style.background = 'none';
    this._inpEase.style.border = 'none';
    this._inpEase.style.color = amgui.color.text;
    this._inpEase.addEventListener('change', this._onChangeEase);
    this._deContent.appendChild(this._inpEase);

    this._btnSelectEase = amgui.createIconBtn({
        icon: 'chart-bar',
        display: 'inline'
    });
    this._btnSelectEase.style.marginLeft = '4px';
    this._deContent.appendChild(this._btnSelectEase);

    amgui.bindDropdown({
        deTarget: this._btnSelectEase,
        deMenu: amgui.createDropdown({
            options: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'steps(1)', 'cubic-bezier(0,0,1,1)'],
            onSelect: this._onSelectEase,
        }),
        menuParent: this._deContent
    });

    this._beizerEditor = amgui.createBezierEditor({
        // width: 330,
        // height: 330,
        parent: this._deContent,
        onChange: this._onChangeBezier
    });
};

p._onClickOk = function () {

    this.hide();
};

p._onSelectEase = function (e) {

    this.ease = e.detail.selection;
};

p._onChangeEase = function () {

    this.ease = this._inpEase.value;
};

p._onChangeBezier = function (e) {

    this.ease = e.detail.value;
};

module.exports = new DialogKeyOptions();

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\dialogSequOptions.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../../amgui');

function DialogSequOptions () {

    EventEmitter.call(this);

    this._name = '';
    this._selectors = [];

    this._onClickOk = this._onClickOk.bind(this); 
    this._onChangeName = this._onChangeName.bind(this); 
    this._onSelectFill = this._onSelectFill.bind(this); 
    this._onChangeIterations = this._onChangeIterations.bind(this); 
}

inherits(DialogSequOptions, EventEmitter);
var p = DialogSequOptions.prototype;



Object.defineProperties(p, {

    name: {
        set: function (v) {

            if (this._name === v) {
                return;
            }

            this._name = v;
            this._inpName.value = v;
            this.emit('changeName', v);
        },
        get: function () {
            return this._name;
        }
    },

    selectors: {
        set: function (v) {

            this._selectors.slice().map(this._removeSelector, this);
            v.map(this._addSelector, this);
            this.emit('changeSelectors', this.selectors);
        },
        get: function () {
            return _.pluck(this._selectors, 'value'); 
        }
    },

    fill: {
        set: function (v) {

            if (this._fill === v) {
                return;
            }

            this._fill = v;
            this._deFill.textContent = v;
            this.emit('changeFill', v);
        },
        get: function () {
            return this._fill;
        }
    },

    iterations: {
        set: function (v) {

            if (this._iterations === v) {
                return;
            }

            this._iterations = v;
            this._inpIterations.value = v;
            this.emit('changeIterations', v);
        },
        get: function () {
            return this._iterations;
        }
    },
});

p.show = function (opt) {

    opt = opt || {};

    this._createDialog();

    if ('name' in opt) this.name = opt.name;
    if ('fill' in opt) this.fill = opt.fill;
    if ('iterations' in opt) this.iterations = opt.iterations;
    if ('selectors' in opt) this.selectors = opt.selectors;

    if ('onChangeName' in opt) this.on('changeName', opt.onChangeName);
    if ('onChangeFill' in opt) this.on('changeFill', opt.onChangeFill);
    if ('onChangeIterations' in opt) this.on('changeIterations', opt.onChangeIterations);
    if ('onChangeSelectors' in opt) this.on('changeSelectors', opt.onChangeSelectors);

    this.domElem.showModal();
};

p.hide = function () {

    this.domElem.close();

    this.removeAllListeners('changeName');
    this.removeAllListeners('changeFill');
    this.removeAllListeners('changeIterations');
    this.removeAllListeners('changeSelectors');
};

p._createDialog = function () {

    if (this._isDialogCreated) return;
    this._isDialogCreated = true;

    this._createContent();
    
    this.domElem = amgui.createDialog({
        title: 'Sequence',
        content: this._deContent,
        parent: am.deDialogCont,
        buttons: ['ok'],
    });

    this.domElem.addEventListener('click_ok', this._onClickOk);
};

p._onClickOk = function () {

    this.hide();
};

p._onChangeName = function () {

    this.name = this._inpName.value;
};

p._onSelectFill = function (e) {

    this.fill = e.detail.selection;
};

p._onChangeIterations = function () {

    this.iterations = parseInt(this._inpIterations.value);
};


p._createContent = function () {

    this._deContent = document.createElement('div');
    this._deContent.style.width = '330px';
    this._deContent.style.padding = '30px 12px';

    amgui.createLabel({
        caption: 'Name: ',
        fontSize: '18px',
        // display: 'block',
        parent: this._deContent
    });

    this._inpName = document.createElement('input');
    this._inpName.type = 'text';
    this._inpName.value = this.name;
    this._inpName.style.display = 'inline-block';
    this._inpName.style.width = '245px';
    this._inpName.style.fontSize = '14px';
    this._inpName.style.fontFamily = amgui.FONT_FAMILY;
    this._inpName.style.background = 'none';
    this._inpName.style.border = 'none';
    this._inpName.style.marginBottom = '12px';
    this._inpName.style.color = amgui.color.text;
    this._inpName.addEventListener('change', this._onChangeName);
    this._deContent.appendChild(this._inpName);

    amgui.createLabel({
        caption: 'Selectors',
        fontSize: '18px',
        display: 'block',
        parent: this._deContent
    });

    this._deSelectorCont = document.createElement('div');
    this._deSelectorCont.style.width = '100%';
    this._deContent.appendChild(this._deSelectorCont);

    amgui.createIconBtn({
        icon: 'plus',
        display: 'inline-block',
        onClick: this._addSelector.bind(this, ''),
        parent: this._deContent
    });

    amgui.createIconBtn({
        icon: 'code',
        display: 'inline-block',
        onClick: function () {am.dialogs.featureDoesntExist.show();},
        parent: this._deContent,
        tooltip: 'select from options'
    });

    amgui.createLinebreak({
        parent:this._deContent
    });

    amgui.createLabel({
        caption: 'Fill mode: ',
        fontSize: '18px',
        parent: this._deContent
    });
    this._deFill = amgui.createLabel({
        parent: this._deContent
    });
    amgui.bindDropdown({
        deTarget: this._deFill,
        deMenu: amgui.createDropdown({
            options: ['none', 'forwards', 'backwards', 'both'],
            onSelect: this._onSelectFill,
        }),
        menuParent: this._deContent,
    });

    amgui.createLinebreak({
        parent: this._deContent
    });

    amgui.createLabel({
        fontSize: '18px',
        caption: 'Iterations: ',
        parent: this._deContent
    });

    this._inpIterations = document.createElement('input');
    this._inpIterations.type = 'number';
    this._inpIterations.step = 1;
    this._inpIterations.min = 0;
    this._inpIterations.max = 999999999999;
    this._inpIterations.style.fontSize = '14px';
    this._inpIterations.style.fontFamily = amgui.FONT_FAMILY;
    this._inpIterations.style.background = 'none';
    this._inpIterations.style.border = 'none';
    this._inpIterations.style.marginBottom = '12px';
    this._inpIterations.style.color = amgui.color.text;
    this._inpIterations.addEventListener('change', this._onChangeIterations);
    this._deContent.appendChild(this._inpIterations);
};

p._addSelector = function(value) {

    var selector = {
        value: value,
    };
    this._selectors.push(selector);

    var height = 23;

    selector.domElem = document.createElement('div');
    selector.domElem.style.display = 'flex';
    selector.domElem.style.height = height + 'px';
    selector.domElem.style.paddingLeft = '2px';
    selector.domElem.style.margin = '1px 0';
    selector.domElem.style.background = amgui.color.bg2;
    this._deSelectorCont.appendChild(selector.domElem);

    var inp = document.createElement('input');
    inp.type = 'text';
    inp.value = value;
    inp.placeholder = 'selector';
    inp.style.width = '245px';
    inp.style.height = height + 'px';
    inp.style.fontSize = '14px';
    inp.style.fontFamily = amgui.FONT_FAMILY;
    inp.style.flex = '1';
    inp.style.background = 'none';
    inp.style.border = 'none';
    inp.style.color = amgui.color.text;
    selector.domElem.appendChild(inp);

    inp.addEventListener('change', function () {

        selector.value = inp.value;

        this.emit('changeSelectors', this.selectors);
    }.bind(this));

    var btnDel = amgui.createIconBtn({
        icon: 'cancel',
        height: height,
        display: 'inline-block',
        onClick:this._removeSelector.bind(this, selector),
        parent: selector.domElem
    });
    btnDel.style.visibility = 'hidden';

    selector.domElem.addEventListener('mouseenter', function () {
        btnDel.style.visibility = 'visible';
    });
    selector.domElem.addEventListener('mouseleave', function () {
        btnDel.style.visibility = 'hidden';
    });
};

p._removeSelector = function (selector) {

    this._selectors.splice(this._selectors.indexOf(selector), 1);

    selector.domElem.parentNode.removeChild(selector.domElem);
};

module.exports = new DialogSequOptions();

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\script.player.mst":[function(require,module,exports){
module.exports = "function () {\n\n    var player,\n        animation,\n        isInited = false,\n        animations = [],\n        paramKeys = {{{paramKeys}}},\n        options = {{{options}}},\n        elems = document.querySelectorAll('{{{selectors}}}');\n\n    for (var i = 0; i < elems.length; ++i) {\n        for (var j = 0; j < paramKeys.length; ++j) {\n\n            animations.push(new Animation(elems[i], paramKeys[j], options));\n        }\n    }\n\n    animation = new AnimationGroup(animations);\n\n    return {\n\n        play: function () {\n\n            if (!isInited) {\n\n                player = document.timeline.play(animation);\n                isInited = true;\n            }\n            else {\n                player.play();\n            }\n        },\n        pause: function () {\n\n            if (!player) {\n                return;\n            }\n\n            player.pause();\n        },\n        seek: function (time) {\n\n            if (!player) {\n                return;\n            }\n\n            player.currentTime = time;\n        }\n    };\n}";

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\css\\uncalc.js":[function(require,module,exports){
'use strict';

var rx = /^calc\((.*?)\)$/;
    
module.exports = function uncalc (value) {

    if (typeof(value) === 'string' && value.indexOf('calc(') !== -1) {

        var m = rx.exec(value);
        return m ? '( ' + m[1] + ' )' : value;
    }
    else {

        return value;
    }
};
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\Interval.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../../amgui');

function Interval(opt) {

    EventEmitter.call(this);

    this._lineH =  21;
    this._start = 0;
    this._end = am.timeline.length;

    this._onDragResize = this._onDragResize.bind(this);
    this._onFinishResize = this._onFinishResize.bind(this);
    this._onDragMove = this._onDragMove.bind(this);
    this._onChangeTime = this._onChangeTime.bind(this);

    this._createDomElem();
    this._refreshDomElem();

    am.timeline.on('changeTime', this._onChangeTime);

    if (opt) {
        this.useSave(opt);
    }
}

inherits(Interval, EventEmitter);
var p = Interval.prototype;









Object.defineProperties(p, {

    start: {
        set: function (v) {

            v = parseInt(v);

            if (this._start === v) return;

            this._start = v;

            this._refreshDomElem();
        },
        get: function () {
            
            return this._start;
        }
    },
    end: {
        set: function (v) {

            v = parseInt(v);

            if (this._end === v) return;

            this._end = v;

            this._refreshDomElem();
        },
        get: function () {
            
            return this._end;
        }
    },
});





p.getSave = function () {

    var save = {
        start: this.start,
        end: this.end,
    };

    return save;
};

p.useSave = function(save) {

    if ('start' in save) this.start = save.start;
    if ('end' in save) this.end = save.end;
};

p.showNeighbours = function (neighbours) {

    this._neighbourIntervals = neighbours;
};










p._nextInterval = function () {

    return this.__neighbourInterval(true);
};

p._prevInterval = function () {

    return this.__neighbourInterval(false);
};

p.__neighbourInterval = function (forward) {

    var pos, neighbour;

    this._neighbourIntervals.forEach(function (interval) {

        var next = forward ? interval.start : interval.end;

        if (interval !== this && 
            (forward ? next > this.end : next < this.start) &&
            (pos === undefined || (forward === (pos > next))))
        {
            pos = next;
            neighbour = interval;
        }
    }, this);

    return neighbour;
};

p._remove = function () {

    this.emit('remove', this);
};










p._onChangeTime = function () {

    this._refreshDomElem();
};

p._onDragResize = function (md, mx) {

    var neighbour, 
        timePos = am.timeline.screenXToTime(mx);

    if (md.side === 'left') {

        neighbour = this._prevInterval();

        if (neighbour && timePos < neighbour.end) {

            timePos = neighbour.end;
        }

        this.start = timePos;
    }
    else {

        neighbour = this._nextInterval();

        if (neighbour && timePos > neighbour.start) {

            timePos = neighbour.start;
        }

        this.end = timePos;
    }
};

p._onFinishResize = function (md) {

    var neighbour;

    if (md.side === 'left') {

        neighbour = this._prevInterval();

        if (neighbour && neighbour.end === this.start) {

            neighbour.end = this.end;
            this._remove();
        }
    }
    else {

        neighbour = this._nextInterval();

        if (neighbour && neighbour.start === this.end) {

            neighbour.start = this.start;
            this._remove();
        }
    }
};

p._onDragMove = function (md, mx) {

    var timePos = am.timeline.screenXToTime(mx),
        move = timePos - md.timePos,
        nextInterval = this._nextInterval(),
        prevInterval = this._prevInterval();

    if (nextInterval && md.end + move > nextInterval.start) {

        move = nextInterval.start - md.end;
    }

    if (prevInterval && md.start + move < prevInterval.end) {

        move = prevInterval.end - md.start;
    }

    if (md.start + move < 0) {

        move = -md.start;
    }

    this.start = md.start + move;
    this.end = md.end + move;
};








p._refreshDomElem = function () {

    this.domElem.style.left = this.start * am.timeline.timescale + 'px';
    this.domElem.style.width = (this.end - this.start) * am.timeline.timescale + 'px';
};








p._createDomElem = function () {

    var de = document.createElement('div');
    de.style.width = '100%';
    de.style.height = this._lineH + 'px';
    de.style.background = 'blue';
    de.style.position = 'relative';

    createHandler.call(this, 'left');
    createHandler.call(this, 'right');

    this.domElem = de;

    amgui.makeDraggable({
        deTarget: de,
        thisArg: this,
        onDown: function (e) {
            return {
                start: this.start,
                end: this.end,
                timePos: am.timeline.screenXToTime(e.screenX)
            };
        },
        onMove: this._onDragMove,
    });

    amgui.bindDropdown({
        asContextMenu: true,
        deTarget: de,
        deMenu: amgui.createDropdown({
            options: [
                {text: 'split here'},
                {text: 'remove'}
            ]
        }),
        onSelect: function (selection) {
            
            if (selection === 'split here') {

                this._remove();
            }
            else {
                am.dialogs.featureDoesntExist.show();
            }
        }
    });

    function createHandler(side) {

        var handler = document.createElement('div');
        handler.style.position = 'absolute';
        handler.style.top = '0px';
        handler.style[side] = '0px';
        handler.style.height = '100%';
        handler.style.width = '3px';
        handler.style.cursor = 'ew-resize';
        handler.style.pointerEvents = 'auto';
        de.appendChild(handler);

        amgui.makeDraggable({
            deTarget: handler,
            onDown: function () {
                return {
                    side: side
                };
            },
            onMove: this._onDragResize,
            onUp: this._onFinishResize,
            onEnter: function () {
                handler.style.background = 'white';
            },
            onLeave: function () {
                handler.style.background = '';
            }
        });
    }
};



p.dispose = function () {

    //TODO
};

module.exports = Interval;

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\IntervalScript.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var dialogScriptEditor = require('./dialogScriptEditor');
var amgui = require('../../amgui');
var Interval = require('./Interval');

function IntervalScript(opt) {

    EventEmitter.call(this);

    this._lineH =  21;
    this._script =  '/**/';
    this._intervals = [];

    this._onClickOpenScript = this._onClickOpenScript.bind(this);
    this._onChangeScript = this._onChangeScript.bind(this);
    this._onRemoveInterval = this._onRemoveInterval.bind(this);
    this.onSelectAddInterval = this.onSelectAddInterval.bind(this);
    this._onDblclickKeyline = this._onDblclickKeyline.bind(this);

    this.deOptions = this._createParameterOptions();
    this.deKeyline = this._createBoundsLine();

    this._addInterval();

    this.deKeyline.addEventListener('dblclick', this._onDblclickKeyline);

    if (opt) {
        this.useSave(opt);
    }
}

inherits(IntervalScript, EventEmitter);
var p = IntervalScript.prototype;









Object.defineProperties(p, {

    height: {
        get: function () {
            
            return this._lineH;
        }
    },
    script: {
        set: function (v) {

            v = v || '';

            if (this._script === v) return;

            this._script = v;
        },
        get: function () {

            return this._script;
        }
    }
});





p.getSave = function () {

    var save = {
        name: this.name,
        script: JSON.stringify(this.script).slice(1, -1).replace(/'/g, '\\\''),
        intervals: [],
    };

    this._intervals.forEach(function (interval) {

        save.intervals.push(interval.getSave());
    });

    return save;
};

p.useSave = function(save) {

    if ('name' in save) this.name = save.name;
    if ('script' in save) this.script = save.script;
    if ('intervals' in save) {

        while (this._intervals.length) {

            this._removeInterval(this._intervals[0]);
        }

        save.intervals.forEach(function (intervalSave) {

            this._addInterval(intervalSave);
        }, this);
    }
};

p.isInsideBounds = function (time) {

    return this._intervals.some(function (interval) {

        if (interval.start <= time && interval.end >= time) {

            return true;
        }
    });
};

p.runScript = function () {

    (new Function(this.script))();//TODO hack!!!
};

p.editScript = function () {

    dialogScriptEditor.show({

        script: this.script,
        onChangeScript: function (script) {

            this.script = script;
        }
    });
};









p._addInterval = function (opt) {

    var interval = new Interval(opt);

    interval.showNeighbours(this._intervals);
    interval.on('remove', this._onRemoveInterval);

    this.deKeyline.appendChild(interval.domElem);
    this._intervals.push(interval);
};

p._removeInterval = function (interval) {

    var idx = this._intervals.indexOf(interval);

    if (idx === -1) {
        return;
    }

    this._intervals.splice(idx, 1);

    interval.domElem.parentNode.removeChild(interval.domElem);
    interval.removeListener('remove', this._onRemoveInterval);
    interval.dispose();
};








p._onDeleteKey = function (key) {

    this.removeKey(key);
};

p._onClickOpenScript = function () {

    dialogScriptEditor.show({
        script: this.script,
        onChangeScript: this._onChangeScript,
    });
};

p._onChangeScript = function (script) {

    this.script = script;
};

p._onRemoveInterval = function (interval) {

    this._removeInterval(interval);
};

p._onDblclickKeyline = function () {

    this.editScript();
};

p.onSelectAddInterval = function () {

    var time = am.timeline.screenXToTime(am.mouse.screenX),
        nextStart = time - 500, 
        prevEnd = time + 500;

    if (this.isInsideBounds(time)) {

        return;
    }

    this._intervals.forEach(function (interval) {

        if (interval.end < time && (!prevEnd || prevEnd < interval.end)) {

            prevEnd = interval.end;
        }

        if (interval.start > time && (!nextStart || nextStart > interval.start)) {

            nextStart = interval.start;
        }
    });

    this._addInterval({
        start: time - Math.min(500, (prevEnd - time) * 0.8, time),
        end: time + Math.min(500, (time - nextStart) * 0.8),
    });
};














p._createBoundsLine = function () {

    var de = document.createElement('div');
    de.style.width = '100%';
    de.style.height = this._lineH + 'px';
    de.style.background = 'grey';
    de.style.position = 'relative';

    amgui.bindDropdown({
        asContextMenu: true,
        deTarget: de,
        deMenu: amgui.createDropdown({
            options: [
                {text: 'add interval', onSelect: this.onSelectAddInterval}
            ]
        })
    });

    return de;
};


p._createParameterOptions = function () {

    var de = document.createElement('div');
    de.style.display = 'flex';
    de.style.width = '100%';
    de.style.height = this._lineH + 'px';
    de.style.background = 'linear-gradient(to bottom, blue 18%,darkblue 96%)';

    var space = document.createElement('div');
    space.style.display = 'inline-block';
    space.style.flex = '1';
    space.style.pointerEvents = 'none';
    de.appendChild(space);

    this._btnOpenScript = amgui.createIconBtn({
        icon: 'code',
        height: this._baseH,
        onClick: this._onClickOpenScript,
        parent: de
    });

    // this._btnEdit = amgui.createIconBtn({
    //     icon: 'wrench',
    //     height: this._baseH,
    //     parent: de
    // });

    // amgui.bindDropdown({
    //     deTarget: this._btnEdit,
    //     deMenu: amgui.createDropdown({
    //         options: [
    //             {text: 'merge'},
    //             {text: 'split'},
    //             {text: 'end here'},
    //             {text: 'start here'},
    //             {text: 'add', icon: 'plus'},
    //             {text: 'remove', icon: 'minus'},
    //         ]
    //     }),
    //     onSelect: function () {
    //         am.dialogs.featureDoesntExist.show();
    //     }
    // });

    amgui.bindDropdown({
        asContextMenu: true,
        deTarget: de,
        deMenu: amgui.createDropdown({
            options: [
                {text: 'move up', onSelect: this.emit.bind(this, 'move', this, -1)},
                {text: 'move down', onSelect: this.emit.bind(this, 'move', this, 1)},
                {text: 'delete', onSelect: this.emit.bind(this, 'delete', this)},
            ]
        })
    });

    return de;
};

p.dispose = function () {

    //TODO
};

module.exports = IntervalScript;

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./Interval":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\Interval.js","./dialogScriptEditor":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\dialogScriptEditor.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\JsSequence.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../../amgui');
var IntervalScript = require('./IntervalScript');
var MomentScript = require('./MomentScript');
var mstPlayer = require('./script.player.mst');
var dialogSequOptions = require('./dialogSequOptions');

function JsSequence(opt) {

    EventEmitter.call(this);

    this._intervalScripts = [];
    this._momentScripts = [];
    this._baseH = 21;
    this._isShowingIntervalScrips = false;
    this._isHidingSelectedElems = false;
    this._isPlaying = false;

    this._onSelectClick = this._onSelectClick.bind(this);
    this._onChangeTime = this._onChangeTime.bind(this);
    this._onChangeIntervalScript = this._onChangeIntervalScript.bind(this);
    this._onDeleteIntervalScript = this._onDeleteIntervalScript.bind(this);
    this._onMoveIntervalScript = this._onMoveIntervalScript.bind(this);
    this._onClickAddIntervalScript = this._onClickAddIntervalScript.bind(this);
    this._onClickTgglShowIntervalScripts = this._onClickTgglShowIntervalScripts.bind(this);
    this._onClickTgglMomentScript = this._onClickTgglMomentScript.bind(this);
    this._onClickEditMomentScript = this._onClickEditMomentScript.bind(this);
    this._onClickName = this._onClickName.bind(this);
    this._onChangeName = this._onChangeName.bind(this);
    this._onChangeName = this._onChangeName.bind(this);
    this._animPlay = this._animPlay.bind(this);

    this.deOptions = document.createElement('div');
    this.deKeys = document.createElement('div');

    this._deHeadOptinos = this._createHeadOptions();
    this._deHeadKeyline = amgui.createKeyline({});
    this.deKeys.appendChild(this._deHeadKeyline);

    am.timeline.on('changeTime', this._onChangeTime);
    this.deOptions.addEventListener('click', this._onSelectClick);
    this.deKeys.addEventListener('click', this._onSelectClick);

    if (opt) {
        this.useSave(opt);
    }
}

inherits(JsSequence, EventEmitter);
var p = JsSequence.prototype;

p.type = 'js_sequ_type';






Object.defineProperties(p, {

    height: {

        get: function () {

            var ret = this._baseH;

            if (this._isShowingIntervalScrips) {

                this._intervalScripts.forEach(function (intervalScript) {

                    ret += intervalScript.height;
                });
            }

            return ret;
        }
    },

    name: {
        set: function (v) {

            if (v === this._name) return;

            this._name = v || 'unnamed';
            this._deName.textContent = this._name;
        },
        get: function () {

            return this._name;
        }
    }
});






p.getSave = function () {

    var save = {
        name: this.name,
        intervalScripts: [],
        momentScripts: [],
        isShowingIntervalScripts: this._isShowingIntervalScrips,
    };

    this._intervalScripts.forEach(function (intervalScript) {

        save.intervalScripts.push(intervalScript.getSave());
    });

    this._momentScripts.forEach(function (momentScript) {

        save.momentScripts.push(momentScript.getSave());
    });

    return save;
};

p.useSave = function (save) {

    if (!save) {
        return;
    }

    this._selectors = save.selectors || [];

    if ('name' in save) this.name = save.name;

    if (save.intervalScripts) {

        save.intervalScripts.forEach(this.addIntervalScript, this);
    }

    if (save.momentScripts) {

        save.momentScripts.forEach(this.addMomentScript, this);
    }

    if (save.isShowingIntervalScripts) {

        this._showIntervalScripts();
    }
};

p.getScript = function () {//TODO

    var momentScripts = [], intervalScripts = [];

    this._intervalScripts.forEach(function (intervalScript) {

    });

    var code = Mustache.render(mstPlayer, {
        momentScripts: JSON.stringify(momentScripts),
        intervalScripts: JSON.stringify(intervalScripts)
    });

    return 'function () {/*TODO*/}';
};

p.addIntervalScript = function (opt, skipHistory) {

    opt = opt || {};

    var intervalScript = new IntervalScript(opt);

    if (!skipHistory) {
        am.history.save([this._removeIntervalScript, this, intervalScript, true],
            [this.addIntervalScript, this, opt, true]);
    }
    
    this._intervalScripts.push(intervalScript);
    intervalScript.on('change', this._onChangeIntervalScript);
    intervalScript.on('delete', this._onDeleteIntervalScript);
    intervalScript.on('move', this._onMoveIntervalScript);

    this._refreshIntervalScriptOrdering();
    this.emit('changeHeight', this);

    return intervalScript;
};

p.removeIntervalScript = function (intervalScript, skipHistory) {

    if (!skipHistory) {
        am.history.save([this.addIntervalScript, this, intervalScript, true],
            [this.removeIntervalScript, this, intervalScript, true]);
    }

    var idx = this._intervalScripts.indexOf(intervalScript);

    if (idx === -1) {
        return;
    }

    this._intervalScripts.splice(idx, 1);

    intervalScript.removeListener('change', this._onChangeIntervalScript);
    intervalScript.removeListener('delete', this._onDeleteIntervalScript);
    intervalScript.removeListener('move', this._onMoveIntervalScript);

    $(intervalScript.deOptions).remove();
    $(intervalScript.deKeyline).remove();
};

p.moveIntervalScript = function (intervalScript, way) {

    var idx = this._intervalScripts.indexOf(intervalScript);

    this._intervalScripts.splice(idx, 1);
    idx = Math.min(this._intervalScripts.length, Math.max(0, idx + way));
    this._intervalScripts.splice(idx, 0, intervalScript);

    this._refreshIntervalScriptOrdering();
};


p.addMomentScript = function (opt, skipHistory) {
    
    var ms = this.getMomentScript(opt.time);

    if (ms) {

        if ('script' in opt) {

            if (!skipHistory) {
                am.history.saveChain(ms, [this.addMomentScript, this, ms, true], [this.addMomentScript, this, opt, true]);
            }

            ms.script = opt.script;
        }
    }
    else {

        ms = new MomentScript(_.extend({deKeyline: this._deHeadKeyline}, opt));

        // ms.on('changeTime', this._onChangeKeyTime);//TODO
        // ms.on('delete', this._onDeleteKey);//TODO

        this._momentScripts.push(ms);

        if (!skipHistory) {
            am.history.closeChain(ms);
            am.history.save([this.removeMomentScript, this, opt.time, true], [this.addMomentScript, this, opt, true]);
        }
    }

    this._refreshTgglMomentScript();

    this.emit('change');

    return ms;
};

p.removeMomentScript = function (ms, skipHistory) {

    if (typeof(ms) === 'number') {

        ms = this.getMomentScript(ms);
    }

    var idx = this._momentScripts.indexOf(ms);

    if (idx === -1) {

        return;
    }

    if (!skipHistory) {
        am.history.save([this.addMomentScript, this, ms, true],
            [this.removeMomentScript, this, ms, true]);
    }

    this._momentScripts.splice(idx, 1);

    ms.dispose();

    // ms.removeListener('changeTime', this._onChangeKeyTime);//TODO
    // ms.removeListener('delete', this._onDeleteKey);//TODO

    this._refreshTgglMomentScript();

    this.emit('change');
};

p.getMomentScript = function (time) {

    return this._momentScripts.find(function(ms) {

        return ms.time === time;
    });
};


p.select = function (opt) {

    opt = opt || {};

    if (this._isSelected) return;
    this._isSelected = true;

    this.deHighlight.style.opacity = 1;

    this.emit('select', this);
};

p.deselect = function () {

    if (!this._isSelected) return;
    this._isSelected = false;

    this.deHighlight.style.opacity = 0;
};

p.renderTime = function (time) {

    //TODO
};

p.play = function () {

    this._isPlaying = true;

    this._animPlay();
};

p.pause = function () {

    this._isPlaying = false;

    window.cancelAnimationFrame(this._animPlayRafid);
};

p.getMagnetPoints = function () {

    var times = [];

    this._momentScripts.forEach(function (momentScript) {

        times.push(momentScript.time);
    });

    return times;
};










p._animPlay = function () {

    this._animPlayRafid = window.requestAnimationFrame(this._animPlay);
    
    var currTime = am.timeline.currTime, 
        prevTime = this.prevRenderTime;

    this._momentScripts.forEach(function (momentScript) {

        if (momentScript.time > prevTime && momentScript.time <= currTime) {

            momentScript.runScript();
        }
    });

    this._intervalScripts.forEach(function (intervalScript) {

        if (intervalScript.isInsideBounds(currTime)) {

            intervalScript.runScript();
        }
    });

    this.prevRenderTime = currTime;
};

p._showIntervalScripts = function () {

    if (this._isShowingIntervalScrips) return;
    this._isShowingIntervalScrips = true;

    this._tgglShowIntervalScripts.setToggle(true);
    this.emit('changeHeight', this);
};

p._hideIntervalScripts = function () {

    if (!this._isShowingIntervalScrips) return;
    this._isShowingIntervalScrips = false;

    this._tgglShowIntervalScripts.setToggle(false);
    this.emit('changeHeight', this);
};








p._onSelectClick = function () {

    this.select();
};

p._onChangeTime = function () {

    if (this._isPlaying) {
        return;
    }

    this._refreshTgglMomentScript();
};

p._onChangeIntervalScript = function () {

    this.renderTime();

    this.emit('change');
};

p._onDeleteIntervalScript = function (intervalScript) {

    this.removeIntervalScript(intervalScript);
};

p._onMoveIntervalScript = function (intervalScript, way) {

    this.moveIntervalScript(intervalScript, way);
};

p._onClickTgglMomentScript = function () {

    var time = am.timeline.currTime,
        momentScript = this.getMomentScript(time);
    
    if (momentScript) {

        this.removeMomentScript(momentScript);
    }
    else {
        this.addMomentScript({time: time});
    }

    this._refreshTgglMomentScript();
};

p._onClickEditMomentScript = function () {

    var momentScript = this.getMomentScript(am.timeline.currTime);

    if (momentScript) {

        momentScript.editScript();
    }
};

p._onClickTgglShowIntervalScripts = function () {

    if (this._isShowingIntervalScrips) {
        this._hideIntervalScripts   ();
    }
    else {
        this._showIntervalScripts();
    }
};

p._onClickAddIntervalScript = function () {

    this.addIntervalScript();
};

p._onClickName = function () {

    dialogSequOptions.show({
        name: this._name,
        onChangeName: this._onChangeName,
    });
};

p._onChangeName = function (name) {

    this.name = name;
};













p._refreshTgglMomentScript = function () {

    var momentScript = this.getMomentScript(am.timeline.currTime);

    this._tgglMomentScript.setToggle(!!momentScript);
    this._tgglEditMomentScript.setToggle(!!momentScript);
};

p._refreshIntervalScriptOrdering = function () {

    this._intervalScripts.forEach(function (intervalScript) {

        this.deOptions.appendChild(intervalScript.deOptions);
        this.deKeys.appendChild(intervalScript.deKeyline);
    }, this);
};











p._createHeadOptions = function (){

    var de = document.createElement('div');
    de.style.position = 'relative';
    de.style.width = '100%';
    de.style.display = 'flex';
    de.style.height = this._baseH + 'px';
    de.style.background = 'linear-gradient(to bottom, blue 18%,darkblue 96%)';
    this.deOptions.appendChild(de);

    this.deHighlight = document.createElement('div');
    this.deHighlight.style.display = 'inline-block';
    this.deHighlight.style.width = '2px';
    this.deHighlight.style.height = this._baseH + 'px';
    this.deHighlight.style.background = 'gold';
    this.deHighlight.style.opacity = 0;
    de.appendChild(this.deHighlight);

    this._tgglShowIntervalScripts = amgui.createToggleIconBtn({
        iconOn: 'angle-down',
        iconOff: 'angle-right',
        height: this._baseH,
        onClick: this._onClickTgglShowIntervalScripts,
        parent: de
    });

    this._deName = amgui.createLabel({caption: this._name, parent: de});
    this._deName.style.height = this._baseH  + 'px';
    this._deName.style.cursor = 'pointer';
    this._deName.addEventListener('click', this._onClickName);

    var deNameIcon = amgui.createIcon({
        icon: 'cog',
        parent: de
    });
    deNameIcon.style.display = 'none';
    this._deName.addEventListener('mouseenter', function () {deNameIcon.style.display = 'inline-block';});
    this._deName.addEventListener('mouseleave', function () {deNameIcon.style.display = 'none';});

    var space = document.createElement('div');
    space.style.display = 'inline-block';
    space.style.flex = '1';
    space.style.pointerEvents = 'none';
    de.appendChild(space);

    this._btnAddIntervalScript = amgui.createIconBtn({
        icon: 'plus',
        height: this._baseH,
        defaultToggle: false,
        onClick: this._onClickAddIntervalScript,
        parent: de
    });

    this._tgglEditMomentScript = amgui.createToggleIconBtn({
        icon: 'code',
        height: this._baseH,
        onClick: this._onClickEditMomentScript,
        changeColor: true,
        parent: de
    });

    this._tgglMomentScript = amgui.createToggleIconBtn({
        iconOn: 'circle',
        iconOff: 'circle-empty',
        height: this._baseH,
        onClick: this._onClickTgglMomentScript,
        changeColor: true,
        parent: de
    });
    this._refreshTgglMomentScript();

    amgui.bindDropdown({
        asContextMenu: true,
        deTarget: de,
        deMenu: amgui.createDropdown({
            options: [
                {text: 'move up', onSelect: this.emit.bind(this, 'move', this, -1)},
                {text: 'move down', onSelect: this.emit.bind(this, 'move', this, 1)},
                {text: 'delete', onSelect: this.emit.bind(this, 'delete', this)},
            ]
        })
    });

    return de;
};

p.isOwnedDomElem = function () {

    return false;
};

p.dispose = function () {

    am.timeline.removeListener('changeTime', this._onChangeTime);

    //TODO
};

module.exports = JsSequence;





},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./IntervalScript":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\IntervalScript.js","./MomentScript":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\MomentScript.js","./dialogSequOptions":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\dialogSequOptions.js","./script.player.mst":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\script.player.mst","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\MomentScript.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var dialogScriptEditor = require('./dialogScriptEditor');
var amgui = require('../../amgui');

function MomentScript(opt) {

    EventEmitter.call(this);
    
    this._time =  0;
    this._script =  '';
    this._deKeyline = opt.deKeyline;

    this._onChangeDeTime = this._onChangeDeTime.bind(this);
    this._onSelectDropdown = this._onSelectDropdown.bind(this);
    this._onChangeTape = this._onChangeTape.bind(this);
    this._onDblclickKey = this._onDblclickKey.bind(this);

    this.domElem = this._deKeyline.addKey({
        timescale: am.timeline.timescale,
        time: this.time,
        ease: 'none'
    });


    this._deMenu = amgui.createDropdown({
        options: ['script', 'delete']
    });
    this._deMenu.addEventListener('select', this._onSelectDropdown);

    this.domElem.addEventListener('changeTime', this._onChangeDeTime);
    am.timeline.on('changeTape', this._onChangeTape);

    amgui.bindDropdown({
        deTarget: this.domElem,
        deMenu: this._deMenu,
        asContextMenu: true
    });

    this.domElem.addEventListener('dblclick', this._onDblclickKey);

    if (opt) {
        this.useSave(opt);
    }
}

inherits(MomentScript, EventEmitter);
var p = MomentScript.prototype;

Object.defineProperties(p, {

    time: {
        set: function (v) {

            if (!Number.isFinite(v) || this._time === v) return;

            this._time = v;

            this.domElem.setTime(this._time);
        },
        get: function () {

            return this._time;
        }
    },
    script: {
        set: function (v) {

            if (this._script === v) return;

            this._script = v;
        },
        get: function () {

            return this._script;
        }
    }
});


p.getSave = function () {

    return {
        script: JSON.stringify(this.script).slice(1, -1).replace(/'/g, '\\\''),
        time: this.time,
    };
};

p.useSave = function (save) {

    if ('script' in save) this.script = save.script;
    if ('time' in save) this.time = save.time;
};

p.runScript = function () {

    (new Function(this.script))();//TODO hack!!!
};

p.editScript = function () {

    dialogScriptEditor.show({

        script: this.script,
        onChangeScript: function (script) {

            this.script = script;
        }
    });
};






p._onChangeDeTime = function (e) {

    this.time = e.detail.time;

    this.emit('changeTime');
};

p._onSelectDropdown = function (e) {
    
    var selection = e.detail.selection;

    if (selection === 'delete') {

        this.emit('delete', this);
    }
    else if (selection === 'edit script') {

        this.editScript();
    }
};

p._onChangeTape = function () {

    this.domElem.setTimescale(am.timeline.timescale);
};

p._onDblclickKey = function () {

    this.editScript();
};




p.dispose = function () {

    this.domElem.removeEventListener('changeTime', this._onChangeDeTime);
    this._deMenu.removeEventListener('select', this._onSelectDropdown);
    am.timeline.removeListener('changeTape', this._onChangeTape);

    this.domElem.remove();
    if (this._deMenu.parentNode) this._deMenu.parentNode.removeChild(this._deMenu); 
};

module.exports = MomentScript;

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./dialogScriptEditor":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\dialogScriptEditor.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\dialogScriptEditor.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../../amgui');

function DialogScriptEditor () {

    EventEmitter.call(this);

    this._name = '';
    this._selectors = [];

    this._onClickOk = this._onClickOk.bind(this); 
    this._onChangeScript = this._onChangeScript.bind(this);
}

inherits(DialogScriptEditor, EventEmitter);
var p = DialogScriptEditor.prototype;



Object.defineProperties(p, {

    script: {
        set: function (v) {

            v = v || '';

            if (this._script === v) {
                return;
            }

            this._script = v;

            if (this._cm && this._cm.getValue() !== v) {
                
                this._cm.setValue(v);
            }
            this.emit('changeScript', v);
        },
        get: function () {

            return this._script;
        }
    }
});

p.show = function (opt) {

    opt = opt || {};

    this._createDialog();

    if ('script' in opt) this.script = opt.script;

    this.domElem.showModal();

    if (this._cm) {
        this._cm.refresh();
    }

    if ('onChangeScript' in opt) this.on('changeScript', opt.onChangeScript);
};

p.hide = function () {

    this.domElem.close();

    this.removeAllListeners('changeScript');
};

p._createDialog = function () {

    if (this._isDialogCreated) return;
    this._isDialogCreated = true;

    this._createContent();
    
    this.domElem = amgui.createDialog({
        title: 'Script',
        content: this._deContent,
        parent: am.deDialogCont,
        buttons: ['ok'],
    });

    this.domElem.addEventListener('click_ok', this._onClickOk);
};

p._onClickOk = function () {

    this.hide();
};

p._onChangeScript = function () {

    this.script = this._cm.getValue();
};


p._createContent = function () {

    this._deContent = document.createElement('div');
    this._deContent.style.width = '480px';
    this._deContent.style.height = '330px';
    this._deContent.style.padding = '30px 12px';

    this._textarea = document.createElement('textarea');
    this._deContent.appendChild(this._textarea);

    amgui.callOnAdded(this._textarea, function () {

        this._cm = new CodeMirror.fromTextArea(this._textarea, {
            lineNumbers: true,
            theme: 'pastel-on-dark',
            mode: 'javascript'
        });
        
        this._cm.setValue(this.script);
        this._cm.on('change', this._onChangeScript);
    }, this);
};

module.exports = new DialogScriptEditor();

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\dialogSequOptions.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../../amgui');

function DialogSequOptions () {

    EventEmitter.call(this);

    this._name = '';
    this._selectors = [];

    this._onClickOk = this._onClickOk.bind(this); 
    this._onChangeName = this._onChangeName.bind(this);
}

inherits(DialogSequOptions, EventEmitter);
var p = DialogSequOptions.prototype;



Object.defineProperties(p, {

    name: {
        set: function (v) {

            if (this._name === v) {
                return;
            }

            this._name = v;
            this._inpName.value = v;
            this.emit('changeName', v);
        },
        get: function () {
            return this._name;
        }
    },
});

p.show = function (opt) {

    opt = opt || {};

    this._createDialog();

    if ('name' in opt) this.name = opt.name;

    if ('onChangeName' in opt) this.on('changeName', opt.onChangeName);

    this.domElem.showModal();
};

p.hide = function () {

    this.domElem.close();

    this.removeAllListeners('changeName');
};

p._createDialog = function () {

    if (this._isDialogCreated) return;
    this._isDialogCreated = true;

    this._createContent();
    
    this.domElem = amgui.createDialog({
        title: 'Sequence',
        content: this._deContent,
        parent: am.deDialogCont,
        buttons: ['ok'],
    });

    this.domElem.addEventListener('click_ok', this._onClickOk);
};

p._onClickOk = function () {

    this.hide();
};

p._onChangeName = function () {

    this.name = this._inpName.value;
};


p._createContent = function () {

    this._deContent = document.createElement('div');
    this._deContent.style.width = '330px';
    this._deContent.style.padding = '30px 12px';

    amgui.createLabel({
        caption: 'Name',
        fontSize: '18px',
        display: 'block',
        parent: this._deContent
    });

    this._inpName = document.createElement('input');
    this._inpName.type = 'text';
    this._inpName.value = this.name;
    this._inpName.style.width = '245px';
    this._inpName.style.fontSize = '14px';
    this._inpName.style.fontFamily = amgui.FONT_FAMILY;
    this._inpName.style.background = 'none';
    this._inpName.style.border = 'none';
    this._inpName.style.marginBottom = '12px';
    this._inpName.style.color = amgui.color.text;
    this._inpName.addEventListener('change', this._onChangeName);
    this._deContent.appendChild(this._inpName);
};

module.exports = new DialogSequOptions();

},{"../../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\jsModule.js":[function(require,module,exports){
'use strict';

var JsSequence = require('./JsSequence');

exports.init = function () {

    am.registerSequenceType(JsSequence, JsSequence.prototype.type);
};

},{"./JsSequence":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\JsSequence.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\modules\\javascript\\script.player.mst":[function(require,module,exports){
module.exports = " function () {\n\n    return function () {\n\n        var currTime = 0,\n            prevTime = 0,\n            speed = 0;\n        \n        this.startSystemTime = 0;\n        this.momentFunctions = [{{{momentFunctions}}}];\n        this.intervalFunctions = [{{{intervalFunctions}}}];\n\n        this.step = function(time) {\n\n            this.stepRafId = requestAnimationFrame(this.step);\n            \n            prevTime = currTime;\n            currTime = performance.now();\n\n            this.momentFunctions.forEach(function (fnData) {\n\n                if (fnData.time > prevTime && fnData.time <= currTime) {\n\n                    fnData.fn();\n                }\n            });\n\n            this.intervalFunctions.forEach(function (fnData) {\n\n                for (var i = 0; i < fnData.bounds; i += 2) {\n\n                    if (fnData.bounds[i] > prevTime && fnData.bounds[i+1] <= currTime) {\n\n                        fnData.fn();\n                    }\n                }\n            });\n\n        }.bind(this);\n\n        var ret = {};\n\n        ret.play = function () {\n\n            this.step();\n\n        }.bind(this);\n\n        ret.pause = function () {\n\n            cancelAnimationFrame(this.stepRafId);\n\n        }.bind(this);\n\n        ret.seek = function (time) {\n\n            currTime = time;\n            prevTime = time;\n\n        }.bind(this);\n\n    }.call({});\n};";

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\mouse\\Mouse.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

function Mouse() {

    this.screenX = 0;
    this.screenY = 0;

    this._onMouseMove = this._onMouseMove.bind(this);

    window.addEventListener('mousemove', this._onMouseMove);
}

inherits(Mouse, EventEmitter);
var p = Mouse.prototype;

p._onMouseMove = function (e) {

    this.screenX = e.screenX;
    this.screenY = e.screenY;
} 


module.exports = Mouse;

},{"events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\qsgen.js":[function(require,module,exports){
'use strict';

var EXATTR = ['id', 'class', 'style'];

function generate(de, root) {

    root = root || document;

    var deCurr = de,
        rootCurr = root, 
        qsCurr, qsParent = '';

    while (true) {

        do {
            qsCurr = gen(deCurr, rootCurr);
        }
        while(!qsCurr && 
            deCurr.parentNode !== rootCurr &&
            (deCurr = deCurr.parentNode));

        if (!qsCurr) {

            if (deCurr.parentNode === rootCurr) {

                qsCurr = '> ' + deCurr.tagName + ':nth-child(' +
                    (Array.prototype.indexOf.call(rootCurr.childNodes, deCurr) + 1) + ')';
            }
            else {
                return; //can't find unique query selector
            }
        }

        qsParent += (qsParent ? ' ' : '') + qsCurr;

        if (deCurr === de) {

            return qsParent;
        }
        else {
            qsCurr = undefined;
            rootCurr = deCurr;
            deCurr = de;
        }
    }
}

function gen(de, root) {


    var singles, selectors, matches = [];

    singles = selectors = [de.tagName].concat(
        possibleIds(de),
        possibleClasses(de, i),
        possibleAttributes(de, i)
    );

    for (var i = 0; i < 5; ++i) {

        selectors.forEach(function (selector) {

            if (root.querySelectorAll(selector).length === 1) {
                matches.push(selector);
            }
        });

        if (matches.length) {

            return matches[0];
        }
        else {
            selectors = combine(selectors, singles);
        }
    }
}

function possibleIds(de) {

    return de.id ? ['#' + CSS.escape(de.id)] : [];
}

function possibleClasses(de, max) {

    return Array.prototype.slice.call(de.classList, 0)
        .map(function (className) {
            return '.' + CSS.escape(className);
        });
}

function possibleAttributes(de) {

    return Array.prototype.slice.call(de.attributes, 0)
        .filter(function(attr) {
            return EXATTR.indexOf(attr.name) === -1;
        })
        .map(function (attr) {
            return '[' + CSS.escape(attr.name) + (attr.value ? '="'+attr.value+'"': '') + ']';
        });
}

// function variate(_list, length) {

//     return step(_list, 2);

//     function step(list, back) {

//         var combined = combine(attributes, list);
//         return list.concat(back === 0 ? combined : step(combined, --back));
//     }
// }

function combine(sourceA, sourceB) {

    var combined = [];

    sourceA.forEach(function (a) {
        sourceB.forEach(function (b) {
            if (a.indexOf(b) === -1 && b.indexOf(a) === -1 &&
                '#.[:'.indexOf(b.charAt(0)) !== -1) 
            {
                combined.push(a + b);
            }
        });
    });

    return combined;
}

module.exports = generate;

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\Timebar.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../amgui');
var decorTimebarNavigator = require('./decorTimebarNavigator');

function Timebar(opt) {

    EventEmitter.call(this);

    opt = opt || {};

    this._start = opt.start || 0;
    this._width = opt.width || 0;
    this._height = opt.height || 21;
    this._timescale = opt.timescale || 0;
    this._currTime = opt.currTime || 0;
    this._length = opt.length || 60000;

    this._magnetPoints = [];

    this._onMDown = onMDown.bind(this);
    this._onMMove = onMMove.bind(this);
    this._onMUp = onMUp.bind(this);

    this._steps = getSteps();

    this._createBase();
    this._createPointer();
    this._createEndShadow();

    this._renderTape();
//TODO use amgui.makeDraggable()
    this._canvasTape.addEventListener('mousedown', this._onMDown);

    decorTimebarNavigator(this);
}

inherits(Timebar, EventEmitter);
var p = Timebar.prototype;
module.exports = Timebar;




Object.defineProperties(p, {

    /** px/ms */
    timescale: {
        set: function (v) {

            if (!Number.isFinite(v) || this._timescale === v) return;

            this._timescale = Math.min(1, Math.max(0.0001, v));
            this._renderTape();
            this.emit('changeTape');
        },
        get: function () {
            return this._timescale;
        }
    },

    start: {
        set: function (v) {

            v = parseInt(v);

            if (!Number.isFinite(v) || this._start === v) return;

            this._start = Math.min(0, v);
            this._renderTape();
            this.emit('changeTape');
        },
        get: function () {
            return this._start;
        }
    }, 

    width: {
        set: function (v) {

            v = parseInt(v);

            if (!Number.isFinite(v) || this._width === v) return;
            
            this._width = v;
            this._renderTape();
            this.emit('changeTape');
        },
        get: function () {
            return this._width;
        }
    }, 
    
    end: {
        get: function () {
            return this._start + (this._width / this._timescale);
        }
    },
    
    visibleTime: {
        set: function (v) {
            this.timescale = this._width / v;
        },

        get: function () {
            return this._width / this._timescale;
        }
    },
    
    currTime: {
        set: function (v) {

            v = parseInt(v);

            if (!Number.isFinite(v) || this._currTime === v) return;

            this._currTime = v;

            this._refreshPointer();

            this.emit('changeTime', this._currTime);
        },
        get: function () {
            return this._currTime;
        }
    }, 
    
    magnetPoints: {
        set: function (v) {
            this._magnetPoints = v;
        },
        get: function () {
            return this._magnetPoints;
        }
    },

    length: {
        set: function (v) {

            v = parseInt(v);

            if (!Number.isFinite(v) || this._length === v) return;
            this._length = v;

            this._renderTape();
            this.emit('changeTape');
        },
        get: function () {
            return this._length;
        }
    },
});











p.screenXToTime = function (screenX) {

    var left = this._canvasTape.getBoundingClientRect().left,
        mouseX = screenX - left,
        time = (mouseX / this.width) * this.visibleTime;

    time -= this.start;

    return time;
};











p._renderTape = function () {

    var start = this._start,
        length = this._length,
        visibleTime = this.visibleTime,
        height = this._height,
        scale = this.timescale, 
        width = this._width,
        maxMarkers = width / 4,
        step, i, text, textW,
        ctx = this._ctxTape;

    this._canvasTape.width = width;
    this._canvasTape.height = height;

    this._steps.forEach(function (s) {

        if ((this.visibleTime / s.small) < maxMarkers && (!step || step.small > s.small)) {

            step = s;
        }
    }, this);

    if (step) {

        ctx.linweidth = 0.5;
        ctx.strokeStyle = amgui.color.bg3;
        ctx.fillStyle = amgui.color.bg3;
        ctx.font = ~~(this._height * 0.5) + 'px "Open Sans"';

        for (i = start % step.small; i < visibleTime; i += step.small) {

            ctx.moveTo(~~(i * scale) + 0.5, height);
            ctx.lineTo(~~(i * scale) + 0.5, height * 0.75);
        }
        ctx.stroke();

        for (i = start % step.big; i < visibleTime; i += step.big) {

            ctx.moveTo(~~(i * scale) + 0.5, height);
            ctx.lineTo(~~(i * scale) + 0.5, height * 0.62);
        }
        ctx.stroke();

        for (i = start % step.time; i < visibleTime; i += step.time) {

            text = step.format(i - start);
            textW = ctx.measureText(text).width / 2;
            ctx.fillText(text, i * scale - textW, 12);
        }
        ctx.stroke();
    }

    this._refreshPointer();

    var endWidth = ((visibleTime - (start + length)) * scale);
    this._deEndShadow.style.width = Math.max(0, Math.min(width, endWidth)) + 'px';
};












function onMDown(e) {

    e.stopPropagation();
    e.preventDefault();

    if (e.shiftKey) this._dragMode = 'translate';
    else if (e.ctrlKey) this._dragMode = 'scale';
    else this._dragMode = 'seek';

    this._mdX = e.pageX;
    this._mdStart = this._start;
    this._mdTimescale = this._timescale;

    this._onMMove(e);

    window.addEventListener('mousemove', this._onMMove);
    window.addEventListener('mouseup', this._onMUp);
    window.addEventListener('mouseleave', this._onMUp);
}

function onMMove(e) {

    var move = e.screenX - this._mdX,
        time, magnetPoint, magnetPointDiff;

    if (this._dragMode === 'seek') {

        time = this.screenXToTime(e.screenX);

        this._magnetPoints.forEach(function (mp) {

            var diff = Math.abs(mp - time);

            if (diff < magnetPointDiff || magnetPointDiff === undefined) {
                magnetPoint = mp;
                magnetPointDiff = diff;
            }
        });
        
        if ((magnetPointDiff * this._timescale) < 2) {

            time = magnetPoint;
        }

        this.currTime = time;

        this.emit('seek');
    }
    else if (this._dragMode === 'translate') {

        this.start = this._mdStart + (move / this.timescale);
    }
    else if (this._dragMode === 'scale') {

        this.timescale = this._mdTimescale + (move/1000);

        var mdPos = (this._mdStart + this.currTime) * this._mdTimescale;
        this.start = -((this.currTime * this.timescale) - mdPos) / this.timescale;
    }
}

function onMUp() {

    window.removeEventListener('mousemove', this._onMMove);
    window.removeEventListener('mouseup', this._onMUp);
    window.removeEventListener('mouseleave', this._onMUp);
}










p._refreshPointer = function () {

    var pos = ((this.start + this.currTime) / this.visibleTime) * this.width;

    this._dePointer.style.left = pos + 'px';
};











p._createBase = function () {

    this.domElem = document.createElement('div');
    this.domElem.style.backgroundColor = amgui.color.bg0;
    this.domElem.style.position = 'relative';

    this._canvasTape = document.createElement('canvas');
    this._ctxTape = this._canvasTape.getContext('2d');
    this._canvasTape.style.display = 'block';
    this.domElem.appendChild(this._canvasTape); 
};

p._createPointer = function () {

    var radius = 5.5;
    this._dePointer = document.createElement('div');
    this._dePointer.style.position = 'absolute';
    this._dePointer.style.bottom = 2*radius + 'px';
    var pointer = document.createElement('div');
    pointer.style.position = 'absolute';
    pointer.style.boxSizing = 'border-box';
    pointer.style.pointerEvents = 'none';
    pointer.style.left = -radius + 'px';
    pointer.style.width = 2*radius + 'px';
    pointer.style.height = 2*radius + 'px';
    pointer.style.border = 'solid red 1px';
    pointer.style.borderRadius = radius + 'px';
    this._dePointer.appendChild(pointer); 
    this.domElem.appendChild(this._dePointer); 
};

p._createEndShadow = function () {

    this._deEndShadow = document.createElement('div');
    this._deEndShadow.style.position = 'absolute';
    this._deEndShadow.style.top = '0px';
    this._deEndShadow.style.right = '0px';
    this._deEndShadow.style.height = '100%';
    this._deEndShadow.style.width = '0px';
    this._deEndShadow.style.pointerEvents = 'none';
    this._deEndShadow.style.backgroundColor = 'rgba(83,83,83,0.73)';
    this.domElem.appendChild(this._deEndShadow); 

    var handler = document.createElement('div');
    handler.style.position = 'absolute';
    handler.style.top = '0px';
    handler.style.left = '0px';
    handler.style.height = '100%';
    handler.style.width = '3px';
    handler.style.cursor = 'ew-resize';
    handler.style.pointerEvents = 'auto';
    this._deEndShadow.appendChild(handler);

    amgui.makeDraggable({
        deTarget: handler,
        thisArg: this,
        onDown: function () {
            return {
                length: this.length,
            };
        },
        onMove: function (md, mx) {

            var dx = mx - md.mx;
            this.length = md.length + (dx / this.timescale);
        }
    });
};








//Steps
function getSteps() {

    return [
        {
            small: 5, 
            big: 50, 
            time: 50, 
            format: function (ms) {
                
                return ms + 'ms';
            } 
        },
        {
            small: 10, 
            big: 100, 
            time: 100, 
            format: function (ms) {
                
                return ms + 'ms';
            } 
        },
        {
            small: 100, 
            big: 1000, 
            time: 1000, 
            format: function (ms) {
                var min = parseInt(ms/60000);
                var sec = parseInt(ms/1000) % 60;

                return (min ? min+':'+two(sec) : sec) + 's';
            } 
        },
        {
            small: 500, 
            big: 5000, 
            time: 5000, 
            format: function (ms) {
                var min = parseInt(ms/60000);
                var sec = parseInt(ms/1000) % 60;

                return (min ? min+':'+two(sec) : sec) + 's';
            } 
        },
        {
            small: 10000, 
            big: 60000, 
            time: 60000, 
            format: function (ms) {
                var min = parseInt(ms/60000) % 60;
                var hour = parseInt(ms/3600000);

                return (hour ? hour+':'+two(min) : min) + 'm';
            } 
        },
        {
            small: 60000, 
            big: 5*60000, 
            time: 5*60000, 
            format: function (ms) {
                var min = parseInt(ms/60000) % 60;
                var hour = parseInt(ms/3600000);

                return (hour ? hour+':'+two(min) : min) + 'm';
            } 
        }
    ];

    function two(num) {

        return ('00' + num).substr(-2);
    }
}

},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./decorTimebarNavigator":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\decorTimebarNavigator.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\Timeline.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var Timebar = require('./Timebar');
var amgui = require('../amgui');
var mineSave = require('./mineSave');
var UglifyJS = require('uglify-js');
var mstSaveScript = require('./script.save.mst');

function Timeline(opt) {

    EventEmitter.call(this);
    this.setMaxListeners(1100);

    this._headerH = 23;

    this._onSelectSequence = this._onSelectSequence.bind(this);
    this._onChangeSequence = this._onChangeSequence.bind(this);
    this._onDeleteSequence = this._onDeleteSequence.bind(this);
    this._onMoveSequence = this._onMoveSequence.bind(this);
    this._onChangeTime = this._onChangeTime.bind(this);
    this._onChangeTape = this._onChangeTape.bind(this);
    this._onWindowResize = this._onWindowResize.bind(this);
    this._onSelectNewSequ = this._onSelectNewSequ.bind(this);
    this._onTogglePlayPause = this._onTogglePlayPause.bind(this);
    this._onTimebarSeek = this._onTimebarSeek.bind(this);
    this._onChangeSequenceHeight = this._onChangeSequenceHeight.bind(this);
    this._onStartEditCurrTime = this._onStartEditCurrTime.bind(this);
    this._onFinishEditCurrTime = this._onFinishEditCurrTime.bind(this);
    this._onChangeInpCurrTime = this._onChangeInpCurrTime.bind(this);
    this._animPlay = this._animPlay.bind(this);
    
    this._timebar = new Timebar({
        height: this._headerH,
        timescale: 0.12,
        length: 6000
    });
    
    this._createBase();
    this._createPointerLine();


    this._refreshTimebarWidth();
    this._refreshDeCurrTime();

    this._sequences = [];
    this._mapSequenceDatas = new WeakMap();

    this._timebar.on('changeTime', this.emit.bind(this, 'changeTime'));
    this._timebar.on('changeTape', this.emit.bind(this, 'changeTape'));
    this._timebar.on('changeTime', this._onChangeTime);
    this._timebar.on('changeTape', this._onChangeTape);
    this._timebar.on('seek', this._onTimebarSeek);

    amgui.callOnAdded(this.domElem, this._refreshTimebarWidth, this);
    
    window.addEventListener('resize', this._onWindowResize);

    if (opt) {
        this.useSave(opt);
    }
}

inherits(Timeline, EventEmitter);
var p = Timeline.prototype;
module.exports = Timeline;






Object.defineProperties(p, {

    'currTime': {
        get: function () {
            return this._timebar._currTime;
        }
    },
    'timescale': {
        get: function () {
            return this._timebar.timescale;
        }
    },
    'sequences': {
        get: function () {
            return this._sequences;
        }
    },
    'length': {
        get: function () {
            return this._timebar.length;
        }
    }
});

p.getSave = function () {

    var save = {
        timebar: {
            currTime: this._timebar.currTime,
            timescale: this._timebar.timescale,
            length: this._timebar.length,
        },
        sequences: []
    };

    this._sequences.forEach(function (sequ) {

        save.sequences.push({
            type: sequ.type,
            data: sequ.getSave()
        });
    });

    console.log(JSON.stringify(save));

    return JSON.stringify(save);
};

p.useSave = function (save) {

    save = mineSave(save);

    if (!save) {
        alert('Can\'t use this save');
    }

    this.clear();

    save = _.extend({
        timebar: {},
        sequences: []
    }, save);

    this._timebar.currTime = save.timebar.currTime;
    this._timebar.timescale = save.timebar.timescale;
    this._timebar.length = save.timebar.length;

    save.sequences.forEach(function (sequData) {

        var SequClass = am.sequenceTypes[sequData.type],
            sequ = new SequClass(sequData.data);

        this.addSequence(sequ);
    }, this);

    _.invoke(this._sequences, 'renderTime', this.currTime);

    am.history.clear();
};

p.getScript = function (opt) {

    opt = opt || {};

    var script, playerScripts = [];

    this._sequences.forEach(function (sequ) {

        playerScripts.push(sequ.getScript());
    });

    script = Mustache.render(mstSaveScript, {
        name: 'amsave',
        saveJson: opt.includeSave && this.getSave(),
        sequPlayerGens: playerScripts.join(',\n'),
        autoPlay: opt.autoPlay
    });

    if (opt.minify) {

    console.log(script);
        script = minify(script);
    }

    console.log(script);

    return script;

    function minify(code) {

        return code;//TODO

        var result = UglifyJS.minify(code, {
            fromString: true,
            mangle: false,
            output: {
                comments: /@amsave/,
            },
            compress: {
                // reserved: 'JSON_SAVE',
            }
        });

        return result.code;

        var toplevel = null;
        toplevel = UglifyJS.parse(code, {
            filename: 'save',
            toplevel: toplevel
        });

        toplevel.figure_out_scope();

        var compressor = UglifyJS.Compressor({mangle: false});
        var compressed_ast = toplevel.transform(compressor);

        compressed_ast.figure_out_scope();
        compressed_ast.compute_char_frequency();
        compressed_ast.mangle_names();

        return compressed_ast.print_to_string({comments: 'all'});
    } 
};

p.clear = function () {
    
    while(this._sequences.length) {

        this.removeSequence(this._sequences[0]);
    }
};

p.addSequence = function (sequ, skipHistory) {

    if (!skipHistory) {
        am.history.save([this.removeSequence, this, sequ, true],
            [this.addSequence, this, sequ, true]);
    }
    
    this._sequences.push(sequ);

    this._mapSequenceDatas.set(sequ, {
        deContOpt: createCont(sequ.deOptions, this._deOptionsCont),
        deContKf: createCont(sequ.deKeys, this._deKeylineCont),
    });

    this._onChangeSequenceHeight(sequ);

    sequ.on('select', this._onSelectSequence);
    sequ.on('change', this._onChangeSequence);
    sequ.on('delete', this._onDeleteSequence);
    sequ.on('move', this._onMoveSequence);
    sequ.on('changeHeight', this._onChangeSequenceHeight);

    function createCont(content, parent) {

        var de = document.createElement('div');
        de.style.width = '100%';
        de.style.height = sequ.height + 'px';
        de.style.overflow = 'hidden';
        de.style.transform = 'height 0.12 easeOut';
        de.appendChild(content);
        parent.appendChild(de);

        return de;
    }
};

p.removeSequence = function (sequ, skipHistory) {

    if (!skipHistory) {
        am.history.save([this.addSequence, this, sequ, true],
            [this.removeSequence, this, sequ, true]);
    }

    var idx = this._sequences.indexOf(sequ);

    if (idx === -1) {
        return;
    }

    this._sequences.splice(idx, 1);

    var sequData = this._mapSequenceDatas.get(sequ);
    $(sequData.deContOpt).remove();
    $(sequData.deContKf).remove();
    this._mapSequenceDatas.delete(sequ);

    sequ.removeListener('select', this._onSelectSequence);
    sequ.removeListener('change', this._onChangeSequence);
    sequ.removeListener('delete', this._onDeleteSequence);
    sequ.removeListener('move', this._onMoveSequence);
    sequ.removeListener('changeHeight', this._onChangeSequenceHeight);

    sequ.dispose();
};

p.moveSequence = function (sequ, way) {

    var idx = this._sequences.indexOf(sequ);

    this._sequences.splice(idx, 1);
    idx = Math.min(this._sequences.length, Math.max(0, idx + way));
    this._sequences.splice(idx, 0, sequ);

    this._refreshSequenceOrdering();
};

p.play = function () {

    if (this._isPlaying) return;
    this._isPlaying = true;

    this._btnTogglePlay.setToggle(true);

    _.invoke(this._sequences, 'play', this.currTime);

    this._playStartTimeStamp = performance.now();
    this._playStartCurrTime = this.currTime;
    this._animPlay();
};

p.pause = function () {

    if (!this._isPlaying) return;
    this._isPlaying = false;

    this._btnTogglePlay.setToggle(false);

    _.invoke(this._sequences, 'pause');

    window.cancelAnimationFrame(this._animPlayRafid);
};

p.screenXToTime = function (screenX) {

    return this._timebar.screenXToTime(screenX);
}








p._animPlay = function () {

    this._animPlayRafid = window.requestAnimationFrame(this._animPlay);

    var t = Math.round(performance.now() - this._playStartTimeStamp);
    this._timebar.currTime = (this._playStartCurrTime + t) % this._timebar.length;
};

p._onTimebarSeek = function () {

    this.pause();
};

p._onSelectSequence = function(sequ) {

    if (this._currSequence === sequ) 
        return;

    if (this._currSequence) {
        
        this._currSequence.deselect(); 
    }

    this._currSequence = sequ;
};

p._onChangeSequence = function() {

    this._refreshMagnetPoints();
};

p._onDeleteSequence = function (sequ) {

    this.removeSequence(sequ);
};

p._onMoveSequence = function (sequ, way) {

    this.moveSequence(sequ, way);
};

p._onChangeTime = function () {

    this._refreshDePointer();

    this._refreshDeCurrTime();
};

p._onChangeTape = function () {

    var left = (this._timebar.start * this.timescale);

    this._deKeylineCont.style.left = left + 'px';
    this._deKeylineCont.style.width = 'calc(100% + ' + (-left) + 'px)';

    this._refreshDePointer();
};

p._onChangeSequenceHeight = function (sequ) {

    var h = sequ.height,
        sequData = this._mapSequenceDatas.get(sequ);

    sequData.deContOpt.style.height = h + 'px';
    sequData.deContKf.style.height = h + 'px';
};

p._onWindowResize = function () {

    this._refreshTimebarWidth();
};

p._onTogglePlayPause = function () {

    if (this._isPlaying) {

        this.pause();
    }
    else {
        this.play();
    }
};

p._onSelectNewSequ = function (e) {

    var addSequ = function (type) {

        var SequClass = am.sequenceTypes[type];

        this.addSequence(new SequClass());
    }.bind(this);

    switch (e.detail.selection) {

        case 'css':
            addSequ('css_sequ_type');
            break;

        case 'js':
            addSequ('js_sequ_type');
            break;

        default:
            am.dialogs.featureDoesntExist.show();
            
    }
};

p._onStartEditCurrTime = function () {

    this._inpCurrTime.value = this.currTime;

    this._deCurrTime.style.display = 'none';
    this._inpCurrTime.style.display = 'block';

    this._inpCurrTime.focus();
};

p._onFinishEditCurrTime = function () {

    this._inpCurrTime.style.display = 'none';
    this._deCurrTime.style.display = 'block';
};

p._onChangeInpCurrTime = function () {

    this._timebar.currTime = this._inpCurrTime.value;
};








p._refreshSequenceOrdering = function () {

    this._sequences.forEach(function (sequ) {

        var sequData = this._mapSequenceDatas.get(sequ);

        this._deOptionsCont.appendChild(sequData.deContOpt);
        this._deKeylineCont.appendChild(sequData.deContKf);
    }, this);
};

p._refreshMagnetPoints = function () {

    var magnetPoints = [];

    this._sequences.forEach(function (sequ) {

        if (typeof sequ.getMagnetPoints === 'function') {

            magnetPoints = magnetPoints.concat(sequ.getMagnetPoints());
        }
    });

    magnetPoints = _.uniq(magnetPoints);

    this._timebar.magnetPoints = magnetPoints;
};

p._refreshTimebarWidth = function () {

    this._timebar.width = this._deRight.offsetWidth;
};

p._refreshDePointer = function () {

    var left = (this._timebar.start + this.currTime) * this.timescale;
    this._dePointerLine.style.left = left + 'px';
};

p._refreshDeCurrTime = function () {

    var time = this.currTime, 
        min, sec, ms, str  = '';

    min = ~~(time / 60000);
    time %= 60000;
    sec = ~~(time / 1000);
    time %= 1000;
    ms = ~~time;

    if (min) {
        str += min + ':';
        sec = ('00' + sec).substr(-2);
    }
    if (sec) {
        str += sec + ':';
        ms = ('000' + ms).substr(-3);
    }
    str += ms;
    this._deCurrTime.textContent = str;
};







p._createBase = function () {

    this.domElem = document.createElement('div');
    this.domElem.style.backgroundColor = amgui.color.bg0; 
    this.domElem.style.display = 'flex'; 
    this.domElem.style.pointerEvents = 'auto'; 

    this._deLeft = document.createElement('div');
    this._deLeft.style.backgroundColor = amgui.color.bg0;
    this._deLeft.style.display = 'flex';
    this._deLeft.style.flexDirection = 'column';
    this._deLeft.style.width = '300px';
    this._deLeft.style.height = '100%';
    this.domElem.appendChild(this._deLeft);

    this._createSettingsHead();

    this._deDivider = document.createElement('div');
    this._deDivider.style.backgroundColor = amgui.color.bg3;
    this._deDivider.style.width = '1px';
    this._deDivider.style.height = '100%';
    this.domElem.appendChild(this._deDivider);

    this._deRight = document.createElement('div');
    this._deRight.style.display = 'flex';
    this._deRight.style.flexDirection = 'column';
    this._deRight.style.position = 'relative';
    this._deRight.style.backgroundColor = amgui.color.bg0;
    this._deRight.style.flex = '1';
    this._deRight.style.height = '100%';
    this.domElem.appendChild(this._deRight);

    this._timebar.domElem.style.height = '23px';
    this._deRight.appendChild(this._timebar.domElem);

    this._deKeylineCont3 = document.createElement('div');
    this._deKeylineCont3.style.position = 'relative';
    this._deKeylineCont3.style.display = 'flex';
    this._deKeylineCont3.style.flex = '1';
    this._deKeylineCont3.style.height = '100%';
    this._deKeylineCont3.style.width = '100%';
    this._deKeylineCont3.style.overflow = 'hidden';
    this._deRight.appendChild(this._deKeylineCont3);

    this._deOptionsCont2 = document.createElement('div');
    this._deOptionsCont2.style.position = 'relative';
    this._deOptionsCont2.style.flex = '1';
    this._deOptionsCont2.style.width = '100%';
    this._deOptionsCont2.style.height = '100%';
    this._deOptionsCont2.style.overflow = 'hidden';
    this._deLeft.appendChild(this._deOptionsCont2);

    this._deKeylineCont2 = document.createElement('div');
    this._deKeylineCont2.style.position = 'relative';
    this._deKeylineCont2.style.flex = '1';
    this._deKeylineCont3.appendChild(this._deKeylineCont2);

    this._deKeylineCont = document.createElement('div');
    this._deKeylineCont.style.position = 'relative';
    this._deKeylineCont.style.width = '100%';
    this._deKeylineCont2.appendChild(this._deKeylineCont);

    this._deOptionsCont = document.createElement('div');
    this._deOptionsCont.style.position = 'relative';
    this._deOptionsCont2.appendChild(this._deOptionsCont);

    this._deRange = amgui.createRange({
        width: '6px',
        height: 'auto',
        parent: this._deKeylineCont3,
        vertical: true
    });

    amgui.makeScrollable({
        deCont: [this._deOptionsCont2, this._deKeylineCont3],
        deTarget: [this._deOptionsCont, this._deKeylineCont],
        deRange: this._deRange
    });

    this._createDividerHandler();
};


p._createSettingsHead = function () {

    this._deSettingsHead = document.createElement('div');
    this._deSettingsHead.style.backgroundColor = 'darkgreey';
    this._deSettingsHead.style.display = 'flex';
    this._deSettingsHead.style.width = '100%';
    this._deSettingsHead.style.height = this._headerH + 'px';
    this._deLeft.appendChild(this._deSettingsHead);

    this._btnNewSequ = amgui.createIconBtn({
        tooltip: 'add new sequence',
        icon: 'plus-squared',
        parent: this._deSettingsHead,
        display: 'inline-block',
    });

    amgui.bindDropdown({
        deTarget: this._btnNewSequ,
        deMenu: amgui.createDropdown({
            options: ['css', 'js', 'attribute', 'media', 'timeline', 'three.js', 'pixi.js'],
            onSelect: this._onSelectNewSequ
        })
    });

    
    this._btnTogglePlay = amgui.createToggleIconBtn({
        tooltip: 'play/pause preview',
        iconOn: 'pause', 
        iconOff: 'play',
        parent: this._deSettingsHead,
        display: 'inline-block',
        onClick: this._onTogglePlayPause
    });

    this._deCurrTime = amgui.createLabel({
        caption: '',
        parent: this._deSettingsHead
    });
    this._deCurrTime.style.flex = '1';
    this._deCurrTime.style.textAlign = 'right';
    this._deCurrTime.style.fontSize = '12px';
    this._deCurrTime.style.marginRight = '2px';
    this._deCurrTime.style.color = amgui.color.bg3;
    this._deCurrTime.addEventListener('click', this._onStartEditCurrTime);

    this._inpCurrTime = amgui.createInput({
        type: 'number',
        parent: this._deSettingsHead
    });
    this._inpCurrTime.style.display = 'none';
    this._inpCurrTime.style.flex = '1';
    this._inpCurrTime.style.textAlign = 'right';
    this._inpCurrTime.style.fontSize = '12px';
    this._inpCurrTime.style.marginRight = '2px';
    this._inpCurrTime.style.color = amgui.color.bg3;
    this._inpCurrTime.addEventListener('blur', this._onFinishEditCurrTime);
    this._inpCurrTime.addEventListener('change', this._onChangeInpCurrTime);
};

p._createDividerHandler = function () {

    this._deDividerHandler = document.createElement('div');
    this._deDividerHandler.style.top = this._headerH + 'px';
    this._deDividerHandler.style.left = this._deLeft.style.width;
    this._deDividerHandler.style.width = '1px';
    this._deDividerHandler.style.position = 'absolute';
    this._deDividerHandler.style.height = 'calc(100% - ' + this._headerH + 'px)';
    this._deDividerHandler.style.transform = 'scaleX(3)';
    this._deDividerHandler.style.cursor = 'ew-resize';
    this.domElem.appendChild(this._deDividerHandler);

    amgui.makeDraggable({

        deTarget: this._deDividerHandler,
        thisArg: this,
        
        onMove: function (md, mx) {

            var left = mx - this.domElem.getBoundingClientRect().left + 'px';

            this._deLeft.style.width = left;
            this._deDividerHandler.style.left = left;

            this._refreshTimebarWidth();
        }
    });
};

p._createPointerLine = function () {

    this._dePointerLine = document.createElement('div');
    this._dePointerLine.style.top = this._headerH + 'px';
    this._dePointerLine.style.width = '0px';
    this._dePointerLine.style.position = 'absolute';
    this._dePointerLine.style.userSelect = 'none';
    this._dePointerLine.style.height = '100%';
    this._dePointerLine.style.borderLeft = '1px solid red';
    this._deRight.appendChild(this._dePointerLine);
};
},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./Timebar":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\Timebar.js","./mineSave":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\mineSave.js","./script.save.mst":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\script.save.mst","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js","uglify-js":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\uglify-js\\tools\\node.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\decorTimebarNavigator.js":[function(require,module,exports){
'use strict';

var amgui = require('../amgui');


function decorTimebarNavigator (timebar) {

    var deNav, deLeftHand, deRightHand, dragMode;
    
    createBase();
    timebar.domElem.appendChild(deNav);

    amgui.makeDraggable({
        deTarget: deNav,
        onDown: function (e) {

            if (e.target === deLeftHand) dragMode = 'start';
            else if (e.target === deRightHand) dragMode = 'end';
            else dragMode = 'move';

            return {
                start: timebar.start,
                visibleTime: timebar.visibleTime,
                timescale: timebar.timescale,
            };
        },
        onMove: function (md, mx) {

            var scale = timebar.width / timebar.length,
                move = (mx - md.mx) / scale,
                start = md.start - move;

            if (dragMode === 'move') {

                timebar.start = start;
            }
            else if (dragMode === 'start') {

                timebar.start = start;
                timebar.visibleTime = md.visibleTime - move;
            }
            else if (dragMode === 'end') {

                timebar.visibleTime = md.visibleTime + move;

                var mdPos = (md.start + timebar.currTime) * md.timescale;
                timebar.start = -((timebar.currTime * timebar.timescale) - mdPos) / timebar.timescale;
            }   
        },
        onUp: function () {

            dragMode = undefined;
            onMLeave();
        },
        onEnter: function () {

            deNav.style.transform = 'scaleY(1)';
        },
        onLeave: onMLeave
    });

    timebar.on('changeTape', onChangeTape);


    function onChangeTape() {

        var scale = timebar.width / timebar.length;

        deNav.style.left = (-timebar.start * scale) + 'px';
        deNav.style.width = (timebar.visibleTime * scale) + 'px';
    }

    function onMLeave() {

        if (!dragMode) {
            deNav.style.transform = 'scaleY(0.4)';
        }
    }

    function createBase () {

        deNav = document.createElement('div');
        deNav.style.position = 'absolute';
        deNav.style.top = '0px';
        deNav.style.height = '7px';
        deNav.style.cursor = 'move';
        deNav.style.transformOrigin = 'center top';
        deNav.style.background = amgui.color.bg2;

        deRightHand = createHandler('right');
        deLeftHand = createHandler('left');
        onMLeave();
    }

    function createHandler(side) {

        var de = document.createElement('div');
        de.style.position = 'absolute';
        de.style[side] = '0px';
        de.style.top = '0px';
        de.style.height = '100%';
        de.style.width = '8%';
        de.style.minWidth = '1px';
        de.style.maxWidth = '7px';
        de.style.cursor = 'ew-resize';
        deNav.appendChild(de);

        return de;
    }
}

module.exports = decorTimebarNavigator;
},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\mineSave.js":[function(require,module,exports){
"use strict";

module.exports = mine;

function mine(str) {

    if (typeof(str) === 'object') {

        return str;
    }

    var rx = /\/\*\*[\s\S].*@amsave[\s\S].*\*\/[\s\S].*var\s.*SAVEJSON\s.*=([\s\S].*)/,
        m = rx.exec(str),
        json;

    if (m && m[1]) {

        json = extractJSON(m[1])[0];

        if (json) {
            return json;
        }
    }
}

//http://stackoverflow.com/a/10574546/3615288
function extractJSON(str) {
    var firstOpen, firstClose, candidate;
    firstOpen = str.indexOf('{', firstOpen + 1);
    do {
        firstClose = str.lastIndexOf('}');
        console.log('firstOpen: ' + firstOpen, 'firstClose: ' + firstClose);
        if(firstClose <= firstOpen) {
            return null;
        }
        do {
            candidate = str.substring(firstOpen, firstClose + 1);
            console.log('candidate: ' + candidate);
            try {
                var res = JSON.parse(candidate);
                console.log('...found');
                return [res, firstOpen, firstClose + 1];
            }
            catch(e) {
                console.log('...failed');
            }
            firstClose = str.substr(0, firstClose).lastIndexOf('}');
        } while(firstClose > firstOpen);
        firstOpen = str.indexOf('{', firstOpen + 1);
    } while(firstOpen !== -1);
}
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\timeline\\script.save.mst":[function(require,module,exports){
module.exports = ";(function (root) {\n    'use strict';\n\n    {{#saveJson}}\n    /**@amsave*/\n    var SAVEJSON = '{{{saveJson}}}';\n    {{/saveJson}}\n\n    var sequPlayerGens = [{{{sequPlayerGens}}}];\n\n    root.am = root.am || {};\n    root.am.pageScripts = root.am.pageScripts || {};\n\n    var reg = root.am.pageScripts.{{name}} = {\n        \n        createPlayer: function (opt) {\n\n            var sequencePlayers = [];\n\n            sequPlayerGens.forEach(function (create) {\n\n                sequencePlayers.push(create(opt))   ;\n            });\n\n            return {\n                play: callPlayers.bind(null, 'play'),\n                pause: callPlayers.bind(null, 'pause'),\n                seek: callPlayers.bind(null, 'seek'),\n            };\n\n            function callPlayers(fnName, arg1) {\n\n                sequencePlayers.forEach(function (sequencePlayer) {\n\n                    sequencePlayer[fnName].call(null, arg1);\n                });\n            }\n        },\n        \n        {{#saveJson}}\n        saveJson: SAVEJSON,\n        {{/saveJson}}\n    };\n\n\n    if (typeof define === 'function' && define.amd) {\n        \n        define(function () {\n            return reg;\n        });\n    }\n\n    if (typeof exports === 'object') {\n        \n        module.exports = reg;\n    }\n\n\n    {{#autoPlay}}\n    if (document.readyState == 'interactive' || document.readyState == 'complete') {\n\n        reg.createPlayer().play();\n    }\n    else {\n        document.addEventListener('DOMContentLoaded', function () {\n\n            reg.createPlayer().play();\n        });\n    }\n    {{/autoPlay}}\n}(this));";

},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\toolbar\\Toolbar.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var amgui = require('../amgui');

function Toolbar() {

    EventEmitter.call(this);

    this._height = 32;
    this._icons = [];
    this._separators = {};

    this.domElem = document.createElement('div');
    this.domElem.style.position = 'fixed';
    this.domElem.style.backgroundColor = 'darkslategrey';
    this.domElem.style.pointerEvents = 'auto';
    this.domElem.style.height = this._height + 'px';

    this.addSeparator('first');
    this.addSeparator('tools');
    this.addSeparator('handler');
    this.addSeparator('global');
    this.addSeparator('rest');
}

inherits(Toolbar, EventEmitter);
var p = Toolbar.prototype;
module.exports = Toolbar;


p.addIcon = function (opt) {

    var deIcon = opt.deIcon || amgui.createIconBtn({
        width: 32,
        height: 32,
        fontSize: '32px',
        icon: opt.icon,
        onClick: opt.onClick
    });

    if (opt.tooltip) {
        
        amgui.addTooltip({
            deTarget: deIcon,
            text: opt.tooltip,
            side: 'bottom'
        });
    }

    deIcon.style.display = 'inline-block';

    this.domElem.insertBefore(deIcon, this._separators[opt.separator || 'rest']);

    return deIcon;
};

p.removeIcon = function (deIcon) {

    deIcon.parentNode.removeChild(deIcon);
};

p.addSeparator = function (name) {

    var de = document.createElement('span');
    this.domElem.appendChild(de);
    this._separators[name] = de;
};
},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\transhand\\Transhand.js":[function(require,module,exports){
'use strict';

var Transformer = require('./hands/Transformer');
var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

function Transhand() {

    EventEmitter.call(this);

    this.hands = {};

    [Transformer].forEach(function (Hand) {

        var hand = new Hand();

        hand.on('change', this.emit.bind(this, 'change'));

        this.hands[Hand.id] = hand;
    }, this);
}

inherits(Transhand, EventEmitter);

var p = Transhand.prototype;

p.setup = function (opt) {

    var hand = this.hands[opt.hand.type];

    if (hand) {

        hand.setup(opt.hand);
        this.domElem = hand.domElem;
        this._currHand = hand;
    }
    else {
        throw 'Unknown hand type: ' + opt.hand.type;
    }

    if (typeof(opt.on) === 'object') {

        Object.keys(opt.on).forEach(function (eventType) {

            this.on(eventType, opt.on[eventType]);
        }, this);
    }
};

p.activate = function () {

    if (this._currHand) {

        this._currHand.activate();
    }
};

p.deactivate = function () {

    if (this._currHand) {

        this._currHand.deactivate();
    }
};

module.exports = Transhand;
},{"./hands/Transformer":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\transhand\\hands\\Transformer.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\transhand\\hands\\Transformer.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var _ = require('lodash');

var MOUSESTATES = {
    'move': 'move',
    'rotate': '-webkit-grab',
    'origin': 'crosshair',
    '1000': 'ns-resize',
    '1100': 'nesw-resize',
    '0100': 'ew-resize',
    '0110': 'nwse-resize',
    '0010': 'ns-resize',
    '0011': 'nesw-resize',
    '0001': 'ew-resize',
    '1001': 'nwse-resize',
};


function Transformer() {

    EventEmitter.call(this);

    this._params = {
        tx: 0, ty: 0,
        sx: 1, sy: 1,
        rz: 0,
        ox: 0.5, oy: 0.5
    };
    this._base = {x: 0, y: 0, w: 0, h: 0};
    this._points = [{}, {}, {}, {}];
    this._pOrigin = {};
    this._originRadius = 6;

    this._onDrag = this._onDrag.bind(this);
    this._onMouseUp = this._onMouseUp.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    this._onMouseDown = this._onMouseDown.bind(this);
}

Transformer.id = 'transformer';

inherits(Transformer, EventEmitter);

var p = Transformer.prototype;

p.setup = function (opt) {

    if (!this.domElem) {
        this.createGraphics();
    }

    _.extend(this._params, opt.params);
    _.extend(this._base, opt.base);
    this._refreshPoints();
    this._renderHandler();
};

p.activate = function () {

    if (this._isActivated) return;
    this._isActivated = true;

    window.addEventListener('mousemove', this._onMouseMove);
    window.addEventListener('mousedown', this._onMouseDown);
};

p.deactivate = function () {

    if (!this._isActivated) return;
    this._isActivated = false;
    
    window.removeEventListener('mousemove', this._onMouseMove);
    window.removeEventListener('mousedown', this._onMouseDown);
};

p.createGraphics = function () {

    this.domElem = document.createElement('canvas');
    this.domElem.style.position = 'fixed';
    this.domElem.style.pointerEvents = 'none';
    // this.domElem.style.border = '1px solid red';
};

p._refreshPoints = function () {

    var base = _.clone(this._base), 
        params = this._params,
        p = this._points,
        po = this._pOrigin;

    base.x += params.tx;
    base.y += params.ty;
    
    po.x = base.x + (base.w * params.ox);
    po.y = base.y + (base.h * params.oy);

    var tox = base.x + params.ox * base.w,
        toy = base.y + params.oy * base.h;

    t(p[0], base.x, base.y);
    t(p[1], base.x + base.w, base.y);
    t(p[2], base.x + base.w, base.y + base.h);
    t(p[3], base.x, base.y + base.h);

    function t(p, x, y) {

        var dx = (x - tox) * params.sx,
            dy = (y - toy) * params.sy,
            d = Math.sqrt(dx*dx + dy*dy),
            rad = Math.atan2(dy, dx) + params.rz;

        p.x = tox + (d * Math.cos(rad));
        p.y = toy + (d * Math.sin(rad));
    }
};

p._renderHandler = function () {

    var p = this._points,
        po = this._pOrigin,
        c = this.domElem,
        or = this._originRadius,
        ctx = c.getContext('2d'),
        margin = 7,
        minX = Math.min(p[0].x, p[1].x, p[2].x, p[3].x, po.x),
        maxX = Math.max(p[0].x, p[1].x, p[2].x, p[3].x, po.x),
        minY = Math.min(p[0].y, p[1].y, p[2].y, p[3].y, po.y),
        maxY = Math.max(p[0].y, p[1].y, p[2].y, p[3].y, po.y);

    c.style.left = (minX - margin) + 'px';
    c.style.top = (minY - margin) + 'px';
    c.width = (maxX - minX) + (margin * 2);
    c.height = (maxY - minY) + (margin * 2);

    ctx.save();
    ctx.translate(margin - minX, margin - minY);
    ctx.beginPath();
    ctx.moveTo(p[0].x, p[0].y);
    ctx.lineTo(p[1].x, p[1].y);
    ctx.lineTo(p[2].x, p[2].y);
    ctx.lineTo(p[3].x, p[3].y);
    ctx.closePath();

    ctx.moveTo(po.x - or, po.y);
    ctx.lineTo(po.x + or, po.y);
    ctx.moveTo(po.x, po.y - or);
    ctx.lineTo(po.x, po.y + or);
    

    // ctx.shadowColor = '#f00';
    // ctx.shadowBlur = 3;
    // ctx.shadowOffsetX = 0;
    // ctx.shadowOffsetY = 0;

    ctx.strokeStyle = '#4f2';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
};

p._onDrag = function (e) {

    var params = this._params,
        base = this._base,
        pOrigin = this._pOrigin,
        md = this._mdPos,
        finger = this._finger,
        pMouse = {x: e.clientX, y: e.clientY},
        dx = pMouse.x - md.pMouse.x,
        dy = pMouse.y - md.pMouse.y,
        alt = e.altKey,
        shift = e.shiftKey,
        change = {};

    if (finger === 'origin') {
        
        setOrigin();
    }
        
    if (finger === 'move') {

        setTransform();
    }
    
    if (finger.charAt(0) === '1') {

        setScale(-Math.PI/2, 'sy', -1);
    }

    if (finger.charAt(1) === '1') {

        setScale(0, 'sx', 1);
    }

    if (finger.charAt(2) === '1') {

        setScale(Math.PI/2, 'sy', 1);
    }

    if (finger.charAt(3) === '1') {

        setScale(Math.PI, 'sx', -1);
    }

    if (finger === 'rotate') {

        setRotation();
    }

    if (shift && 'sx' in change && 'sy' in change) {

        fixProportion();
    }


    this.emit('change', change, 'transform');





    function setScale(r, sN, way) {

        var rad = r + md.params.rz,
            mdDist = distToPointInAngle(md.pOrigin, md.pMouse, rad),
            dragDist = distToPointInAngle(md.pOrigin, pMouse, rad),
            scale = (dragDist / mdDist) * md.params[sN];

        if (alt) {
            var es = (scale - md.params[sN]) / 2,
                tN = 't' + sN.charAt(1),
                dN = sN.charAt(1) === 'x' ? 'w' : 'h';

            scale -= es;
            change[tN] = params[tN] = md.params[tN] + base[dN] * es/2 * way;            
        }

        change[sN] = params[sN] = scale;
    }

    function fixProportion() {

        var mx = pMouse.x - pOrigin.x,
            my = pMouse.y - pOrigin.y,
            mr = Math.abs(radDiff(params.rz, Math.atan2(my, mx))),
            isVertical = mr > Math.PI/4 && mr < Math.PI/4 * 3,
            spx = params.sx / md.params.sx,
            spy = params.sy / md.params.sy;

        spx *= spx < 0 ? -1 : 1;
        spy *= spy < 0 ? -1 : 1;
        
        var sp = isVertical ? spy : spx;

        change.sx = params.sx = md.params.sx * sp;
        change.sy = params.sy = md.params.sy * sp;
    }

    function setRotation() {

        var mdx = md.pMouse.x - pOrigin.x,
            mdy = md.pMouse.y - pOrigin.y,
            mdr = Math.atan2(mdy, mdx),
            mx = pMouse.x - pOrigin.x,
            my = pMouse.y - pOrigin.y,
            mr = Math.atan2(my, mx),
            r = mr - mdr;

        if (shift) {

            r = Math.floor(r / (Math.PI / 12)) * (Math.PI / 12);
        }

        change.rz = params.rz = md.params.rz + r;
    }

    function setTransform() {

        if (shift) {
            
            if (Math.abs(dx) > Math.abs(dy)) {

                change.tx = params.tx = md.params.tx + dx;
                change.ty = params.ty = md.params.ty;
            }
            else {
                change.tx = params.tx = md.params.tx;
                change.ty = params.ty = md.params.ty + dy;
            }
        }
        else {
            change.tx = params.tx = md.params.tx + dx;
            change.ty = params.ty = md.params.ty + dy;
        }
    }

    function setOrigin() {

        var mx = pMouse.x - md.pOrigin.x,
            my = pMouse.y - md.pOrigin.y,
            dist = Math.sqrt(mx*mx + my*my),
            r = Math.atan2(my, mx) - params.rz,
            x = (Math.cos(r) * dist) / params.sx,
            y = (Math.sin(r) * dist) / params.sy;

        change.ox = params.ox = md.params.ox + (x / base.w);
        change.oy = params.oy = md.params.oy + (y / base.h);
        change.tx = params.tx = md.params.tx + (mx - x);
        change.ty = params.ty = md.params.ty + (my - y);
    }
};

p._setFinger = function (e) {

    var base = this._base,
        params = this._params,
        p = this._points,
        po = this._pOrigin,
        diff = 3,
        rDiff = 16,
        mx = e.clientX,
        my = e.clientY,
        mp = {x: mx, y: my},
        dox = po.x - mx,
        doy = po.y - my,
        dOrigin = Math.sqrt(dox*dox + doy*doy),
        dTop = distToSegment(mp, p[0], p[1]),
        dLeft = distToSegment(mp, p[1], p[2]),
        dBottom = distToSegment(mp, p[2], p[3]),
        dRight = distToSegment(mp, p[3], p[0]),
        top = dTop < diff,
        left = dLeft < diff,
        bottom = dBottom < diff,
        right = dRight < diff,
        inside = isInside(mp, p),
        cursorScale;

    if (base.w * params.sx < diff * 2 && inside) {
        
        left = false;
        right = false;
    }

    if (base.h * params.sy < diff * 2 && inside) {
    
        top = false;
        bottom = false;
    }
    
    if (dOrigin < this._originRadius) {

        this._finger = 'origin';
    }
    else if (top || right || bottom || left) {

        this._finger = ('000' + (top * 1000 + left * 100 + bottom * 10 + right * 1)).substr(-4);
        cursorScale = true;
    }
    else if (inside) {

        this._finger = 'move';
    }
    else if (dTop < rDiff || dRight < rDiff || dBottom < rDiff || dLeft < rDiff) {

        this._finger = 'rotate';
    }
    else {
        this._finger = false;
    }


    if (this._finger === 'rotate') {

        this._cursorFunc = this._getRotateCursor;
    }
    else if (cursorScale) {

        this._cursorFunc = this._getScaleCursor;
    }
    else {
        this._cursorFunc = undefined;
        
        if (this._finger) {

            // this.domElem.style.pointerEvents = 'auto';
            this._setCursor(MOUSESTATES[this._finger]);
        }
        else {
            // this.domElem.style.pointerEvents = 'none';
            this._setCursor('auto');
        }
    }
};

p._setCursor = function (cursor) {

    this.domElem.style.cursor = cursor;
    document.querySelector("html").style.cursor = cursor;//hack! TODO
};

p._onMouseMove = function (e) {

    if (!this._isHandle) {
        
        if (am.isPickableDomElem(e.target)) {            

            this._setFinger(e);
        }
    }

    if (this._cursorFunc) {
        this._setCursor(this._cursorFunc(e.clientX, e.clientY));
    }
};

p._onMouseDown = function (e) {

    if (!this._finger || !am.isPickableDomElem(e.target)) {
        return;
    }

    e.stopPropagation();
    e.preventDefault();

    this._isHandle = true;

    this._mdPos = {
        pMouse: {x: e.clientX, y: e.clientY},
        params: _.cloneDeep(this._params),
        points: _.cloneDeep(this._points),
        pOrigin: _.cloneDeep(this._pOrigin)
    };

    window.addEventListener('mouseup', this._onMouseUp);
    window.addEventListener('mouseup', this._onMouseUp);
    window.addEventListener('mousemove', this._onDrag);
};

p._onMouseUp = function () {

    window.removeEventListener('mouseup', this._onMouseUp);
    window.removeEventListener('mouseleave', this._onMouseUp);
    window.removeEventListener('mousemove', this._onDrag);
    
    this._isHandle = false;
};



p._getRotateCursor = function (mx, my) {

    var r = Math.atan2(my - this._pOrigin.y, mx - this._pOrigin.x) / Math.PI * 180;
    return 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" ><path transform="rotate('+r+', 16, 16)" d="M18.907 3.238l-7.54-2.104s8.35 3.9 8.428 15.367c.08 11.794-7.807 14.49-7.807 14.49l7.363-1.725" stroke="#000" stroke-width="2.054" fill="none"/></svg>\') 16 16, auto';
};

p._getScaleCursor = (function () {

    var FINGERS = ['0100', '0110', '0010', '0011', '0001', '1001', '1000', '1100'];

    return function () {

        var rBase = FINGERS.indexOf(this._finger) * 45;

        var r = rBase + (this._params.rz / Math.PI * 180);
        return 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><path transform="rotate('+r+', 16, 16)" d="M22.406 12.552l5.88 4.18H3.677l5.728 4.36" stroke="#000" stroke-width="2.254" fill="none"/></svg>\') 16 16, auto';
    };
}());


module.exports = Transformer;




//utils/////////////////////////////////////////////////////

function radDiff(r0, r1) {

    r0 %= Math.PI;
    r1 %= Math.PI;
    r0 += Math.PI;
    r1 += Math.PI;

    return r1 - r0;
}

function sqr(x) { 
    return x * x;
}

function dist2(v, w) { 
    return sqr(v.x - w.x) + sqr(v.y - w.y);
}

function distToSegmentSquared(p, v, w) {
  var l2 = dist2(v, w);
    
  if (l2 === 0) return dist2(p, v);
    
  var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    
  if (t < 0) return dist2(p, v);
  if (t > 1) return dist2(p, w);
    
  return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
}

function distToSegment(p, v, w) { 
    return Math.sqrt(distToSegmentSquared(p, v, w));
}

function distToPointInAngle(p0, p1, rad) {

    var dx = p1.x - p0.x,
        dy = p1.y - p0.y,
        d = Math.sqrt(dx*dx + dy*dy),
        mRad = Math.atan2(dy, dx);

    rad = mRad - rad;

    // console.log('dx', dx, 'dy', dy, 'd', d, 'mRad', mRad, 'rad', rad, 'return', Math.cos(rad) * d)

    return Math.cos(rad) * d;

}

function isInside(point, vs) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    
    var x = point.x, y = point.y;
    
    var inside = false;
    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        var xi = vs[i].x, yi = vs[i].y;
        var xj = vs[j].x, yj = vs[j].y;
        
        var intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    
    return inside;
}

},{"events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js","lodash":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\lodash\\dist\\lodash.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\Warehouseman.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var WebStorageman = require('./storages/WebStorageman');
var PageScript = require('./storages/PageScript');
var Download = require('./storages/Download');
var decorDialog = require('./decorDialog');

function Warehouseeman(opt) {

    EventEmitter.call(this);

    decorDialog(this);

    opt = opt || {};

    this._storages = [];
    this.addStorage(new PageScript());
    this.addStorage(new WebStorageman());
    this.addStorage(new Download());
    // this.addStorage(new Copy());
    this.addStorage({icon: 'hdd', tooltip: 'local file system'});
    this.addStorage({icon: 'git', tooltip: 'Git'});
    this.addStorage({icon: 'evernote', tooltip: 'Evernote'});
    this.addStorage({icon: 'dropbox', tooltip: 'Dropbox'});
    this.addStorage({icon: 'history', tooltip: 'auto save'});

    this.selectStorage(this._storages[2]);
}

inherits(Warehouseeman, EventEmitter);
var p = Warehouseeman.prototype;

p.addStorage = function (storage) {

    storage.features = storage.features || {
        placeholder: true,
    };

    this._storages.push(storage);
    this.emit('changeStorages');
};

p.selectStorage = function (storage) {

    if (this._currStorage === storage) {
        return;
    }

    this._currStorage = storage;

    if (storage.features.placeholder) {

        am.dialogs.featureDoesntExist.show();
    }

    this.emit('changeCurrStorage');
};

p.save = function (name, data, path) {

    return this._currStorage.save(name, data, path);
};

p.load = function (name, path   ) {

    return this._currStorage.load(name, path);
};

p.mkdir = function (path) {

    return this._currStorage.mkdir(path);
};

p.dir = function (path) {

    return this._currStorage.dir(path);
};

module.exports = Warehouseeman;


},{"./decorDialog":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\decorDialog.js","./storages/Download":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\storages\\Download.js","./storages/PageScript":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\storages\\PageScript.js","./storages/WebStorageman":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\storages\\WebStorageman.js","events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\decorDialog.js":[function(require,module,exports){
'use strict';

var amgui = require('../amgui');

function decorDialog(whm) {

    var dialog, deRoot, deLeft, deHead, deBreadcrumbs, inpName, 
        deStorageSelector, deDirectory, btnNewFolder, isInited, deOptions,
        selectedPath = '', selectedName = '', selectedData = '',
        openOptions = {}, mode;



    whm.showSaveDialog = function(opt) {

        init();

        openOptions = opt;
        mode = 'save';

        selectedName = opt.name || '';
        selectedData = opt.data || '';
        selectedPath = opt.path || '';

        inpName.style.display = 'block';

        dialog.setTitle('Save');
        dialog.setButtons(['save', 'close']);
        deStorageSelector.refresh();
        refresh();
        dialog.showModal();
    };

    whm.showOpenDialog = function(opt) {

        init();

        openOptions = opt;
        mode = 'open';

        selectedName = opt.name || '';
        selectedPath = opt.path || '';

        inpName.style.display = 'none';

        dialog.setTitle('Open');
        dialog.setButtons(['open', 'close']);
        deStorageSelector.refresh();
        refresh();
        dialog.showModal();
    };

    whm.setSaveOtions = function (opt) {

        deOptions.setOptions(opt);
    };

    whm.getSaveOptions = function () {

        return deOptions.getOptions();
    };

    function feature(name) {

        return whm._currStorage.features &&
            whm._currStorage.features[name];
    }


    function onChangeCurrStorage() {

        refresh();
    }

    function refresh() {

        deBreadcrumbs.refresh();
        deDirectory.refresh();
        deStorageSelector.refreshSelection();
        inpName.refresh();

        showHide(deDirectory, feature('browse'));
        showHide(deBreadcrumbs, feature('browse'));
        showHide(btnNewFolder, feature('mkdir'));

        function showHide(de, show) {

            de.style.display = show ? 'block' || de.baseDisplay : 'hidden';
        }
    }

    function init () {

        if (isInited) {
            return;
        }
        isInited = true;

        createDialog();
        createStorageSelector();
        createBreadcrumbs();
        createBtnNewFolder();
        createBtnSettings();
        createNameInput();
        createDirectory();
        createOptions();

        whm.on('changeCurrStorage', onChangeCurrStorage);
    }

    function onSave() {

        var save = openOptions.getSave(),
            name = selectedName || 'anim.am.js';

        whm.save(name, save, selectedPath);

        onClose();
    }

    function onOpen() {

        var save = whm.load(selectedName, selectedPath);

        if (openOptions.onOpen) {

            openOptions.onOpen(save);
        }

        onClose();
    }

    function onClose() {

        dialog.close();
    }









    function createDialog () {

        deRoot = document.createElement('div');
        deRoot.style.width = '700px';
        deRoot.style.height = '400px';
        deRoot.style.display = 'flex';
        deRoot.style.color = 'white';

        deLeft = document.createElement('div');
        deLeft.style.height = '100%';
        deLeft.style.flex = '1';
        deLeft.style.display = 'flex';
        deLeft.style.flexDirection = 'column';
        deRoot.appendChild(deLeft);

        deHead = document.createElement('div');
        deHead.style.width = '100%';
        deHead.style.height = '21px';
        deHead.style.display = 'flex';
        deLeft.appendChild(deHead);

        dialog = amgui.createDialog({
            content: deRoot,
            parent: am.deDialogCont
        });

        dialog.addEventListener('click_save', onSave);
        dialog.addEventListener('click_open', onOpen);
        dialog.addEventListener('click_close', onClose);
    }


    function createBreadcrumbs() {

        deBreadcrumbs = document.createElement('div');
        deBreadcrumbs.style.display = 'inline-block';
        deBreadcrumbs.style.flex = '1';
        deHead.appendChild(deBreadcrumbs);

        deBreadcrumbs.addEventListener('click', function () {

            if (this.crambValue) {

                whm.cd(this.crambValue);
            }
        });

        deBreadcrumbs.refresh = function () {

            var crumbs = selectedPath.split('/').filter(Boolean),
                value = '';

            deBreadcrumbs.innerHTML = '';
            
            createCrumb((whm._currStorage.rootName || 'root') + '://', value);

            crumbs.forEach(function (crumbName) {

                value += crumbName + '/';
                createCrumb(crumbName, value);
                createSlash();
            });
        };

        function createSlash() {

            var deSlash = createLi(' / ');
            deSlash.style.pointerEvents = 'none';

            return deSlash;
        }

        function createCrumb(content, value) {

            var deChrumb = createLi(content);
            deChrumb.style.pointerEvents = 'none';
            deChrumb.crumbValue = value;

            return deChrumb;
        }
  
        function createLi(content) {

            var li = document.createElement('span');
            li.textContent = content;

            deBreadcrumbs.appendChild(li);

            return li;
        }
    }



    function createBtnSettings() {

        btnNewFolder = amgui.createIconBtn({
            parent: deHead,
            icon: 'wrench',
            width: 21,
            onClick: function () {
                deOptions.toggle();
            }
        });
    }



    function createBtnNewFolder() {

        btnNewFolder = amgui.createIconBtn({
            parent: deHead,
            icon: 'folder-add',
            width: 21
        });
    }

    function createNameInput() {

        inpName = document.createElement('input');
        inpName.type = 'text';
        inpName.style.width = '100%';
        inpName.style.height = '21px';
        inpName.style.background = 'none';
        inpName.style.border = 'none';
        inpName.style.color = amgui.color.text;
        inpName.style.fontSize = amgui.FONT_SIZE;
        inpName.style.fontFamily = amgui.FONT_FAMILY;
        inpName.placeholder = 'File name';
        deLeft.appendChild(inpName);

        inpName.addEventListener('change', function () {

            selectedName = inpName.value;
        });

        inpName.refresh = function () {

            if (inpName.value !== selectedName) {

                inpName.value = selectedName;
            }
        };
    }


    function createDirectory() {

        deDirectory = document.createElement('div');
        deDirectory.style.listStyle = 'none';
        deDirectory.style.display = 'inline-block';
        deDirectory.style.width = '100%';
        deDirectory.style.flex = '1';
        deLeft.appendChild(deDirectory);

        deDirectory.refresh = function () {

            deDirectory.innerHTML = '';

            if (!feature('browse')) {
                return;
            }

            var list = whm.dir();

            list.forEach(function (item) {

                createItem(item.name, item.type);
            });
        };
  
        function createItem(name, type) {

            var deItem = document.createElement('div');
            deItem._value = name;
            
            amgui.createIcon({
                icon: type === 'folder' ? 'folder-empty' : 'doc',
                parent: deItem,
                display: 'inline-block'
            });

            var deName = document.createElement('span');
            deName.textContent = name;
            deItem.appendChild(deName);

            deDirectory.appendChild(deItem);

            deItem.addEventListener('click', onClick);
            deItem.addEventListener('dblclick', onClick);
            deItem.addEventListener('mouseover', onMOver);
            deItem.addEventListener('mouseout', onMOut);

            return deItem;
        }

        function onClick(e) {
            
            selectedName = this._value;

            if (e.type === 'dblclick') {

                onOpen(selectedPath, selectedName);
            }
        }

        function onMOver() {
            
            this.style.background = amgui.color.bgHover;
        }

        function onMOut() {

            this.style.background = 'none';
        }
    }




    function createStorageSelector() {

        var btnSize = 52, buttons = [];

        deStorageSelector = document.createElement('div');
        deStorageSelector.style.display = 'inline-block';
        deStorageSelector.style.width = btnSize + 'px';
        deStorageSelector.style.height = '100%';
        deRoot.insertBefore(deStorageSelector, deLeft);

        deStorageSelector.addEventListener('click', function (e) {

            var idx = e.target._storageIdx;
            
            if (idx !== undefined) {

                whm.selectStorage(whm._storages[idx]);
            }
        });

        function removeButtons() {

            buttons.forEach(function (btn) {

                if (btn.domElem.parentNode) {
                    btn.domElem.parentNode.removeChild(btn.domElem);
                }

                btn.domElem.removeEventListener('click', onClickBtn);
            });
        }

        deStorageSelector.refresh = function () {

            removeButtons();

            whm._storages.forEach(function (storage) {

                if (storage.features.placeholder || storage.features[mode]) {

                    createItem(storage);
                }
            });

            deStorageSelector.refreshSelection();
        };

        deStorageSelector.refreshSelection = function () {

            buttons.forEach(function (btn) {

                if (btn.storage === whm._currStorage) {

                    btn.domElem.fixHighlight();
                }
                else {
                    btn.domElem.removeFixHighlight();
                }
            });
        };

        function onClickBtn(e) {

            buttons.forEach(function (btn) {

                if (btn.domElem === e.currentTarget) {

                    whm.selectStorage(btn.storage);
                }
            });
        }
  
        function createItem(storage) {

            var btn = {
                domElem: amgui.createIconBtn({
                    icon: storage.icon,
                    parent: deStorageSelector,
                    width: btnSize,
                    height: btnSize,
                    display: 'inline-block',
                    onClick: onClickBtn,
                }),
                storage: storage
            };

            amgui.addTooltip({
                deTarget: btn.domElem, 
                text: storage.tooltip
            });

            buttons.push(btn);
        }
    }

    function createOptions() {

        var isOpened = false;

        deOptions = document.createElement('div');
        deOptions.style.display = 'none';
        deOptions.style.width = '138px';
        deOptions.style.height = '100%';
        deRoot.appendChild(deOptions);

        var checkSave = createCheckbox('include save', true);
        var checkMinify = createCheckbox('minify');
        var checkAuto = createCheckbox('auto play', true);

        deOptions.getOptions = function () {

            return {
                includeSave: checkSave.checked,
                minify: checkMinify.checked,
                autoPlay: checkAuto.checked
            };
        };

        deOptions.setOptions = function (opt) {

            checkSave.checked = opt.includeSave;
            checkMinify.checked = opt.minify;
            checkAuto.checked = opt.autoPlay;
        };

        deOptions.toggle = function () {

            isOpened = !isOpened;

            deOptions.style.display = isOpened ? 'block' : 'none';
        };

        function createCheckbox(name, checked) {

            var de = document.createElement('div');
            deOptions.appendChild(de);

            var cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = checked;
            de.appendChild(cb);
            
            var label = document.createElement('label');
            label.style.color = amgui.color.text;
            label.textContent = name;
            de.appendChild(label);

            return cb;
        }
    }
}


module.exports = decorDialog;


},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\storages\\Download.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

function Download(opt) {

    EventEmitter.call(this);

    opt = opt || {};

    this._root = opt.root || '_Download/';

    this.icon = 'download';
    this.tooltip = 'Download';
}

inherits(Download, EventEmitter);
var p = Download.prototype;

p.features = {
    save: true,
};

p.save = function (name, data) {

    data = 'data:application/javascript;charset=utf-8,' + encodeURIComponent(data);
    $('<a download="' + name + '" href="' + data + '"></a>')[0].click();
};

module.exports = Download;
},{"events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\storages\\PageScript.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

var FOLDERS = '<folders>';

function PageScript(opt) {

    EventEmitter.call(this);

    opt = opt || {};

    this._root = opt.root || '_PageScript/';

    this.icon = 'code';
    this.tooltip = 'running Animachine pagescripts';

    this._folders = window.localStorage.getItem(this._root + FOLDERS);
    
    try { 
        this.folders = JSON.parse(this._folders); 
    }
    catch (e) {
        this._folders = [];
    }
}

inherits(PageScript, EventEmitter);
var p = PageScript.prototype;

p.save = function (name, data, path) {

    name = this._validName(name);
    
    this.mkdir(path);
    this._set(path + name, data);

    return name;
};

p.open = function (name) {

    if (name in pageScripts()) {

        return pageScripts()[name];
    }
};

p.dir = function () {

    var ret = [];

    Object.keys(pageScripts()).forEach(function (key) {

        ret.push({
            name: key,
            type: 'file'
        });
    });

    return ret;
};

function pageScripts() {

    return (window.am && window.am.pageScripts) || [];
}

module.exports = PageScript;
},{"events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\warehouseman\\storages\\WebStorageman.js":[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

var ROOT = '_webstorageman/', 
    FOLDERS = '<folders>';

function WebStorageman(opt) {

    EventEmitter.call(this);

    opt = opt || {};

    this.icon = 'bullseye';
    this.rootName = 'webstorage';
    this.tooltip = 'webstorage, store data in your browser';

    this._folders = window.localStorage.getItem(ROOT + FOLDERS);
    
    try { 
        this._folders = JSON.parse(this._folders); 
    }
    catch (e) {}

    if (!(this._folders instanceof Array)) {

        this._folders = [];
    } 
}

inherits(WebStorageman, EventEmitter);
var p = WebStorageman.prototype;

p.features = {
    save: true,
    open: true,
    browse: true,
};


p.save = function (name, data, path) {

    name = this._validName(name);
    path = this._validPath(path);
    
    this.mkdir(path);
    this._set(path + name, data);

    return name;
};

p.load = function (name, path) {

    name = this._validName(name);
    path = this._validPath(path);
    
    return this._get(path + name);
};

p.mkdir = function (path) {

    path = this._validPath(path).split('/').filter(Boolean);

    var folderPath = '';

    path.forEach(function (folder) {

        this._addFolder(folder + '/');

    }, this);
};

p.dir = function (path) {

    path = ROOT + this._validPath(path);

    var ret = [];

    Object.keys(window.localStorage).forEach(function (key) {

        if (key.indexOf(FOLDERS) === -1) {

            testKey(key, 'file');
        }
    });

    this._folders.forEach(function (path) {

        testKey(ROOT + path.slice(0, -1), 'folder');
    });

    return ret;

    function testKey(key, type) {

        if (key.indexOf(path) === 0) {

            key = key.substr(path.length);
            
            if (key.indexOf('/') === -1) {

                ret.push({
                    name: key,
                    type: type
                });
            }
        }
    }
};

p._addFolder = function(path) {

    if (this._folders.indexOf(path) !== -1) {
        return;
    }

    this._folders.push(path);

    window.localStorage.setItem(ROOT + FOLDERS, JSON.stringify(this._folders));
};

p._set = function(path, data) {

    return window.localStorage.setItem(ROOT + path, data);
};

p._get = function(path) {

    return window.localStorage.getItem(ROOT + path);
};

p._validPath = function(path) {

    if (!path) {
        path = '';
    }

    if (path.charAt(0) === '/') {
        path = path.substr(1);
    }

    if (path.charAt(path.length-1) !== '/' && path.length) {
        path += '/';
    }

    return path;
};

p._validName = function(name) {

    return name.replace(/<|\//g, '_');
};

module.exports = WebStorageman;
},{"events":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\events\\events.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Block.js":[function(require,module,exports){
'use strict';

function Block(opt) {

    this._createDomElem();

    this.size = opt.size;
    this.scaleMode = opt.scaleMode;
}

var p = Block.prototype;

Object.defineProperties(p, {

    size: {
        set: function (v) {

            if (this._size === v) return;

            this._size = v;
            this._refresh();
        },
        get: function () {

            return this._size;
        }
    },
    scaleMode: {
        set: function (v) {

            if (this._scaleMode === v) return;

            this._scaleMode = v;
            this._refresh();
        },
        get: function () {

            return this._scaleMode;
        }
    }
});

p._refresh = function () {

    var flex = '', width = '', height = ''; 

    if (this.scaleMode === 'fix') {

        if (this._direction === 'row') {

            width = this.size + 'px'; 
        } else {
            height = this.size + 'px';
        }
    }
    else if (this.scaleMode === 'flex') {

        flex = this.size;
    }

    this.domElem.style.width = width;
    this.domElem.style.height = height;
    this.domElem.style.flex = flex;
};

p._createDomElem = function () {

    this.domElem = document.createElement('div');
    this.domElem.style.display = 'relative';
    this.domElem.style.width = '100%';
    this.domElem.style.height = '100%';
    this.domElem.style.display = 'flex';
    this.domElem.style.alignItems = 'stretch';
    this.domElem.style.pointerEvents = 'none';
};

module.exports = Block;
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Container.js":[function(require,module,exports){
'use strict';

var Block = require('./Block');
var Panel = require('./Panel');
var inherits = require('inherits');
var amgui = require('../amgui');

function Container(opt) {

    Block.call(this, opt);

    this.direction = opt.direction || 'row';
    this._children = [];
    this._deHandlers = [];

    opt.children.forEach(function (cData) {

        if (cData.type === 'container') {

            this.addChild(new Container(cData));
        }
        else if (cData.type === 'panel') {

            this.addChild(new Panel(cData));
        }
    }, this);
}

inherits(Container, Block);
var p = Container.prototype;
module.exports = Container;

Object.defineProperties(p, {

    direction: {
        set: function (v) {

            this._direction = v;
            this.domElem.style.flexDirection = this._direction;
        },
        get: function () {

            return this._direction;
        }
    }
});

p.addChild = function (child) {

    this.addChildAt(child, this._children.length);
};

p.addChildAt = function (child, idx) {

    this._children.splice(idx, 0, child);
    this._refreshChildren();
    this._refreshHandlers();
};

p.findTab = function (name) {

    var tab;

    this._children.some(function (child) {

        tab = child.findTab(name);
        return tab;
    });

    return tab;
};



p._getFullFlex = function () {

    var br = this.domElem.getBoundingClientRect(),
        full = this.direction === 'row' ? br.width : br.height;

    this._children.forEach(function (child) {

        if (child.scaleMode === 'fix') {

            full -= child.size;
        }
    });

    return full;
};

p._refreshChildren = function () {

    this._children.forEach(function (child) {
        
        this.domElem.appendChild(child.domElem);
    }, this);
};

p._refreshHandlers = function () {

    var i, deHandler, ncBr, 
        thickness = 4,
        br = this.domElem.getBoundingClientRect();

    for (i = 0; i < this._children.length - 1; ++i) {

        if (!this._deHandlers[i]) {
            this._deHandlers.push(this._createHandler())
        }

        ncBr = this._children[i+1].domElem.getBoundingClientRect();
        deHandler = this._deHandlers[i];

        if (this.direction === 'row') {

            deHandler.style.left = (ncBr.left - br.left - thickness/2) + 'px';
            deHandler.style.top = '0px';
            deHandler.style.width = thickness + 'px';
            deHandler.style.height = '100%';
        }
        else {
            deHandler.style.left = '0px';
            deHandler.style.top = (ncBr.top - br.top - thickness/2) + 'px';
            deHandler.style.width = '100%';
            deHandler.style.height = thickness + 'px';
        }
    }

    this._deHandlers.splice(i).forEach(function (deHandler) {

        deHandler.parentNode.removeChild(deHandler);
    })
};






p._onDragHandler = function (md, mx, my) {

    var move = this.direction === 'row' ? mx - md.mx : my - md.my,
        moveFlex = move / this._getFullFlex(),
        prevChild = this._children[md.idx],
        nextChild = this._children[md.idx + 1];

    prevChild.size = md.prevChildSize - (prevChild.scaleMode === 'fix' ? move : moveFlex);
    nextChild.size = md.nextChildSize - (nextChild.scaleMode === 'fix' ? move : moveFlex);
}




p._createHandler = function () {

    var de = document.createElement('div');
    de.style.position = 'absolute';

    amgui.makeDraggable({
        deTarget: de,
        thisArg: this,
        onDown: function () {
            return {
                idx: this._deHandlers.indexOf(de)
            }
        },
        onMove: this._onDragHandler,
        onEnter: function () {
            de.style.background = '#fff';
        },
        onLeave: function () {
            de.style.background = '';
        }
    });

    this.domElem.appendChild(de);

    return de;
};

},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./Block":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Block.js","./Panel":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Panel.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Panel.js":[function(require,module,exports){
'use strict';

var Tab = require('./Tab');
var amgui = require('../amgui');
var Block = require('./Block');
var inherits = require('inherits');

function Panel(opt) {

    Block.call(this, opt);

    this._tabs = [];

    this._createTabBase();

    this._empty = false;
    this._collapsed = false;
    this._noHead = true;

    if ('empty' in opt) this.empty = opt.empty;
    if ('collapsed' in opt) this.collapsed = opt.collapsed;
    if ('noHead' in opt) this.noHead = opt.noHead;

    if (opt.tabs) {
        opt.tabs.forEach(this.addTab, this);
    }

    if (!this._tabs.some(function (tab) {return tab.selected;}) &&
        this._tabs.length)
    {
        this._tabs[0].select();
    }
}

inherits(Panel, Block);
var p = Panel.prototype;
module.exports = Panel;

Object.defineProperties(p, {

    empty: {
        set: function (v) {

            v = !!v;
            if (this._empty === v) return;

            this._empty = v;
            this.domElem.style.pointerEvents = this._empty ? 'none' : 'auto';
            this.domElem.style.visibility = this._empty ? 'hidden' : 'visibile';
        },
        get: function () {
            return this._empty;
        }
    },
    
    collapsed: {
        set: function (v) {

            v = !!v;
            if (this._collapsed === v) return;

            this._collapsed = v;
            this._deTabBase.style.display = this._collapsed ? 'none' : 'flex';
        },
        get: function () {
            return this._collapsed;
        }
    },
    
    noHead: {
        set: function (v) {

            v = !!v;
            if (this._noHead === v) return;

            this._noHead = v;
            this._deTabHead.style.display = this._noHead ? 'none' : 'flex';
        },
        get: function () {
            return this._noHead;
        }
    }
});

p.addTab = function (tData) {

    var tab = new Tab(tData);
    this._deTabHead.appendChild(tab.deEar);
    this._deTabContent.appendChild(tab.domElem);
    this._tabs.push(tab);
};


p.findTab = function (name) {

    var tab;

    this._tabs.some(function (t) {

        if (t.name === name) {

            return (tab = t);
        }
    });

    return tab;
};

p.showTab = function (tab) {

    this._tabs.forEach(function (t) {
        
        if (tab === t) {
            t.select();
        }
        else {
            t.deselect();
        }
    });
};

p._createTabBase = function () {

    this._deTabBase = document.createElement('div');
    this._deTabBase.style.width = '100%';
    this._deTabBase.style.height = '100%';
    this._deTabBase.style.display = 'flex';
    this._deTabBase.style.flexDirection = 'column';
    this.domElem.appendChild(this._deTabBase);

    this._deTabHead = document.createElement('div');
    this._deTabHead.style.width = '100%';
    this._deTabHead.style.height = '23px';
    this._deTabHead.style.display = 'flex';
    this._deTabHead.style.alignItems = 'stretch';
    this._deTabHead.style.background = amgui.color.bg1;
    if (this._showHead) {
        this._deTabBase.appendChild(this._deTabHead);
    }

    this._deTabContent = document.createElement('div');
    this._deTabContent.style.width = '100%';
    this._deTabContent.style.flex = 1;
    this._deTabBase.appendChild(this._deTabContent);
};
},{"../amgui":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\amgui\\amgui.js","./Block":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Block.js","./Tab":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Tab.js","inherits":"c:\\Users\\Andras\\Downloads\\animachine\\node_modules\\inherits\\inherits_browser.js"}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Tab.js":[function(require,module,exports){
'use strict';

function Tab(opt) {

    this.name = opt.name;
    this.selected = opt.selected;

    this._createDomElem();
    this.deEar = this._createTabEar();

    this[this.selected ? 'select' : 'deselect']();
}

var p = Tab.prototype;

p.setContent = function (deContent) {

    this.domElem.innerHTML = '';
    this.domElem.appendChild(deContent);
};

p.select = function () {

    this.domElem.style.display = 'block';
    this.deEar.style.borderBottomWidth = '2px';
};

p.deselect = function () {

    this.domElem.style.display = 'none';
    this.deEar.style.borderBottomWidth = '1px';
};

p._createDomElem = function () {

    this.domElem = document.createElement('div');
    this.domElem.style.width = '100%';
    this.domElem.style.height = '100%';
    this.domElem.style.background = 'rgba(0,0,0,0.3)';
    this.domElem.style.pointerEvents = 'auto';
};

p._createTabEar = function () {

    var de = document.createElement('div');
    de.textContent = this.name;
    de.style.flex = 1;
    de.style.boxSizing = 'border-box';
    de.style.borderBottom = 'solid 1px white';
    de.style.alignItems = 'stretch';

    return de;
};

module.exports = Tab;
},{}],"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Windooman.js":[function(require,module,exports){
'use strict';

var Container = require('./Container');

function Windooman() {

    this._tabMap = {};
    this._workspaces = {};

    this._createDomElem();
}

var p = Windooman.prototype;

p.loadWorkspaces = function (workspaces) {

    Object.keys(workspaces).forEach(function (name) {

        this._workspaces[name] = workspaces[name];
    }, this);
};

p.load = function (name) {

    var map = this._workspaces[name];

    if (!map || map.type !== 'container') {
        throw Error('can\'t load ' + map);
    }

    this._root = new Container(map);
    
    this.domElem.innerHTML = '';
    this.domElem.appendChild(this._root.domElem);

    Object.keys(this._tabMap).forEach(function (name) {

        this.placeTab(name, this._tabMap[name]);
    }, this);
};

p.findTab = function (name) {

    if (this._root) {

        return this._root.findTab(name);
    }
};

p.fillTab = function (name, content) {

    this._tabMap[name] = content;

    var tab = this.findTab(name);

    if (tab) {
        tab.setContent(content);
    }
};

p._createDomElem = function () {

    this.domElem = document.createElement('div');
    this.domElem.style.width = '100%';
    this.domElem.style.height = '100%';
};

p._calcBorders = function () {
};

module.exports = Windooman;
},{"./Container":"c:\\Users\\Andras\\Downloads\\animachine\\src\\editor\\windooman\\Container.js"}]},{},["./src/editor/main.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6XFxVc2Vyc1xcQW5kcmFzXFxEb3dubG9hZHNcXGFuaW1hY2hpbmVcXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwiLi9zcmMvZWRpdG9yL21haW4uanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9kaXN0L2xvZGFzaC5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYXJyYXktc2V0LmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LXZscS5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2JpbmFyeS1zZWFyY2guanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL25vZGVfbW9kdWxlcy91Z2xpZnktanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2Utbm9kZS5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9ub2RlX21vZHVsZXMvdWdsaWZ5LWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3V0aWwuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvbm9kZV9tb2R1bGVzL3VnbGlmeS1qcy90b29scy9ub2RlLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW0uY3NzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW1ndWkvYW1ndWkuYmV6aWVyRWRpdG9yLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW1ndWkvYW1ndWkuYnV0dG9uLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW1ndWkvYW1ndWkuZGlhbG9nLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW1ndWkvYW1ndWkuZHJvcGRvd24uanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci9hbWd1aS9hbWd1aS5pbnB1dC5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL2FtZ3VpL2FtZ3VpLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW1ndWkvYW1ndWkua2V5VmFsdWVJbnB1dC5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL2FtZ3VpL2FtZ3VpLmtleXMuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci9hbWd1aS9hbWd1aS5tYWtlRHJhZ2dhYmxlLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW1ndWkvYW1ndWkuc2Nyb2xsLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYW1ndWkvYW1ndWkudG9vbHRpcC5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL2FtZ3VpL2FtZ3VpLnV0aWxzLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvYXNzZXRzL2ZvbnRlbGxvL2NvbmZpZy5qc29uIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvY2hyb25pY2xlci9DaHJvbmljbGVyLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvY29tbW9uRGlhbG9ncy9kaWFsb2dGZWF0dXJlRG9lc250RXhpdHMuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci9jb21tb25EaWFsb2dzL2RpYWxvZ0ZlZWRiYWNrLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvZG9tLXBpY2tlci9Eb21QaWNrZXIuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci9tb2R1bGVzL2Nzcy9Dc3NQYXJhbWV0ZXIuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci9tb2R1bGVzL2Nzcy9Dc3NTZXF1ZW5jZS5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvY3NzL0Nzc1RyYW5zZm9ybVBhcmFtZXRlci5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvY3NzL0tleS5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvY3NzL2Nzc01vZHVsZS5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvY3NzL2RpYWxvZ0tleU9wdGlvbnMuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci9tb2R1bGVzL2Nzcy9kaWFsb2dTZXF1T3B0aW9ucy5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvY3NzL3NjcmlwdC5wbGF5ZXIubXN0IiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvbW9kdWxlcy9jc3MvdW5jYWxjLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvbW9kdWxlcy9qYXZhc2NyaXB0L0ludGVydmFsLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvbW9kdWxlcy9qYXZhc2NyaXB0L0ludGVydmFsU2NyaXB0LmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvbW9kdWxlcy9qYXZhc2NyaXB0L0pzU2VxdWVuY2UuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci9tb2R1bGVzL2phdmFzY3JpcHQvTW9tZW50U2NyaXB0LmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvbW9kdWxlcy9qYXZhc2NyaXB0L2RpYWxvZ1NjcmlwdEVkaXRvci5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvamF2YXNjcmlwdC9kaWFsb2dTZXF1T3B0aW9ucy5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvamF2YXNjcmlwdC9qc01vZHVsZS5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vZHVsZXMvamF2YXNjcmlwdC9zY3JpcHQucGxheWVyLm1zdCIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL21vdXNlL01vdXNlLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvcXNnZW4uanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci90aW1lbGluZS9UaW1lYmFyLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3IvdGltZWxpbmUvVGltZWxpbmUuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci90aW1lbGluZS9kZWNvclRpbWViYXJOYXZpZ2F0b3IuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci90aW1lbGluZS9taW5lU2F2ZS5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL3RpbWVsaW5lL3NjcmlwdC5zYXZlLm1zdCIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL3Rvb2xiYXIvVG9vbGJhci5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL3RyYW5zaGFuZC9UcmFuc2hhbmQuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci90cmFuc2hhbmQvaGFuZHMvVHJhbnNmb3JtZXIuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci93YXJlaG91c2VtYW4vV2FyZWhvdXNlbWFuLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3Ivd2FyZWhvdXNlbWFuL2RlY29yRGlhbG9nLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3Ivd2FyZWhvdXNlbWFuL3N0b3JhZ2VzL0Rvd25sb2FkLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3Ivd2FyZWhvdXNlbWFuL3N0b3JhZ2VzL1BhZ2VTY3JpcHQuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci93YXJlaG91c2VtYW4vc3RvcmFnZXMvV2ViU3RvcmFnZW1hbi5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL3dpbmRvb21hbi9CbG9jay5qcyIsImM6L1VzZXJzL0FuZHJhcy9Eb3dubG9hZHMvYW5pbWFjaGluZS9zcmMvZWRpdG9yL3dpbmRvb21hbi9Db250YWluZXIuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci93aW5kb29tYW4vUGFuZWwuanMiLCJjOi9Vc2Vycy9BbmRyYXMvRG93bmxvYWRzL2FuaW1hY2hpbmUvc3JjL2VkaXRvci93aW5kb29tYW4vVGFiLmpzIiwiYzovVXNlcnMvQW5kcmFzL0Rvd25sb2Fkcy9hbmltYWNoaW5lL3NyYy9lZGl0b3Ivd2luZG9vbWFuL1dpbmRvb21hbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNub05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pyUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25lQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzduQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4vYW1ndWknKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgVHJhbnNoYW5kID0gcmVxdWlyZSgnLi90cmFuc2hhbmQnKTtcbnZhciBUaW1lbGluZSA9IHJlcXVpcmUoJy4vdGltZWxpbmUnKTtcbnZhciBUb29sYmFyID0gcmVxdWlyZSgnLi90b29sYmFyJyk7XG52YXIgV2luZG9vbWFuID0gcmVxdWlyZSgnLi93aW5kb29tYW4nKTtcbnZhciBXYXJlaG91c2VtYW4gPSByZXF1aXJlKCcuL3dhcmVob3VzZW1hbicpO1xudmFyIENocm9uaWNsZXIgPSByZXF1aXJlKCcuL2Nocm9uaWNsZXInKTtcbnZhciBEb21QaWNrZXIgPSByZXF1aXJlKCcuL2RvbS1waWNrZXInKTtcbnZhciBNb3VzZSA9IHJlcXVpcmUoJy4vbW91c2UnKTtcbnZhciBkaWFsb2dGZWF0dXJlRG9lc250RXhpdHMgPSByZXF1aXJlKCcuL2NvbW1vbkRpYWxvZ3MvZGlhbG9nRmVhdHVyZURvZXNudEV4aXRzJyk7XG52YXIgZGlhbG9nRmVlZGJhY2sgPSByZXF1aXJlKCcuL2NvbW1vbkRpYWxvZ3MvZGlhbG9nRmVlZGJhY2snKTtcbnZhciBtb2R1bGVzID0ge1xuICAgIGNzczogcmVxdWlyZSgnLi9tb2R1bGVzL2NzcycpLFxuICAgIGpzOiByZXF1aXJlKCcuL21vZHVsZXMvamF2YXNjcmlwdCcpXG59O1xudmFyIGV4dGVybmFsU3R5bGVzaGVldHMgPSBbXG4gICAgLy8gcmVxdWlyZSgnLi9hc3NldHMvZm9udGVsbG8vY3NzL2FtZ3VpLmNzcycpLFxuICAgIHJlcXVpcmUoJy4vYW0uY3NzJyksXG5dO1xuXG52YXIgaXNJbml0ZWQgPSBmYWxzZSwgaGFuZGxlckJ1ZmYgPSBbXTtcblxuXG52YXIgYW0gPSB3aW5kb3cuYW0gPSBtb2R1bGUuZXhwb3J0cyA9IF8uZXh0ZW5kKG5ldyBFdmVudEVtaXR0ZXIoKSwge1xuXG4gICAgc2VxdWVuY2VUeXBlczoge30sXG5cbiAgICBzZWxlY3RlZEVsZW1lbnQ6IHVuZGVmaW5lZCxcblxuICAgIHJlZ2lzdGVyU2VxdWVuY2VUeXBlOiBmdW5jdGlvbiAoU2VxdWVuY2UsIHR5cGUpIHtcblxuICAgICAgICB0aGlzLnNlcXVlbmNlVHlwZXNbdHlwZV0gPSBTZXF1ZW5jZTtcbiAgICB9XG59KTtcblxuYW0uZ2V0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmIChoYW5kbGVyQnVmZi5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gaGFuZGxlckJ1ZmYucG9wKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaGFuZCgpO1xuICAgIH1cbn07XG5cbmFtLnRocm93SGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG5cbiAgICBoYW5kbGVyQnVmZi5wdXNoKGhhbmRsZXIpO1xufTtcblxuYW0ub3BlbiA9IGZ1bmN0aW9uIChzYXZlKSB7XG5cbiAgICBpZiAoIXdpbmRvdy5jaHJvbWUpIHtcbiAgICBcbiAgICAgICAgcmV0dXJuIGFsZXJ0VW5zdXBwb3J0ZWRCcm93c2VycygpO1xuICAgIH1cblxuICAgIGFtLl9pbml0KCk7XG5cbiAgICBpZiAoc2F2ZSkge1xuXG4gICAgICAgIGlmICh0eXBlb2Yoc2F2ZSkgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHNhdmUgPSBKU09OLnBhcnNlKHNhdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYW0udGltZWxpbmUudXNlU2F2ZShzYXZlKTtcbiAgICB9XG59O1xuXG5hbS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmIChpc0luaXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIGFtLmRpYWxvZ3MgPSB7XG4gICAgICAgIGZlYXR1cmVEb2VzbnRFeGlzdDogZGlhbG9nRmVhdHVyZURvZXNudEV4aXRzLFxuICAgICAgICBmZWVkYmFjazogZGlhbG9nRmVlZGJhY2ssXG4gICAgfTtcblxuICAgIGFtLndvcmtzcGFjZSA9IG5ldyBXaW5kb29tYW4oKTtcbiAgICBhbS53b3Jrc3BhY2UubG9hZFdvcmtzcGFjZXMoe1xuICAgICAgICBiYXNlOiBnZXRCYXNlV29ya3NwYWNlKClcbiAgICB9KTtcbiAgICBhbS53b3Jrc3BhY2UubG9hZCgnYmFzZScpO1xuXG4gICAgYW0ubW91c2UgPSBuZXcgTW91c2UoKTtcblxuICAgIGFtLnN0b3JhZ2UgPSBuZXcgV2FyZWhvdXNlbWFuKCk7XG5cbiAgICBhbS5kb21FbGVtID0gY3JlYXRlQW1Sb290KCk7XG4gICAgYW0uZGVIYW5kbGVyQ29udCA9IGNyZWF0ZUFtTGF5ZXIoKTtcbiAgICBhbS5kZUd1aUNvbnQgPSBjcmVhdGVBbUxheWVyKCk7XG4gICAgYW0uZGVEaWFsb2dDb250ID0gY3JlYXRlQW1MYXllcigpO1xuXG5cbiAgICBhbWd1aS5kZU92ZXJsYXlDb250ID0gYW0uZGVEaWFsb2dDb250O1xuXG4gICAgYW0uZGVHdWlDb250LmFwcGVuZENoaWxkKGFtLndvcmtzcGFjZS5kb21FbGVtKTtcblxuICAgIGFtLmRlUm9vdCA9IGRvY3VtZW50LmJvZHk7XG4gICAgYW0uaGlzdG9yeSA9IG5ldyBDaHJvbmljbGVyKCk7XG4gICAgYW0udG9vbGJhciA9IG5ldyBUb29sYmFyKCk7XG4gICAgYW0udGltZWxpbmUgPSBuZXcgVGltZWxpbmUoKTtcbiAgICBhbS5kb21QaWNrZXIgPSBuZXcgRG9tUGlja2VyKCk7XG5cbiAgICBhbS53b3Jrc3BhY2UuZmlsbFRhYigndG9vbHMnLCBhbS50b29sYmFyLmRvbUVsZW0pO1xuXG4gICAgYW0uZGVIYW5kbGVyQ29udC5hcHBlbmRDaGlsZChhbS5kb21QaWNrZXIuZG9tRWxlbSk7XG4gICAgYW0uZG9tUGlja2VyLm9uKCdwaWNrJywgb25TZWxlY3RXaXRoRG9tUGlja2VyKTtcblxuICAgIGFtLnRvb2xiYXIuYWRkSWNvbih7XG4gICAgICAgIHRvb2x0aXA6ICd1bmRvJyxcbiAgICAgICAgaWNvbjogJ2NjdycsXG4gICAgICAgIG9uQ2xpY2s6IGFtLmhpc3RvcnkudW5kby5iaW5kKGFtLmhpc3RvcnkpXG4gICAgfSk7XG5cbiAgICBhbS50b29sYmFyLmFkZEljb24oe1xuICAgICAgICB0b29sdGlwOiAncmVkbycsXG4gICAgICAgIGljb246ICdjdycsXG4gICAgICAgIG9uQ2xpY2s6IGFtLmhpc3RvcnkucmVkby5iaW5kKGFtLmhpc3RvcnkpXG4gICAgfSk7XG5cblxuICAgIGFtLnRvb2xiYXIuYWRkSWNvbih7XG4gICAgICAgIHRvb2x0aXA6ICdmZWVkYmFjaycsXG4gICAgICAgIGljb246ICdtZWdhcGhvbmUnLFxuICAgICAgICBzZXBhcmF0b3I6ICdyZXN0JyxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYW0uZGlhbG9ncy5mZWVkYmFjay5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbiAgICBhbS50aW1lbGluZS5kb21FbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBhbS50aW1lbGluZS5kb21FbGVtLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIGFtLnRpbWVsaW5lLmRvbUVsZW0uc3R5bGUuaGVpZ2h0ID0gJzIzMHB4JztcbiAgICBhbS50aW1lbGluZS5kb21FbGVtLnN0eWxlLmJvdHRvbSA9ICcwcHgnO1xuICAgIGFtLndvcmtzcGFjZS5maWxsVGFiKCd0aW1lbGluZScsIGFtLnRpbWVsaW5lLmRvbUVsZW0pO1xuXG4gICAgYWRkVG9nZ2xlR3VpKCk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGlja1Jvb3QpO1xuXG4gICAgT2JqZWN0LmtleXMobW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdpbml0JywgbW9kdWxlTmFtZSwgJ21vZHVsZS4uLicpO1xuXG4gICAgICAgIG1vZHVsZXNbbW9kdWxlTmFtZV0uaW5pdChhbSk7XG4gICAgfSk7XG5cbiAgICBjcmVhdGVNZW51KCk7XG4gICAgY3JlYXRlU3RhdHVzTGFiZWwoKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbnUoKSB7XG4gICAgXG4gICAgdmFyIGljb25NZW51ID0gYW0udG9vbGJhci5hZGRJY29uKHtcbiAgICAgICAgdG9vbHRpcDogJ2ZpbGUnLFxuICAgICAgICBpY29uOiAnbWVudScsXG4gICAgICAgIHNlcGFyYXRvcjogJ2dsb2JhbCcsXG4gICAgfSk7XG5cbiAgICBhbWd1aS5iaW5kRHJvcGRvd24oe1xuICAgICAgICBkZVRhcmdldDogaWNvbk1lbnUsXG4gICAgICAgIGRlTWVudTogYW1ndWkuY3JlYXRlRHJvcGRvd24oe1xuICAgICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgICAgIHt0ZXh0OiAnbmV3Jywgb25TZWxlY3Q6IG9uU2VsZWN0TmV3fSxcbiAgICAgICAgICAgICAgICB7dGV4dDogJ3NhdmUnLCBvblNlbGVjdDogb25TZWxlY3RTYXZlfSxcbiAgICAgICAgICAgICAgICB7dGV4dDogJ3NhdmVBcycsIG9uU2VsZWN0OiBvblNlbGVjdFNhdmV9LFxuICAgICAgICAgICAgICAgIHt0ZXh0OiAnb3BlbicsIG9uU2VsZWN0OiBvblNlbGVjdE9wZW59LFxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25TZWxlY3ROZXcoKSB7XG5cbiAgICAgICAgYW0udGltZWxpbmUuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblNlbGVjdFNhdmUoKSB7XG5cbiAgICAgICAgYW0uc3RvcmFnZS5zaG93U2F2ZURpYWxvZyh7XG5cbiAgICAgICAgICAgIGdldFNhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0gYW0uc3RvcmFnZS5nZXRTYXZlT3B0aW9ucygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFtLnRpbWVsaW5lLmdldFNjcmlwdChvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblNlbGVjdE9wZW4oKSB7XG5cbiAgICAgICAgYW0uc3RvcmFnZS5zaG93T3BlbkRpYWxvZyh7XG5cbiAgICAgICAgICAgIG9uT3BlbjogZnVuY3Rpb24gKHNhdmUpIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNhdmUpO1xuXG4gICAgICAgICAgICAgICAgYW0udGltZWxpbmUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBhbS50aW1lbGluZS51c2VTYXZlKHNhdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uQ2xpY2tSb290KGUpIHtcblxuICAgIGlmIChhbS5pc1BpY2thYmxlRG9tRWxlbShlLnRhcmdldCkpIHtcbiAgICAgICAgXG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gYW0uc2VsZWN0ZWRFbGVtZW50KSB7Ly9oYWNrIVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBhbS5kb21QaWNrZXIuZm9jdXNFbGVtKGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWRFbGVtZW50KHVuZGVmaW5lZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvblNlbGVjdFdpdGhEb21QaWNrZXIoZGUpIHtcblxuICAgIHNldFNlbGVjdGVkRWxlbWVudChkZSk7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkRWxlbWVudChkZSkge1xuXG4gICAgaWYgKGFtLnNlbGVjdGVkRWxlbWVudCAhPT0gZGUpIHtcblxuICAgICAgICBhbS5zZWxlY3RlZEVsZW1lbnQgPSBkZTtcbiAgICAgICAgYW0uZW1pdCgnc2VsZWN0RG9tRWxlbWVudCcsIGFtLnNlbGVjdGVkRWxlbWVudCk7XG4gICAgfVxufVxuXG5hbS5pc1BpY2thYmxlRG9tRWxlbSA9IGZ1bmN0aW9uIChkZVRlc3QpIHtcbiAgICAvL1RPRE8gdXNlIC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbigpXG4gICAgaWYgKCFkZVRlc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBzdGVwKGRlVGVzdCk7XG5cbiAgICBmdW5jdGlvbiBzdGVwKGRlKSB7XG5cbiAgICAgICAgaWYgKCFkZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGUuaGFzQXR0cmlidXRlKCdkYXRhLWFtLXBpY2snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGUuaGFzQXR0cmlidXRlKCdkYXRhLWFtLW5vcGljaycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZSAhPT0gZGVUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChkZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFtUm9vdCgpIHtcblxuICAgIC8vICQoJ2JvZHknKS5jc3MoJ29wYWNpdHknLCAuMjMpXG4gICAgICAgIC8vIC5tb3VzZWVudGVyKGZ1bmN0aW9uICgpIHskKCdib2R5JykuY3NzKCdvcGFjaXR5JywgMSl9KVxuICAgICAgICAvLyAubW91c2VsZWF2ZShmdW5jdGlvbiAoKSB7JCgnYm9keScpLmNzcygnb3BhY2l0eScsIC4yMyl9KTtcbiAgICBcbiAgICB2YXIgZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgZGUuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIGRlLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGRlLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIGRlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBkZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIGRlLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZGUuc3R5bGUud2Via3RVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGRlLnN0eWxlLmZvbnRGYW1pbHkgPSBhbWd1aS5GT05UX0ZBTUlMWTtcbiAgICBkZS5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG5cbiAgICBkZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW0tbm9waWNrJywgJycpO1xuXG4gICAgdmFyIHpJbmRleCA9IGdldE1heFpJbmRleCgpO1xuICAgIGlmICh6SW5kZXgpIHtcbiAgICAgICAgZGUuc3R5bGUuekluZGV4ID0gekluZGV4ICsgMTAwMDtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRlKTtcblxuICAgIHZhciBzciA9IGRlLmNyZWF0ZVNoYWRvd1Jvb3QoKTtcbiAgICAgICAgXG4gICAgc3IuYXBwZW5kQ2hpbGQoYW1ndWkuZ2V0U3R5bGVTaGVldCgpKTtcblxuICAgIGV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoY3NzKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICAgICAgICAvL1RPRE9cbiAgICAgICAgc3IuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAvLyBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzcjtcbiAgICAvLyByZXR1cm4gZGU7XG59XG5cbmZ1bmN0aW9uIGFkZFRvZ2dsZUd1aSgpIHtcblxuICAgIGFtLnRvb2xiYXIuYWRkSWNvbih7XG4gICAgICAgIHRvb2x0aXA6ICdzaG93L2hpZGUgZWRpdG9yJyxcbiAgICAgICAgaWNvbjogJ3Jlc2l6ZS1zbWFsbCcsXG4gICAgICAgIHNlcGFyYXRvcjogJ2ZpcnN0JyxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBhbS5kZUd1aUNvbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChidG5GdWxsKTtcblxuICAgICAgICAgICAgdmFyIHpJbmRleCA9IGdldE1heFpJbmRleCgpO1xuICAgICAgICAgICAgaWYgKHpJbmRleCkge1xuICAgICAgICAgICAgICAgIGJ0bkZ1bGwuc3R5bGUuekluZGV4ID0gekluZGV4ICsgMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGJ0bkZ1bGwgPSBhbWd1aS5jcmVhdGVJY29uQnRuKHtcbiAgICAgICAgd2lkdGg6IDMyLFxuICAgICAgICBoZWlnaHQ6IDMyLFxuICAgICAgICBmb250U2l6ZTogJzMycHgnLFxuICAgICAgICBpY29uOiAncmVzaXplLWZ1bGwnLFxuICAgICAgICB0b29sdGlwOiAnc2hvdyBlZGl0b3InLFxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGFtLmRlR3VpQ29udC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIGJ0bkZ1bGwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChidG5GdWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYnRuRnVsbC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBidG5GdWxsLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBidG5GdWxsLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW1MYXllcigpIHtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBkZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBkZS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZGUuc2V0QXR0cmlidXRlKCdkYXRhLWFtLW5vcGljaycsICcnKTtcbiAgICBhbS5kb21FbGVtLmFwcGVuZENoaWxkKGRlKTtcbiAgICByZXR1cm4gZGU7XG59XG5cblxuXG5cbmZ1bmN0aW9uIGdldE1heFpJbmRleCgpIHtcblxuICAgIHZhciB6SW5kZXggPSAwLCBlbHMsIHgsIHhMZW4sIGVsLCB2YWw7XG5cbiAgICBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG4gICAgZm9yICh4ID0gMCwgeExlbiA9IGVscy5sZW5ndGg7IHggPCB4TGVuOyB4ICs9IDEpIHtcbiAgICAgIGVsID0gZWxzW3hdO1xuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpICE9PSAnc3RhdGljJykge1xuICAgICAgICB2YWwgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnei1pbmRleCcpO1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgdmFsID0gK3ZhbDtcbiAgICAgICAgICBpZiAodmFsID4gekluZGV4KSB7XG4gICAgICAgICAgICB6SW5kZXggPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB6SW5kZXg7ICAgIFxufVxuXG5cbmZ1bmN0aW9uIGdldEJhc2VXb3Jrc3BhY2UoKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29udGFpbmVyJyxcbiAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhbmVsJyxcbiAgICAgICAgICAgICAgICBzaXplOiAzMixcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6ICdmaXgnLFxuICAgICAgICAgICAgICAgIG5vSGVhZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFiczogW3tuYW1lOiAndG9vbHMnfV0sXG4gICAgICAgICAgICB9LHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgIHNpemU6IDEwLFxuICAgICAgICAgICAgICAgIHNjYWxlTW9kZTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbeyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYW5lbCcsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlTW9kZTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICB0YWJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0NzcyBTdHlsZSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdEb20gVHJlZSd9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LCB7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhbmVsJyxcbiAgICAgICAgICAgICAgICAgICAgZW1wdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZU1vZGU6ICdmbGV4J1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhbmVsJyxcbiAgICAgICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgICAgIHNjYWxlTW9kZTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIG5vSGVhZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFiczogW3tuYW1lOiAndGltZWxpbmUnfV0sXG4gICAgICAgICAgICB9XVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXR1c0xhYmVsKCkge1xuXG4gICAgdmFyIGRlVGl0bGUgPSBhbWd1aS5jcmVhdGVMYWJlbCh7XG4gICAgICAgIGNhcHRpb246ICdBbmltYWNoaW5lIChhbHBoYSknLFxuICAgICAgICBwYXJlbnQ6IGFtLmRlRGlhbG9nQ29udCxcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIGZvbnRTaXplOiAnMThweCdcbiAgICB9KTtcblxuICAgIGRlVGl0bGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICBkZVRpdGxlLnN0eWxlLnRvcCA9ICczMnB4JztcbiAgICBkZVRpdGxlLnN0eWxlLmxlZnQgPSAnM3B4JztcbiAgICBkZVRpdGxlLnN0eWxlLm9wYWNpdHkgPSAnMC4yMyc7XG4gICAgZGVUaXRsZS5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xufVxuXG5mdW5jdGlvbiBhbGVydFVuc3VwcG9ydGVkQnJvd3NlcnMoKSB7XG5cbiAgICB2YXIgZGVTb3JyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlU29ycnkudGV4dENvbnRlbnQgPSAnU29ycnksIHRoaXMgZGVtbyBpcyBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgY2hyb21lLiAnO1xuICAgIGFtZ3VpLmNyZWF0ZUljb24oe2ljb246ICdlbW8tdW5oYXBweScsIHBhcmVudDogZGVTb3JyeSwgZGlzcGxheTogJ2lubGluZSd9KTtcbiAgICBkZVNvcnJ5LnN0eWxlLmRpc3BsYXkgPSAnZml4ZWQnO1xuICAgIGRlU29ycnkuc3R5bGUubWFyZ2luID0gJ2F1dG8nO1xuICAgIGRlU29ycnkuc3R5bGUuZm9udEZhbWlseSA9IGFtZ3VpLkZPTlRfRkFNSUxZO1xuICAgIGRlU29ycnkuc3R5bGUuZm9udFNpemUgPSAnMjFweCc7XG4gICAgZGVTb3JyeS5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgZGVTb3JyeS5zdHlsZS5iYWNrZ3JvdW5kID0gYW1ndWkuY29sb3Iub3ZlcmxheTtcbiAgICBkZVNvcnJ5LnN0eWxlLnRvcCA9IDA7XG4gICAgZGVTb3JyeS5zdHlsZS5yaWdodCA9IDA7XG4gICAgZGVTb3JyeS5zdHlsZS5ib3R0b20gPSAwO1xuICAgIGRlU29ycnkuc3R5bGUubGVmdCA9IDA7XG4gICAgZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSAnJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRlU29ycnkpO1xufVxuXG4vLy9wb2x5ZmlsbHNcbmlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmQgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIGxpc3QpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xufSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuNC4xIChDdXN0b20gQnVpbGQpIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLW8gLi9kaXN0L2xvZGFzaC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCB3aGl0ZXNwYWNlICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIHdoaXRlc3BhY2VcbiAgICAnIFxcdFxceDBCXFxmXFx4QTBcXHVmZWZmJyArXG5cbiAgICAvLyBsaW5lIHRlcm1pbmF0b3JzXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyB1bmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIEVTNiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkgKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCBzaG9ydGN1dHMgKi9cbiAgdmFyIGFyZ3NDbGFzcyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlDbGFzcyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYCAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXNcbiAgICogb3IgYGZyb21JbmRleGAgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGUuY2FjaGU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3ZhbHVlXSA/IDAgOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWU7XG4gICAgY2FjaGUgPSAoY2FjaGUgPSBjYWNoZVt0eXBlXSkgJiYgY2FjaGVba2V5XTtcblxuICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnXG4gICAgICA/IChjYWNoZSAmJiBiYXNlSW5kZXhPZihjYWNoZSwgdmFsdWUpID4gLTEgPyAwIDogLTEpXG4gICAgICA6IChjYWNoZSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIHZhbHVlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAodHlwZUNhY2hlW2tleV0gfHwgKHR5cGVDYWNoZVtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5tYXhgIGFuZCBgXy5taW5gIGFzIHRoZSBkZWZhdWx0IGNhbGxiYWNrIHdoZW4gYSBnaXZlblxuICAgKiBjb2xsZWN0aW9uIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IGZyb20gdGhlIGFycmF5IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gYXJyYXlQb29sLnBvcCgpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIG9iamVjdFBvb2wucG9wKCkgfHwge1xuICAgICAgJ2FycmF5JzogbnVsbCxcbiAgICAgICdjYWNoZSc6IG51bGwsXG4gICAgICAnY3JpdGVyaWEnOiBudWxsLFxuICAgICAgJ2ZhbHNlJzogZmFsc2UsXG4gICAgICAnaW5kZXgnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cnVlJzogZmFsc2UsXG4gICAgICAndW5kZWZpbmVkJzogZmFsc2UsXG4gICAgICAndmFsdWUnOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGJhY2sgdG8gdGhlIG9iamVjdCBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZU9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgY2FjaGUgPSBvYmplY3QuY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gICAgb2JqZWN0LmFycmF5ID0gb2JqZWN0LmNhY2hlID0gb2JqZWN0LmNyaXRlcmlhID0gb2JqZWN0Lm9iamVjdCA9IG9iamVjdC5udW1iZXIgPSBvYmplY3Quc3RyaW5nID0gb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICBpZiAob2JqZWN0UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgb2JqZWN0UG9vbC5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBub0NvbmZsaWN0YCAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICAgIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2UsXG4gICAgICAgIHVuc2hpZnQgPSBhcnJheVJlZi51bnNoaWZ0O1xuXG4gICAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJRSA4IG9ubHkgYWNjZXB0cyBET00gZWxlbWVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgICBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICAgIHZhciBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVJc05hTiA9IGNvbnRleHQuaXNOYU4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCBhIGJ1aWx0LWluIGNvbnN0cnVjdG9yIGJ5IFtbQ2xhc3NdXSAqL1xuICAgIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICAgIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gICAgY3RvckJ5Q2xhc3NbYm9vbENsYXNzXSA9IEJvb2xlYW47XG4gICAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gICAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICAgIGN0b3JCeUNsYXNzW29iamVjdENsYXNzXSA9IE9iamVjdDtcbiAgICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gICAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICAgIGN0b3JCeUNsYXNzW3N0cmluZ0NsYXNzXSA9IFN0cmluZztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICAgKiBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXNzaWduYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNoYWluYCwgYGNvbXBhY3RgLFxuICAgICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAgICogYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGlja2AsIGBwbHVja2AsIGBwdWxsYCwgYHB1c2hgLFxuICAgICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCxcbiAgICAgKiBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgICAqIGBpbmRleE9mYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgICAqIGBsYXN0SW5kZXhPZmAsIGBtaXhpbmAsIGBub0NvbmZsaWN0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAvLyBkb24ndCB3cmFwIGlmIGFscmVhZHkgd3JhcHBlZCwgZXZlbiBpZiB3cmFwcGVkIGJ5IGEgZGlmZmVyZW50IGBsb2Rhc2hgIGNvbnN0cnVjdG9yXG4gICAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgICAgPyB2YWx1ZVxuICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFzdCBwYXRoIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gICAgbG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgICB2YXIgY3RvckEgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAgICogd2l0aCBhbiBvcHRpb25hbCBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgMSAtIGBfLmJpbmRgXG4gICAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICA0IC0gYF8uY3VycnlgXG4gICAgICogIDggLSBgXy5jdXJyeWAgKGJvdW5kKVxuICAgICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsQXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICAgIGlmICghaXNCaW5kS2V5ICYmICFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsICYmICFwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgICBpc1BhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAoYmluZERhdGEgJiYgYmluZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgICAgaWYgKGJpbmREYXRhWzJdKSB7XG4gICAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmREYXRhWzNdKSB7XG4gICAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICB1bnNoaWZ0LmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBpc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYSBnaXZlbiB2YWx1ZVxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgICAqIHRoZXJlIGFyZSBubyBgT2JqZWN0LnByb3RvdHlwZWAgZXh0ZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIGN0b3IsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAvLyBhdm9pZCBub24gT2JqZWN0IG9iamVjdHMsIGBhcmd1bWVudHNgIG9iamVjdHMsIGFuZCBET00gZWxlbWVudHNcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSB8fFxuICAgICAgICAgIChjdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIGlzRnVuY3Rpb24oY3RvcikgJiYgIShjdG9yIGluc3RhbmNlb2YgY3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgdmFyIHNoaW1LZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtleXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAgICogb2YgYSB0YWcgb3IgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgICAqL1xuICAgIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiMzOTsnXG4gICAgfTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gICAgdmFyIGh0bWxVbmVzY2FwZXMgPSBpbnZlcnQoaHRtbEVzY2FwZXMpO1xuXG4gICAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzICovXG4gICAgdmFyIHJlRXNjYXBlZEh0bWwgPSBSZWdFeHAoJygnICsga2V5cyhodG1sVW5lc2NhcGVzKS5qb2luKCd8JykgKyAnKScsICdnJyksXG4gICAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cCgnWycgKyBrZXlzKGh0bWxFc2NhcGVzKS5qb2luKCcnKSArICddJywgJ2cnKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICAgKiBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnZnJlZCcgfSwgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgYSA9PSAndW5kZWZpbmVkJyA/IGIgOiBhO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIGRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrKHJlc3VsdFtpbmRleF0sIGl0ZXJhYmxlW2luZGV4XSkgOiBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIHdpbGwgYWxzb1xuICAgICAqIGJlIGNsb25lZCwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBiZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKGNoYXJhY3RlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKGNoYXJhY3RlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oe1xuICAgICAqICAgJ2Nsb25lJzogXy5wYXJ0aWFsUmlnaHQoXy5jbG9uZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICogICB9KVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZShkb2N1bWVudC5ib2R5KTtcbiAgICAgKiBjbG9uZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgXG4gICAgICAvLyBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50cyBmb3IgYGlzRGVlcGAgYW5kIGBjYWxsYmFja2BcbiAgICAgIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlXG4gICAgICogZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtLiBGdW5jdGlvbnNcbiAgICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIGNsb25lZC4gVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZFxuICAgICAqIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoY2hhcmFjdGVycyk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwgeyAnY29uc3RydWN0b3InOiBDaXJjbGUgfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgd2l0aG91dCB1c2luZyBpdHNcbiAgICAgKiAgYGtleWAgYW5kIGBvYmplY3RgIGFyZ3VtZW50cyBhcyBzb3VyY2VzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIF8uZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2luZGV4XSA9PSAndW5kZWZpbmVkJykgcmVzdWx0W2luZGV4XSA9IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCwgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duUmlnaHQob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LFxuICAgICAqIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ21vdmUnLCAneScsIGFuZCAneCcgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHBhaXJzLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2socGFpcnNbbGVuZ3RoLS1dLCBwYWlyc1tsZW5ndGhdLCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQoeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbGVuZ3RoJywgJzEnLCBhbmQgJzAnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLFxuICAgICAqIGluc3RlYWQgb2YgYW4gaW5oZXJpdGVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYga2V5IGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGFzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZlcnQoeyAnZmlyc3QnOiAnZnJlZCcsICdzZWNvbmQnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogJ2ZpcnN0JywgJ2Jhcm5leSc6ICdzZWNvbmQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZGF0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAgICogbGVuZ3RoIG9mIGAwYCBhbmQgb2JqZWN0cyB3aXRoIG5vIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvbnNpZGVyZWRcbiAgICAgKiBcImVtcHR5XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgnJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgaWYgKChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcyB8fCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IGFyZ3NDbGFzcyApIHx8XG4gICAgICAgICAgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyAmJiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3JPd24odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiB0byBjb21wYXJlIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAoYSwgYikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBjb3B5O1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBjb3B5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgd29yZHMgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXJXb3JkcyA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKHdvcmRzLCBvdGhlcldvcmRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICB2YXIgcmVHcmVldCA9IC9eKD86aGVsbG98aGkpJC9pLFxuICAgICAqICAgICAgIGFHcmVldCA9IF8uaXNTdHJpbmcoYSkgJiYgcmVHcmVldC50ZXN0KGEpLFxuICAgICAqICAgICAgIGJHcmVldCA9IF8uaXNTdHJpbmcoYikgJiYgcmVHcmVldC50ZXN0KGIpO1xuICAgICAqXG4gICAgICogICByZXR1cm4gKGFHcmVldCB8fCBiR3JlZXQpID8gKGFHcmVldCA9PSBiR3JlZXQpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYSwgYiwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMsIG9yIGNhbiBiZSBjb2VyY2VkIHRvLCBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzRmluaXRlYCB3aGljaCB3aWxsIHJldHVybiB0cnVlIGZvclxuICAgICAqIGJvb2xlYW5zIGFuZCBlbXB0eSBzdHJpbmdzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGZpbml0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKC0xMDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSkgJiYgIW5hdGl2ZUlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3QuXG4gICAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDhcbiAgICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICAgICAgcmV0dXJuICEhKHZhbHVlICYmIG9iamVjdFR5cGVzW3R5cGVvZiB2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc05hTmAgd2hpY2ggd2lsbCByZXR1cm4gYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBgTmFOYCBhcyBhIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGZcbiAgICAgIC8vIChwZXJmb3JtIHRoZSBbW0NsYXNzXV0gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUpXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogYE5hTmAgaXMgY29uc2lkZXJlZCBhIG51bWJlci4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OC41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQgKiA1KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlckNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IFNoYXBlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gICAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9mcmVkLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdmFsdWVzIG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogM30gLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXBWYWx1ZXMoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uXG4gICAgICogYW5kIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbmFtZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdiYXJuZXknIH0sXG4gICAgICogICAgIHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICdhZ2UnOiAzNiB9LFxuICAgICAqICAgICB7ICdhZ2UnOiA0MCB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UobmFtZXMsIGFnZXMpO1xuICAgICAqIC8vID0+IHsgJ2NoYXJhY3RlcnMnOiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYXBwbGUnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyRm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UoZm9vZCwgb3RoZXJGb29kLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gXy5pc0FycmF5KGEpID8gYS5jb25jYXQoYikgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90XSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqZWN0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSAyO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSAhPSAnbnVtYmVyJykge1xuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1sZW5ndGggLSAxXSwgYXJnc1tsZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UoYXJndW1lbnRzLCAxLCBsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgc3RhY2tBID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBzdGFja0IgPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2VzW2luZGV4XSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGV4Y2x1ZGluZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIHByb3BlcnRpZXMgdG8gb21pdCBvciB0aGVcbiAgICAgKiAgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aG91dCB0aGUgb21pdHRlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcic7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzID0gYmFzZURpZmZlcmVuY2UocHJvcHMsIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIGFuIG9iamVjdCdzIGtleS12YWx1ZSBwYWlycyxcbiAgICAgKiBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBjb21wb3NlZCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgcGlja2luZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCAnbmFtZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5LmNoYXJBdCgwKSAhPSAnXyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgICAgbGVuZ3RoID0gaXNPYmplY3Qob2JqZWN0KSA/IHByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWAgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgdGhyb3VnaCBhIGNhbGxiYWNrLCB3aXRoIGVhY2ggY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzcXVhcmVzID0gXy50cmFuc2Zvcm0oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXSwgZnVuY3Rpb24ocmVzdWx0LCBudW0pIHtcbiAgICAgKiAgIG51bSAqPSBudW07XG4gICAgICogICBpZiAobnVtICUgMikge1xuICAgICAqICAgICByZXR1cm4gcmVzdWx0LnB1c2gobnVtKSA8IDM7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDksIDI1XVxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICBwcm90byA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXhlcywgb3Iga2V5cywgb2YgdGhlXG4gICAgICogYGNvbGxlY3Rpb25gLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgaW5kZXhlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtpbmRleF0gVGhlIGluZGV4ZXMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogICB0byByZXRyaWV2ZSwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgcHJvdmlkZWQgaW5kZXhlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCBbMCwgMiwgNF0pO1xuICAgICAqIC8vID0+IFsnYScsICdjJywgJ2UnXVxuICAgICAqXG4gICAgICogXy5hdChbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXSwgMCwgMik7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF0KGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmdzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgbGVuZ3RoID0gKGFyZ3NbMl0gJiYgYXJnc1syXVthcmdzWzFdXSA9PT0gY29sbGVjdGlvbikgPyAxIDogcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNvbGxlY3Rpb25bcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgcHJlc2VudCBpbiBhIGNvbGxlY3Rpb24gdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRhcmdldGAgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gKGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KSA6IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCsraW5kZXggPj0gZnJvbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSB2YWx1ZSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgdmFsdWUgZm9yICoqYWxsKiogZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gISFjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAhIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdCwgZmluZFdoZXJlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoXG4gICAgICogZWxlbWVudC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogTm90ZTogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgYGxlbmd0aGAgcHJvcGVydHlcbiAgICAgKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAgICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoKGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2hSaWdodChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zICczLDIsMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2xlbmd0aF0sIGxlbmd0aCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBrZXkgPSBwcm9wcyA/IHByb3BzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IHJlc3VsdFtrZXldID0gW10pLnB1c2godmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGdpdmVuIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBrZXlzID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4QnkoY2hhcmFjdGVycywgZnVuY3Rpb24oa2V5KSB7IHRoaXMuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBuYW1lZCBieSBgbWV0aG9kTmFtZWAgb24gZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmBcbiAgICAgKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0XG4gICAgICogd2lsbCBiZSBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2UoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShjb2xsZWN0aW9uLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IChpc0Z1bmMgPyBtZXRob2ROYW1lIDogdmFsdWVbbWV0aG9kTmFtZV0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbGxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYC1JbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50ID4gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50IDwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBhbGwgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICB2YXIgcGx1Y2sgPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGEgY29sbGVjdGlvbiB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjaywgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogY2FsbGJhY2sgZXhlY3V0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGV4ZWN1dGlvbi4gSWZcbiAgICAgKiBgYWNjdW11bGF0b3JgIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgaW5pdGlhbCBgYWNjdW11bGF0b3JgIHZhbHVlLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3VtID0gXy5yZWR1Y2UoWzEsIDIsIDNdLCBmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uKSByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG5vYWNjdW0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNvbGxlY3Rpb25bKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxpc3QgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICogdmFyIGZsYXQgPSBfLnJlZHVjZVJpZ2h0KGxpc3QsIGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBhXG4gICAgICogY29sbGVjdGlvbiB0aGF0IHRoZSBjYWxsYmFjayBkb2VzICoqbm90KiogcmV0dXJuIHRydWV5IGZvci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGZhaWxlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvZGRzID0gXy5yZWplY3QoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgXG4gICAgICogIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YCBhcmd1bWVudHMgYXMgYG5gLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBjb2xsZWN0aW9uLmxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICAgKiBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCArK2luZGV4KTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnVleSB2YWx1ZSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmRcbiAgICAgKiBkb2VzIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgd2lsbCBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc29ydCBvcmRlclxuICAgICAqIG9mIGVxdWFsIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjb2xsZWN0aW9uXG4gICAgICogd2lsbCBiZSBzb3J0ZWQgYnkgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAyNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDMwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgJ2FnZScpLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMjZdLCBbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICpcbiAgICAgKiAvLyBzb3J0aW5nIGJ5IG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCBbJ25hbWUnLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPSA+IFtbJ2Jhcm5leScsIDI2XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGNhbGxiYWNrKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFsrK2luZGV4XSA9IGdldE9iamVjdCgpO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBvYmplY3QuY3JpdGVyaWEgPSBtYXAoY2FsbGJhY2ssIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKG9iamVjdC5jcml0ZXJpYSA9IGdldEFycmF5KCkpWzBdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQuc29ydChjb21wYXJlQXNjZW5kaW5nKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgICAgcmVsZWFzZUFycmF5KG9iamVjdC5jcml0ZXJpYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZU9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYGNvbGxlY3Rpb25gIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTsgfSkoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBvZiBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAgdG8gdGhlIGdpdmVuXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfV1cbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAncGV0cyc6IFsnZGlubyddIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1dXG4gICAgICovXG4gICAgdmFyIHdoZXJlID0gZmlsdGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGFsbCBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDMsIDQsIDVdLCBbNSwgMiwgMTBdKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDIwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA+IDMwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb3IgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmdcbiAgICAgKiBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkLCB0YWtlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maXJzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpcnN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkgKHRoZSBuZXN0aW5nIGNhbiBiZSB0byBhbnkgZGVwdGgpLiBJZiBgaXNTaGFsbG93YFxuICAgICAqIGlzIHRydWV5LCB0aGUgYXJyYXkgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZVxuICAgICAqIGZsYXR0ZW5pbmcuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgW1s0XV1dO1xuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzMCwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmxhdHRlbihjaGFyYWN0ZXJzLCAncGV0cycpO1xuICAgICAqIC8vID0+IFsnaG9wcHknLCAnYmFieSBwdXNzJywgJ2Rpbm8nXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTaGFsbG93ICE9ICdib29sZWFuJyAmJiBpc1NoYWxsb3cgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTaGFsbG93XSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU2hhbGxvdztcbiAgICAgICAgaXNTaGFsbG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBhcnJheSA9IG1hcChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWRcbiAgICAgKiBwcm92aWRpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YCB3aWxsIHJ1biBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyLCAzLCAzXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhXG4gICAgICogY2FsbGJhY2sgaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb21cbiAgICAgKiB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uaW5pdGlhbChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uaW5pdGlhbChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogY2FsbGJhY2sgfHwgbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHByZXNlbnQgaW4gYWxsIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIHRydXN0SW5kZXhPZiA9IGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjYWNoZXMucHVzaCh0cnVzdEluZGV4T2YgJiYgdmFsdWUubGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmXG4gICAgICAgICAgICBjcmVhdGVDYWNoZShhcmdzSW5kZXggPyBhcmdzW2FyZ3NJbmRleF0gOiBzZWVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IGFyZ3NbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWzBdO1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKHNlZW4sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgYXJnc0luZGV4ID0gYXJnc0xlbmd0aDtcbiAgICAgICAgICAoY2FjaGUgfHwgc2VlbikucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcmdzW2FyZ3NJbmRleF0sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0xlbmd0aF07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoY2FjaGVzKTtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmxhc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmxhc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgaW5kZXggKyBmcm9tSW5kZXgpIDogbmF0aXZlTWluKGZyb21JbmRleCwgaW5kZXggLSAxKSkgKyAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbChhcnJheSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYHN0b3BgIGFcbiAgICAgKiB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHR5cGVvZiBzdGVwID09ICdudW1iZXInID8gc3RlcCA6ICgrc3RlcCB8fCAxKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICAvLyB1c2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlc1xuICAgICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgdGhhdCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgIHRoaXMgbWV0aG9kIGdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvclxuICAgICAqIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZCBlbGVtZW50c1xuICAgICAqIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRyb3AsIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogbmF0aXZlTWF4KDAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYSBnaXZlbiBzb3J0ZWQgYXJyYXkgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnRcbiAgICAgKiBvcmRlciBvZiB0aGUgYXJyYXkuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzIwLCAzMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0ge1xuICAgICAqICAgJ3dvcmRUb051bWJlcic6IHsgJ3R3ZW50eSc6IDIwLCAndGhpcnR5JzogMzAsICdmb3VydHknOiA0MCwgJ2ZpZnR5JzogNTAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIGRpY3Qud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgLy8gZXhwbGljaXRseSByZWZlcmVuY2UgYGlkZW50aXR5YCBmb3IgYmV0dGVyIGlubGluaW5nIGluIEZpcmVmb3hcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpIDogaWRlbnRpdHk7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgICAgKGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWUpXG4gICAgICAgICAgPyBsb3cgPSBtaWQgKyAxXG4gICAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA1LCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIHNvcnRlZCwgcHJvdmlkaW5nXG4gICAgICogYHRydWVgIGZvciBgaXNTb3J0ZWRgIHdpbGwgdXNlIGEgZmFzdGVyIGFsZ29yaXRobS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZFxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmUgdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicgJiYgaXNTb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NvcnRlZCAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NvcnRlZF0gPT09IGFycmF5KSA/IG51bGwgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gICAgICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0pO1xuICAgICAqIC8vID0+IFszLCA1LCA0XVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDVdLCBbMiwgMywgNV0sIFszLCA0LCA1XSk7XG4gICAgICogLy8gPT4gWzEsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYmFzZVVuaXEoYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSkuY29uY2F0KGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKSlcbiAgICAgICAgICAgIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuemlwXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gQXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXAoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gbWF4KHBsdWNrKGFycmF5LCAnbGVuZ3RoJykpIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLiBQcm92aWRlXG4gICAgICogZWl0aGVyIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSwgaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gXG4gICAgICogb3IgdHdvIGFycmF5cywgb25lIG9mIGBrZXlzYCBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgb2JqZWN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGFycmF5IG9mIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgZ2l2ZW4ga2V5cyBhbmRcbiAgICAgKiAgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzID8ga2V5cy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAoIXZhbHVlcyAmJiBsZW5ndGggJiYgIWlzQXJyYXkoa2V5c1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyBgZnVuY2AsIHdpdGggIHRoZSBgdGhpc2AgYmluZGluZyBhbmRcbiAgICAgKiBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIG9ubHkgYWZ0ZXIgYmVpbmcgY2FsbGVkIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcbiAgICAgKiAgYGZ1bmNgIGlzIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnRG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdEb25lIHNhdmluZyEnLCBhZnRlciBhbGwgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMgPSBfLmJpbmQoZnVuYywgeyAnbmFtZSc6ICdmcmVkJyB9LCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE3LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCB0aGlzQXJnKVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoZnVuYywgMSwgbnVsbCwgbnVsbCwgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCB0aGUgZnVuY3Rpb24gcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgIHdpbGwgYmUgYm91bmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gW21ldGhvZE5hbWVdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvXG4gICAgICogIGJpbmQsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpOyB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnLCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpIDogZnVuY3Rpb25zKG9iamVjdCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBmdW5jc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgMSwgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZEtleWAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBib3VuZFxuICAgICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAgICogcmVmZXJlbmNlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIGh0dHA6Ly9taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnbmFtZSc6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLm5hbWUgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kS2V5KG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGtleSwgMTksIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIG9iamVjdClcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGtleSwgMywgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNdIEZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhbE5hbWVNYXAgPSB7XG4gICAgICogICAncGViYmxlcyc6ICdwZW5lbG9wZSdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgIG5hbWUgPSByZWFsTmFtZU1hcFtuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XG4gICAgICogICByZXR1cm4gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICogICByZXR1cm4gJ0hpeWEgJyArIGZvcm1hdHRlZCArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHdlbGNvbWUgPSBfLmNvbXBvc2UoZ3JlZXQsIGZvcm1hdCk7XG4gICAgICogd2VsY29tZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdIaXlhIFBlbmVsb3BlISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jc1tsZW5ndGhdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJncyA9IFtmdW5jc1tsZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cbiAgICAgKiBpbnZva2VkIGVpdGhlciBleGVjdXRlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgY2FuIGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgY29uc29sZS5sb2coYSArIGIgKyBjKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSkge1xuICAgICAgYXJpdHkgPSB0eXBlb2YgYXJpdHkgPT0gJ251bWJlcicgPyBhcml0eSA6ICgrYXJpdHkgfHwgZnVuYy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgNCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAgICAgKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICAgICAqIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb25cbiAgICAgKiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgbGF6eUxheW91dCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBleGVjdXRlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSwgZmFsc2UpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGV4ZWN1dGluZyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG4gICAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyBsb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG9yIG1vcmUgbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gbG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxheShmdW5jLCB3YWl0KSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHRcbiAgICAgKiBiYXNlZCBvbiB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBUaGUgcmVzdWx0IGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIEEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmlib25hY2NpID0gXy5tZW1vaXplKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMiA/IG4gOiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZpYm9uYWNjaSg5KVxuICAgICAqIC8vID0+IDM0XG4gICAgICpcbiAgICAgKiB2YXIgZGF0YSA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gbW9kaWZ5aW5nIHRoZSByZXN1bHQgY2FjaGVcbiAgICAgKiB2YXIgZ2V0ID0gXy5tZW1vaXplKGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGRhdGFbbmFtZV07IH0sIF8uaWRlbnRpdHkpO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKlxuICAgICAqIGdldC5jYWNoZS5wZWJibGVzLm5hbWUgPSAncGVuZWxvcGUnO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGVuZWxvcGUnLCAnYWdlJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGUsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXlQcmVmaXggKyBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSlcbiAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICA6IChjYWNoZVtrZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVkLmNhY2hlID0ge307XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBleGVjdXRlIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHMgdG9cbiAgICAgKiB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGV4ZWN1dGVzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgdmFyIHJhbixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmFuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGBmdW5jYCB2YXJpYWJsZSBzbyB0aGUgZnVuY3Rpb24gbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggYW55IGFkZGl0aW9uYWxcbiAgICAgKiBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHsgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTsgfTtcbiAgICAgKiB2YXIgaGkgPSBfLnBhcnRpYWwoZ3JlZXQsICdoaScpO1xuICAgICAqIGhpKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAxNiwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBgcGFydGlhbGAgYXJndW1lbnRzIGFyZVxuICAgICAqIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzRGVlcCA9IF8ucGFydGlhbFJpZ2h0KF8ubWVyZ2UsIF8uZGVmYXVsdHMpO1xuICAgICAqXG4gICAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAndmFyaWFibGUnOiAnZGF0YScsXG4gICAgICogICAnaW1wb3J0cyc6IHsgJ2pxJzogJCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzRGVlcChvcHRpb25zLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuICAgICAqXG4gICAgICogb3B0aW9ucy52YXJpYWJsZVxuICAgICAqIC8vID0+ICdkYXRhJ1xuICAgICAqXG4gICAgICogb3B0aW9ucy5pbXBvcnRzXG4gICAgICogLy8gPT4geyAnXyc6IF8sICdqcSc6ICQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxSaWdodChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAzMiwgbnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgb25seSBjYWxsIHRoZSBgZnVuY2AgZnVuY3Rpb25cbiAgICAgKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG9cbiAgICAgKiBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZVxuICAgICAqIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgZGVib3VuY2VPcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCBkZWJvdW5jZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgZXhlY3V0ZWQgd2l0aFxuICAgICAqIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5GcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIod3JhcHBlciwgMTYsIFt2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eVxuICAgICAqIG5hbWUgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogSWYgYGZ1bmNgIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzXG4gICAgICogdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY3JlYXRlQ2FsbGJhY2sgPSBfLndyYXAoXy5jcmVhdGVDYWxsYmFjaywgZnVuY3Rpb24oZnVuYywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhjYWxsYmFjayk7XG4gICAgICogICByZXR1cm4gIW1hdGNoID8gZnVuYyhjYWxsYmFjaywgdGhpc0FyZykgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCcgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM10gOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2FnZV9fZ3QzOCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmIChmdW5jID09IG51bGwgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIFwiXy5wbHVja1wiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmICh0eXBlICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eShmdW5jKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGtleXMoZnVuYyksXG4gICAgICAgICAga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgYSA9IGZ1bmNba2V5XTtcblxuICAgICAgLy8gaGFuZGxlIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMSAmJiBhID09PSBhICYmICFpc09iamVjdChhKSkge1xuICAgICAgICAvLyBmYXN0IHBhdGggdGhlIGNvbW1vbiBjYXNlIG9mIHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZVxuICAgICAgICAvLyBwcm9wZXJ0eSBjb250YWluaW5nIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICB2YXIgYiA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIHJldHVybiBhID09PSBiICYmIChhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYikpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwob2JqZWN0W3Byb3BzW2xlbmd0aF1dLCBmdW5jW3Byb3BzW2xlbmd0aF1dLCBudWxsLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBgJmAsIGA8YCwgYD5gLCBgXCJgLCBhbmQgYCdgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIG1ldGhvZHMgd2lsbCBiZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkIGFyZSBjaGFpbmFibGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9KTtcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gc291cmNlICYmIGZ1bmN0aW9ucyhzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZSB8fCAoIW9wdGlvbnMgJiYgIW1ldGhvZE5hbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IGxvZGFzaFdyYXBwZXI7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gbG9kYXNoO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGZ1bmN0aW9ucyhzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IG9iamVjdCxcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGN0b3IpO1xuXG4gICAgICBmb3JFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gb2JqZWN0W21ldGhvZE5hbWVdID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgY3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgICAgICBhcmdzID0gW3ZhbHVlXTtcblxuICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlc3VsdCAmJiBpc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGN0b3IocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSAnXycgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgY29udGV4dC5fID0gb2xkRGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3RhbXAgPSBfLm5vdygpO1xuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqL1xuICAgIHZhciBub3cgPSBpc05hdGl2ZShub3cgPSBEYXRlLm5vdykgJiYgbm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogSWYgYHJhZGl4YCBpcyBgdW5kZWZpbmVkYCBvciBgMGAgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgdGhlXG4gICAgICogYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBhdm9pZHMgZGlmZmVyZW5jZXMgaW4gbmF0aXZlIEVTMyBhbmQgRVM1IGBwYXJzZUludGBcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jRS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB1c2VkIHRvIGludGVycHJldCB0aGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbmV3IGludGVnZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqL1xuICAgIHZhciBwYXJzZUludCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSA9PSA4ID8gbmF0aXZlUGFyc2VJbnQgOiBmdW5jdGlvbih2YWx1ZSwgcmFkaXgpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgdGhlIEVTMyBzcGVjaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgYHBhcnNlSW50YFxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UocmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MsICcnKSA6IHZhbHVlLCByYWRpeCB8fCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFwiXy5wbHVja1wiIHN0eWxlIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRoZSBga2V5YCB2YWx1ZSBvZiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBnZXROYW1lID0gXy5wcm9wZXJ0eSgnbmFtZScpO1xuICAgICAqXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIHRydWV5IG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzIGFcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmc9ZmFsc2VdIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWluID09ICdib29sZWFuJyAmJiBub01heCkge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5vTWF4ICYmIHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBga2V5YCBvbiBgb2JqZWN0YC4gSWYgYGtleWAgaXMgYSBmdW5jdGlvblxuICAgICAqIGl0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgb2JqZWN0YCBhbmQgaXRzIHJlc3VsdCByZXR1cm5lZCxcbiAgICAgKiBlbHNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXR1cm5lZC4gSWYgYG9iamVjdGAgaXMgZmFsc2V5IHRoZW4gYHVuZGVmaW5lZGBcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdjaGVlc2UnOiAnY3J1bXBldHMnLFxuICAgICAqICAgJ3N0dWZmJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiAnbm9uc2Vuc2UnO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdjaGVlc2UnKTtcbiAgICAgKiAvLyA9PiAnY3J1bXBldHMnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdHVmZicpO1xuICAgICAqIC8vID0+ICdub25zZW5zZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IG9iamVjdFtrZXldKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1pY3JvLXRlbXBsYXRpbmcgbWV0aG9kIHRoYXQgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzXG4gICAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQsIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICAgKiBkZWJ1Z2dpbmcuIFNlZSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZTpcbiAgICAgKiBodHRwOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBqcS5lYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLm5hbWUgJT4hJywgbnVsbCwgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgIHZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZTtcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0IHx8ICcnKTtcblxuICAgICAgLy8gYXZvaWQgbWlzc2luZyBkZXBlbmRlbmNpZXMgd2hlbiBgaXRlcmF0b3JUZW1wbGF0ZWAgaXMgbm90IGRlZmluZWRcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gdmFsdWVzKGltcG9ydHMpO1xuXG4gICAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gY29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyByZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0c1xuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpblxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZSxcbiAgICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICAgIHZhcmlhYmxlID0gJ29iaic7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoICgnICsgdmFyaWFibGUgKyAnKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArIHZhcmlhYmxlICsgJykge1xcbicgK1xuICAgICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlXCIgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICdcXG4vKlxcbi8vIyBzb3VyY2VVUkw9JyArIChvcHRpb25zLnNvdXJjZVVSTCB8fCAnL2xvZGFzaC90ZW1wbGF0ZS9zb3VyY2VbJyArICh0ZW1wbGF0ZUNvdW50ZXIrKykgKyAnXScpICsgJ1xcbiovJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uKGltcG9ydHNLZXlzLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyBtYWdlLmNhc3RTcGVsbChuKTsgfSk7XG4gICAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgbiA9IChuID0gK24pID4gLTEgPyBuIDogMDtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYCB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ0ZyZWQsIEJhcm5leSAmYW1wOyBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIEJhcm5leSAmIFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlZml4ID09IG51bGwgPyAnJyA6IHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAgICogICAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAgICogICAgIC5maXJzdCgpXG4gICAgICogICAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIGB2YWx1ZWAuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZFxuICAgICAqIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW5cbiAgICAgKiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkgeyBhcnJheS5wb3AoKTsgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygnYWdlJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gemlwO1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgICBtaXhpbihsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9XG4gICAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLnRha2UgPSBmaXJzdDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmModGhpcy5fX3dyYXBwZWRfXywgbiwgZ3VhcmQpO1xuXG4gICAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSAnMi40LjEnO1xuXG4gICAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgZXhpc3Rpbmcgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gICAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICAgKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gICAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc2V0ID0ge307XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gICAqL1xuICBBcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIGlzRHVwbGljYXRlID0gdGhpcy5oYXMoYVN0cik7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gICAgfVxuICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXSA9IGlkeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgICBpZiAodGhpcy5oYXMoYVN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gICAqXG4gICAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICAgIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gICAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gICAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG4gIH07XG5cbiAgZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbiAgLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4gIC8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuICAvLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbiAgLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuICAvLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbiAgLy9cbiAgLy8gICBDb250aW51YXRpb25cbiAgLy8gICB8ICAgIFNpZ25cbiAgLy8gICB8ICAgIHxcbiAgLy8gICBWICAgIFZcbiAgLy8gICAxMDEwMTFcblxuICB2YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbiAgLy8gYmluYXJ5OiAwMTExMTFcbiAgdmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBpcyBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gICAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gICAqL1xuICBmdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICByZXR1cm4gYVZhbHVlIDwgMFxuICAgICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogaXMgcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICAgKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICAgIHJldHVybiBpc05lZ2F0aXZlXG4gICAgICA/IC1zaGlmdGVkXG4gICAgICA6IHNoaWZ0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gICAgdmFyIGRpZ2l0O1xuXG4gICAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgICBkbyB7XG4gICAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgICAgfVxuICAgICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICAgIHJldHVybiBlbmNvZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAgICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0cikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcbiAgICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChpID49IHN0ckxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgICB9XG4gICAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQXQoaSsrKSk7XG4gICAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZnJvbVZMUVNpZ25lZChyZXN1bHQpLFxuICAgICAgcmVzdDogYVN0ci5zbGljZShpKVxuICAgIH07XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgY2hhclRvSW50TWFwID0ge307XG4gIHZhciBpbnRUb0NoYXJNYXAgPSB7fTtcblxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgICAuc3BsaXQoJycpXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGNoLCBpbmRleCkge1xuICAgICAgY2hhclRvSW50TWFwW2NoXSA9IGluZGV4O1xuICAgICAgaW50VG9DaGFyTWFwW2luZGV4XSA9IGNoO1xuICAgIH0pO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZW5jb2RlKGFOdW1iZXIpIHtcbiAgICBpZiAoYU51bWJlciBpbiBpbnRUb0NoYXJNYXApIHtcbiAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbYU51bWJlcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgYU51bWJlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IHRvIGFuIGludGVnZXIuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NF9kZWNvZGUoYUNoYXIpIHtcbiAgICBpZiAoYUNoYXIgaW4gY2hhclRvSW50TWFwKSB7XG4gICAgICByZXR1cm4gY2hhclRvSW50TWFwW2FDaGFyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBhIHZhbGlkIGJhc2UgNjQgZGlnaXQ6IFwiICsgYUNoYXIpO1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgLy9cbiAgICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIC8vXG4gICAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBuZXh0XG4gICAgLy8gICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBsZXNzIHRoYW4gdGhhdCBlbGVtZW50LlxuICAgIC8vXG4gICAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgICAvLyAgICAgIGVsZW1lbnQgd2hpY2ggaXMgbGVzcyB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlXG4gICAgLy8gICAgICByZXR1cm4gbnVsbC5cbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAgIHJldHVybiBhSGF5c3RhY2tbbWlkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgLy8gYUhheXN0YWNrW21pZF0gaXMgZ3JlYXRlciB0aGFuIG91ciBuZWVkbGUuXG4gICAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gV2UgZGlkIG5vdCBmaW5kIGFuIGV4YWN0IG1hdGNoLCByZXR1cm4gdGhlIG5leHQgY2xvc2VzdCBvbmVcbiAgICAgIC8vICh0ZXJtaW5hdGlvbiBjYXNlIDIpLlxuICAgICAgcmV0dXJuIGFIYXlzdGFja1ttaWRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGFIYXlzdGFja1ttaWRdIGlzIGxlc3MgdGhhbiBvdXIgbmVlZGxlLlxuICAgICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSk7XG4gICAgICB9XG4gICAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgyKSBvciAoMykgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgICByZXR1cm4gYUxvdyA8IDBcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogYUhheXN0YWNrW2FMb3ddO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAgICogdGhlIG5leHQgbG93ZXN0IHZhbHVlIGNoZWNrZWQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAgICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICAgKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICAgKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gICAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAgICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAgICovXG4gIGV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICByZXR1cm4gYUhheXN0YWNrLmxlbmd0aCA+IDBcbiAgICAgID8gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKVxuICAgICAgOiBudWxsO1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG5cbiAgLyoqXG4gICAqIEEgU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICAgKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAgICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICAgKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gICAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgKlxuICAgKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAgICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAgICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gICAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAgICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gICAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAgIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICAgIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICAgIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gICAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAgIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAgIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzbWM7XG4gICAgfTtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBtYXBwaW5nU2VwYXJhdG9yID0gL15bLDtdLztcbiAgICAgIHZhciBzdHIgPSBhU3RyO1xuICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICB2YXIgdGVtcDtcblxuICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHIuY2hhckF0KDApID09PSAnLCcpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IHt9O1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG5cbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5fc291cmNlcy5hdChwcmV2aW91c1NvdXJjZSArIHRlbXAudmFsdWUpO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IG1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgbWFwcGluZ1NlcGFyYXRvci50ZXN0KHN0ci5jaGFyQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIW1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSB0aGlzLl9uYW1lcy5hdChwcmV2aW91c05hbWUgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvcikge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvcik7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAobWFwcGluZyAmJiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgdGhpcy5zb3VyY2VSb290KSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxpYmxlLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290KSB7XG4gICAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXJsO1xuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdFxuICAgICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QpIHtcbiAgICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuICBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAgICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICAgKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gICAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAgICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gICAqIEBwYXJhbSBhT3JkZXJcbiAgICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAgICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gICAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICAgIHZhciBtYXBwaW5ncztcbiAgICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiBzb3VyY2VSb290KSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZVxuICAgICAgICB9O1xuICAgICAgfSkuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuXG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gICAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIGlmICghYUFyZ3MpIHtcbiAgICAgIGFBcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICB9XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG5cbiAgICAgIGlmIChzb3VyY2UgJiYgIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLnB1c2goe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhU291cmNlQ29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICAgKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gICAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICAgKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAgICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICAgIGlmICghYVNvdXJjZUZpbGUpIHtcbiAgICAgICAgaWYgKCFhU291cmNlTWFwQ29uc3VtZXIuZmlsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhU291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgLy8gTWFrZSBcImFTb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgIGFTb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBhU291cmNlRmlsZSk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJhU291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gYVNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPT0gbnVsbCAmJiBtYXBwaW5nLm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlIGlkZW50aWZpZXIgbmFtZSBpZiBpdCdzIGFuIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgLy8gaW4gYm90aCBTb3VyY2VNYXBzXG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gICAqXG4gICAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAgICogICAgICB0b2tlbi5cbiAgICpcbiAgICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gICAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgICAgLy8gQ2FzZSAxLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAgICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG1hcHBpbmc7XG5cbiAgICAgIC8vIFRoZSBtYXBwaW5ncyBtdXN0IGJlIGd1YXJhbnRlZWQgdG8gYmUgaW4gc29ydGVkIG9yZGVyIGJlZm9yZSB3ZSBzdGFydFxuICAgICAgLy8gc2VyaWFsaXppbmcgdGhlbSBvciBlbHNlIHRoZSBnZW5lcmF0ZWQgbGluZSBudW1iZXJzICh3aGljaCBhcmUgZGVmaW5lZFxuICAgICAgLy8gdmlhIHRoZSAnOycgc2VwYXJhdG9ycykgd2lsbCBiZSBhbGwgbWVzc2VkIHVwLiBOb3RlOiBpdCBtaWdodCBiZSBtb3JlXG4gICAgICAvLyBwZXJmb3JtYW50IHRvIG1haW50YWluIHRoZSBzb3J0aW5nIGFzIHdlIGluc2VydCB0aGVtLCByYXRoZXIgdGhhbiBhcyB3ZVxuICAgICAgLy8gc2VyaWFsaXplIHRoZW0sIGJ1dCB0aGUgYmlnIE8gaXMgdGhlIHNhbWUgZWl0aGVyIHdheS5cbiAgICAgIHRoaXMuX21hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFwcGluZyA9IHRoaXMuX21hcHBpbmdzW2ldO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmcsIHRoaXMuX21hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG5cbiAgICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVNvdXJjZVJvb3QpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSlcbiAgICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICAgIGZpbGU6IHRoaXMuX2ZpbGUsXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290KSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbiAgdmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pL2c7XG5cbiAgLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgbmV3bGluZSwgb3IgYW55IGNoYXJhY3Rlci5cbiAgdmFyIFJFR0VYX0NIQVJBQ1RFUiA9IC9cXHJcXG58W1xcc1xcU10vZztcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09PSB1bmRlZmluZWQgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09PSB1bmRlZmluZWQgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09PSB1bmRlZmluZWQgPyBudWxsIDogYU5hbWU7XG4gICAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICpcbiAgICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKi9cbiAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIGFycmF5LCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpbmVDb250ZW50cyA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCk7XG4gICAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuICAgICAgfTtcblxuICAgICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlwiO1xuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhQ2h1bmspIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUgfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gICAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICAgKlxuICAgKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gICAgdmFyIG5ld0NoaWxkcmVuO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgICB9XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gICAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gICAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAgICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaHVuay5tYXRjaChSRUdFWF9DSEFSQUNURVIpLmZvckVhY2goZnVuY3Rpb24gKGNoLCBpZHgsIGFycmF5KSB7XG4gICAgICAgIGlmIChSRUdFWF9ORVdMSU5FLnRlc3QoY2gpKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgICAgaWYgKGlkeCArIDEgPT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gKz0gY2gubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbiAgfTtcblxuICBleHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAgICogb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gICAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAgICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbiAgdmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuXSopKD86OihcXGQrKSk/KFxcUyopJC87XG4gIHZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuICBmdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gICAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgICAgaG9zdDogbWF0Y2hbM10sXG4gICAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICAgIHBhdGg6IG1hdGNoWzVdXG4gICAgfTtcbiAgfVxuICBleHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbiAgZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICAgIHZhciB1cmwgPSAnJztcbiAgICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgdXJsICs9ICcvLyc7XG4gICAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAgICpcbiAgICogLSBSZXBsYWNlcyBjb25zZXF1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAgICpcbiAgICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gICAgdmFyIHBhdGggPSBhUGF0aDtcbiAgICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHVybC5wYXRoO1xuICAgIH1cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICAgIHVwID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgdXAtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICB9XG5cbiAgICBpZiAodXJsKSB7XG4gICAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbiAgLyoqXG4gICAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gICAqXG4gICAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gICAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICAgKiAgIGZpcnN0LlxuICAgKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAgICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gICAqICAgaXMgcmV0dXJuZWQuXG4gICAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAgICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICAgKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gICAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgICAgaWYgKGFSb290VXJsKSB7XG4gICAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gICAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgPyBhUGF0aFxuICAgICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gam9pbmVkO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgLyoqXG4gICAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAgICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuICBleHBvcnRzLnRvU2V0U3RyaW5nID0gdG9TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuIGFTdHIuc3Vic3RyKDEpO1xuICB9XG4gIGV4cG9ydHMuZnJvbVNldFN0cmluZyA9IGZyb21TZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09IFwiL1wiICYmIHVybCAmJiB1cmwucGF0aCA9PSBcIi9cIikge1xuICAgICAgcmV0dXJuIGFQYXRoLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSA9PT0gMFxuICAgICAgPyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSlcbiAgICAgIDogYVBhdGg7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICB2YXIgczEgPSBhU3RyMSB8fCBcIlwiO1xuICAgIHZhciBzMiA9IGFTdHIyIHx8IFwiXCI7XG4gICAgcmV0dXJuIChzMSA+IHMyKSAtIChzMSA8IHMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcDtcblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmVcbiAgICogY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM7XG5cbn0pO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzLF9fZmlsZW5hbWUpe1xuLyoqIHZpbTogZXQ6dHM9NDpzdz00OnN0cz00XG4gKiBAbGljZW5zZSBhbWRlZmluZSAwLjEuMCBDb3B5cmlnaHQgKGMpIDIwMTEsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYW1kZWZpbmUgZm9yIGRldGFpbHNcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmaW5lIGZvciBub2RlLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgXCJtb2R1bGVcIiBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IE5vZGUgZm9yIHRoZVxuICogY3VycmVudCBtb2R1bGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVxdWlyZUZuXS4gTm9kZSdzIHJlcXVpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZS5cbiAqIEl0IG9ubHkgbmVlZHMgdG8gYmUgcGFzc2VkIGluIE5vZGUgdmVyc2lvbnMgYmVmb3JlIDAuNSwgd2hlbiBtb2R1bGUucmVxdWlyZVxuICogZGlkIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBkZWZpbmUgZnVuY3Rpb24gdGhhdCBpcyB1c2FibGUgZm9yIHRoZSBjdXJyZW50IG5vZGVcbiAqIG1vZHVsZS5cbiAqL1xuZnVuY3Rpb24gYW1kZWZpbmUobW9kdWxlLCByZXF1aXJlRm4pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmluZUNhY2hlID0ge30sXG4gICAgICAgIGxvYWRlckNhY2hlID0ge30sXG4gICAgICAgIGFscmVhZHlDYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICAgICAgbWFrZVJlcXVpcmUsIHN0cmluZ1JlcXVpcmU7XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgLiBhbmQgLi4gZnJvbSBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcbiAgICAgKiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50LCB0byBoZWxwIHdpdGggbW9kdWxlIG5hbWUgbG9va3VwcyxcbiAgICAgKiB3aGljaCBhY3QgbGlrZSBwYXRocywgYnV0IGNhbiBiZSByZW1hcHBlZC4gQnV0IHRoZSBlbmQgcmVzdWx0LFxuICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgTU9ESUZJRVMgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyeSB0aGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRG90cyhhcnkpIHtcbiAgICAgICAgdmFyIGksIHBhcnQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGFyeVtpXTsgaSs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBhcnlbaV07XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAoYXJ5WzJdID09PSAnLi4nIHx8IGFyeVswXSA9PT0gJy4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgYmFzZVBhcnRzO1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUuc3BsaXQoJy8nKSk7XG4gICAgICAgICAgICAgICAgdHJpbURvdHMoYmFzZVBhcnRzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbm9ybWFsaXplKCkgZnVuY3Rpb24gcGFzc2VkIHRvIGEgbG9hZGVyIHBsdWdpbidzXG4gICAgICogbm9ybWFsaXplIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQodmFsdWUpIHtcbiAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZC5mcm9tVGV4dCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkge1xuICAgICAgICAgICAgLy9UaGlzIG9uZSBpcyBkaWZmaWN1bHQgYmVjYXVzZSB0aGUgdGV4dCBjYW4vcHJvYmFibHkgdXNlc1xuICAgICAgICAgICAgLy9kZWZpbmUsIGFuZCBhbnkgcmVsYXRpdmUgcGF0aHMgYW5kIHJlcXVpcmVzIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAgICAgLy90byB0aGF0IGlkIHdhcyBpdCB3b3VsZCBiZSBmb3VuZCBvbiBkaXNrLiBCdXQgdGhpcyB3b3VsZCByZXF1aXJlXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcHBpbmcgYSBtb2R1bGUvcmVxdWlyZSBmYWlybHkgZGVlcGx5IGZyb20gbm9kZSBjb3JlLlxuICAgICAgICAgICAgLy9Ob3Qgc3VyZSBob3cgYmVzdCB0byBnbyBhYm91dCB0aGF0IHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgZG9lcyBub3QgaW1wbGVtZW50IGxvYWQuZnJvbVRleHQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9hZDtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFtZFJlcXVpcmUoZGVwcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1N5bmNocm9ub3VzLCBzaW5nbGUgbW9kdWxlIHJlcXVpcmUoJycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBzLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQXJyYXkgb2YgZGVwZW5kZW5jaWVzIHdpdGggYSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIC8vQ29udmVydCB0aGUgZGVwZW5kZW5jaWVzIHRvIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwTmFtZSwgcmVsSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9XYWl0IGZvciBuZXh0IHRpY2sgdG8gY2FsbCBiYWNrIHRoZSByZXF1aXJlIGNhbGwuXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGRlcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYW1kUmVxdWlyZS50b1VybCA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAgICAgaWYgKGZpbGVQYXRoLmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoZmlsZVBhdGgsIHBhdGguZGlybmFtZShtb2R1bGUuZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhbWRSZXF1aXJlO1xuICAgIH07XG5cbiAgICAvL0Zhdm9yIGV4cGxpY2l0IHZhbHVlLCBwYXNzZWQgaW4gaWYgdGhlIG1vZHVsZSB3YW50cyB0byBzdXBwb3J0IE5vZGUgMC40LlxuICAgIHJlcXVpcmVGbiA9IHJlcXVpcmVGbiB8fCBmdW5jdGlvbiByZXEoKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUucmVxdWlyZS5hcHBseShtb2R1bGUsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHIsIGUsIG0sIHJlc3VsdDtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGUgPSBsb2FkZXJDYWNoZVtpZF0gPSB7fTtcbiAgICAgICAgICAgIG0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHVyaTogX19maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9Pbmx5IHN1cHBvcnQgb25lIGRlZmluZSBjYWxsIHBlciBmaWxlXG4gICAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgd2l0aCBubyBtb2R1bGUgSUQgY2Fubm90IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBwZXIgZmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL1VzZSB0aGUgcmVhbCB2YXJpYWJsZXMgZnJvbSBub2RlXG4gICAgICAgICAgICAvL1VzZSBtb2R1bGUuZXhwb3J0cyBmb3IgZXhwb3J0cywgc2luY2VcbiAgICAgICAgICAgIC8vdGhlIGV4cG9ydHMgaW4gaGVyZSBpcyBhbWRlZmluZSBleHBvcnRzLlxuICAgICAgICAgICAgZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgICAgICAgICAgbSA9IG1vZHVsZTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIG1vZHVsZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0lmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXMsIHRoZXkgYXJlIHN0cmluZ3MsIHNvIG5lZWRcbiAgICAgICAgLy90byBjb252ZXJ0IHRoZW0gdG8gZGVwZW5kZW5jeSB2YWx1ZXMuXG4gICAgICAgIGlmIChkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcihkZXBOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9DYWxsIHRoZSBmYWN0b3J5IHdpdGggdGhlIHJpZ2h0IGRlcGVuZGVuY2llcy5cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5LmFwcGx5KG0uZXhwb3J0cywgZGVwcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXJDYWNoZVtpZF0gPSBtLmV4cG9ydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJpbmdSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgaWQsIHJlbElkKSB7XG4gICAgICAgIC8vU3BsaXQgdGhlIElEIGJ5IGEgISBzbyB0aGF0XG4gICAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoJyEnKSxcbiAgICAgICAgICAgIG9yaWdpbmFsSWQgPSBpZCxcbiAgICAgICAgICAgIHByZWZpeCwgcGx1Z2luO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG5cbiAgICAgICAgICAgIC8vU3RyYWlnaHQgbW9kdWxlIGxvb2t1cC4gSWYgaXQgaXMgb25lIG9mIHRoZSBzcGVjaWFsIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIC8vZGVhbCB3aXRoIGl0LCBvdGhlcndpc2UsIGRlbGVnYXRlIHRvIG5vZGUuXG4gICAgICAgICAgICBpZiAoaWQgPT09ICdyZXF1aXJlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdleHBvcnRzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2FkZXJDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoc3lzdGVtUmVxdWlyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtUmVxdWlyZShvcmlnaW5hbElkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vZHVsZSB3aXRoIElEOiAnICsgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVGhlcmUgaXMgYSBwbHVnaW4gaW4gcGxheS5cbiAgICAgICAgICAgIHByZWZpeCA9IGlkLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICBpZCA9IGlkLnN1YnN0cmluZyhpbmRleCArIDEsIGlkLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHBsdWdpbiA9IHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBwcmVmaXgsIHJlbElkKTtcblxuICAgICAgICAgICAgaWYgKHBsdWdpbi5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHBsdWdpbi5ub3JtYWxpemUoaWQsIG1ha2VOb3JtYWxpemUocmVsSWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9Ob3JtYWxpemUgdGhlIElEIG5vcm1hbGx5LlxuICAgICAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ubG9hZChpZCwgbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCksIG1ha2VMb2FkKGlkKSwge30pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL0NyZWF0ZSBhIGRlZmluZSBmdW5jdGlvbiBzcGVjaWZpYyB0byB0aGUgbW9kdWxlIGFza2luZyBmb3IgYW1kZWZpbmUuXG4gICAgZnVuY3Rpb24gZGVmaW5lKGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gaWQ7XG4gICAgICAgICAgICBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwcyAmJiAhQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ107XG4gICAgICAgIH1cblxuICAgICAgICAvL1NldCB1cCBwcm9wZXJ0aWVzIGZvciB0aGlzIG1vZHVsZS4gSWYgYW4gSUQsIHRoZW4gdXNlXG4gICAgICAgIC8vaW50ZXJuYWwgY2FjaGUuIElmIG5vIElELCB0aGVuIHVzZSB0aGUgZXh0ZXJuYWwgdmFyaWFibGVzXG4gICAgICAgIC8vZm9yIHRoaXMgbm9kZSBtb2R1bGUuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgLy9QdXQgdGhlIG1vZHVsZSBpbiBkZWVwIGZyZWV6ZSB1bnRpbCB0aGVyZSBpcyBhXG4gICAgICAgICAgICAvL3JlcXVpcmUgY2FsbCBmb3IgaXQuXG4gICAgICAgICAgICBkZWZpbmVDYWNoZVtpZF0gPSBbaWQsIGRlcHMsIGZhY3RvcnldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2RlZmluZS5yZXF1aXJlLCB3aGljaCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgdmFsdWVzIGluIHRoZVxuICAgIC8vY2FjaGUuIFVzZWZ1bCBmb3IgQU1EIG1vZHVsZXMgdGhhdCBhbGwgaGF2ZSBJRHMgaW4gdGhlIGZpbGUsXG4gICAgLy9idXQgbmVlZCB0byBmaW5hbGx5IGV4cG9ydCBhIHZhbHVlIHRvIG5vZGUgYmFzZWQgb24gb25lIG9mIHRob3NlXG4gICAgLy9JRHMuXG4gICAgZGVmaW5lLnJlcXVpcmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lLmFtZCA9IHt9O1xuXG4gICAgcmV0dXJuIGRlZmluZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhbWRlZmluZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksXCIvbm9kZV9tb2R1bGVzXFxcXHVnbGlmeS1qc1xcXFxub2RlX21vZHVsZXNcXFxcc291cmNlLW1hcFxcXFxub2RlX21vZHVsZXNcXFxcYW1kZWZpbmVcXFxcYW1kZWZpbmUuanNcIikiLCJ2YXIgc3lzID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgTU9aX1NvdXJjZU1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpO1xudmFyIFVnbGlmeUpTID0gZXhwb3J0cztcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGFycmF5X3RvX2hhc2goYSkge1xuICAgIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSlcbiAgICAgICAgcmV0W2FbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gc2xpY2UoYSwgc3RhcnQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSwgc3RhcnQgfHwgMCk7XG59O1xuXG5mdW5jdGlvbiBjaGFyYWN0ZXJzKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoXCJcIik7XG59O1xuXG5mdW5jdGlvbiBtZW1iZXIobmFtZSwgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgIGlmIChhcnJheVtpXSA9PSBuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gZmluZF9pZihmdW5jLCBhcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChmdW5jKGFycmF5W2ldKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiByZXBlYXRfc3RyaW5nKHN0ciwgaSkge1xuICAgIGlmIChpIDw9IDApIHJldHVybiBcIlwiO1xuICAgIGlmIChpID09IDEpIHJldHVybiBzdHI7XG4gICAgdmFyIGQgPSByZXBlYXRfc3RyaW5nKHN0ciwgaSA+PiAxKTtcbiAgICBkICs9IGQ7XG4gICAgaWYgKGkgJiAxKSBkICs9IHN0cjtcbiAgICByZXR1cm4gZDtcbn07XG5cbmZ1bmN0aW9uIERlZmF1bHRzRXJyb3IobXNnLCBkZWZzKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzLCBtc2cpO1xuICAgIHRoaXMubXNnID0gbXNnO1xuICAgIHRoaXMuZGVmcyA9IGRlZnM7XG59O1xuRGVmYXVsdHNFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5EZWZhdWx0c0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlZmF1bHRzRXJyb3I7XG5cbkRlZmF1bHRzRXJyb3IuY3JvYWsgPSBmdW5jdGlvbihtc2csIGRlZnMpIHtcbiAgICB0aHJvdyBuZXcgRGVmYXVsdHNFcnJvcihtc2csIGRlZnMpO1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdHMoYXJncywgZGVmcywgY3JvYWspIHtcbiAgICBpZiAoYXJncyA9PT0gdHJ1ZSlcbiAgICAgICAgYXJncyA9IHt9O1xuICAgIHZhciByZXQgPSBhcmdzIHx8IHt9O1xuICAgIGlmIChjcm9haykgZm9yICh2YXIgaSBpbiByZXQpIGlmIChyZXQuaGFzT3duUHJvcGVydHkoaSkgJiYgIWRlZnMuaGFzT3duUHJvcGVydHkoaSkpXG4gICAgICAgIERlZmF1bHRzRXJyb3IuY3JvYWsoXCJgXCIgKyBpICsgXCJgIGlzIG5vdCBhIHN1cHBvcnRlZCBvcHRpb25cIiwgZGVmcyk7XG4gICAgZm9yICh2YXIgaSBpbiBkZWZzKSBpZiAoZGVmcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICByZXRbaV0gPSAoYXJncyAmJiBhcmdzLmhhc093blByb3BlcnR5KGkpKSA/IGFyZ3NbaV0gOiBkZWZzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqLCBleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGV4dCkgaWYgKGV4dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBvYmpbaV0gPSBleHRbaV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBub29wKCkge307XG5cbnZhciBNQVAgPSAoZnVuY3Rpb24oKXtcbiAgICBmdW5jdGlvbiBNQVAoYSwgZiwgYmFja3dhcmRzKSB7XG4gICAgICAgIHZhciByZXQgPSBbXSwgdG9wID0gW10sIGk7XG4gICAgICAgIGZ1bmN0aW9uIGRvaXQoKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZihhW2ldLCBpKTtcbiAgICAgICAgICAgIHZhciBpc19sYXN0ID0gdmFsIGluc3RhbmNlb2YgTGFzdDtcbiAgICAgICAgICAgIGlmIChpc19sYXN0KSB2YWwgPSB2YWwudjtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBdFRvcCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC52O1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2guYXBwbHkodG9wLCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gc2tpcCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc19sYXN0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gYS5sZW5ndGg7IC0taSA+PSAwOykgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB0b3AucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gYSkgaWYgKGEuaGFzT3duUHJvcGVydHkoaSkpIGlmIChkb2l0KCkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3AuY29uY2F0KHJldCk7XG4gICAgfTtcbiAgICBNQVAuYXRfdG9wID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgQXRUb3AodmFsKSB9O1xuICAgIE1BUC5zcGxpY2UgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBTcGxpY2UodmFsKSB9O1xuICAgIE1BUC5sYXN0ID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgTGFzdCh2YWwpIH07XG4gICAgdmFyIHNraXAgPSBNQVAuc2tpcCA9IHt9O1xuICAgIGZ1bmN0aW9uIEF0VG9wKHZhbCkgeyB0aGlzLnYgPSB2YWwgfTtcbiAgICBmdW5jdGlvbiBTcGxpY2UodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgIGZ1bmN0aW9uIExhc3QodmFsKSB7IHRoaXMudiA9IHZhbCB9O1xuICAgIHJldHVybiBNQVA7XG59KSgpO1xuXG5mdW5jdGlvbiBwdXNoX3VuaXEoYXJyYXksIGVsKSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YoZWwpIDwgMClcbiAgICAgICAgYXJyYXkucHVzaChlbCk7XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdfdGVtcGxhdGUodGV4dCwgcHJvcHMpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHsoLis/KVxcfS9nLCBmdW5jdGlvbihzdHIsIHApe1xuICAgICAgICByZXR1cm4gcHJvcHNbcF07XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGVsKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZWwpIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBtZXJnZVNvcnQoYXJyYXksIGNtcCkge1xuICAgIGlmIChhcnJheS5sZW5ndGggPCAyKSByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gICAgICAgIHZhciByID0gW10sIGFpID0gMCwgYmkgPSAwLCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGFpIDwgYS5sZW5ndGggJiYgYmkgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgY21wKGFbYWldLCBiW2JpXSkgPD0gMFxuICAgICAgICAgICAgICAgID8gcltpKytdID0gYVthaSsrXVxuICAgICAgICAgICAgICAgIDogcltpKytdID0gYltiaSsrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWkgPCBhLmxlbmd0aCkgci5wdXNoLmFwcGx5KHIsIGEuc2xpY2UoYWkpKTtcbiAgICAgICAgaWYgKGJpIDwgYi5sZW5ndGgpIHIucHVzaC5hcHBseShyLCBiLnNsaWNlKGJpKSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX21zKGEpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKGEubGVuZ3RoIC8gMiksIGxlZnQgPSBhLnNsaWNlKDAsIG0pLCByaWdodCA9IGEuc2xpY2UobSk7XG4gICAgICAgIGxlZnQgPSBfbXMobGVmdCk7XG4gICAgICAgIHJpZ2h0ID0gX21zKHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBfbXMoYXJyYXkpO1xufTtcblxuZnVuY3Rpb24gc2V0X2RpZmZlcmVuY2UoYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWwpIDwgMDtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIHNldF9pbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWwpID49IDA7XG4gICAgfSk7XG59O1xuXG4vLyB0aGlzIGZ1bmN0aW9uIGlzIHRha2VuIGZyb20gQWNvcm4gWzFdLCB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2Vcbi8vIFsxXSBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29yblxuZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICAgIGlmICghKHdvcmRzIGluc3RhbmNlb2YgQXJyYXkpKSB3b3JkcyA9IHdvcmRzLnNwbGl0KFwiIFwiKTtcbiAgICB2YXIgZiA9IFwiXCIsIGNhdHMgPSBbXTtcbiAgICBvdXQ6IGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYXRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgaWYgKGNhdHNbal1bMF0ubGVuZ3RoID09IHdvcmRzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhdHNbal0ucHVzaCh3b3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXRzLnB1c2goW3dvcmRzW2ldXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT0gMSkgcmV0dXJuIGYgKz0gXCJyZXR1cm4gc3RyID09PSBcIiArIEpTT04uc3RyaW5naWZ5KGFyclswXSkgKyBcIjtcIjtcbiAgICAgICAgZiArPSBcInN3aXRjaChzdHIpe1wiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgZiArPSBcImNhc2UgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbaV0pICsgXCI6XCI7XG4gICAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiB0aHJlZSBsZW5ndGggY2F0ZWdvcmllcywgYW4gb3V0ZXJcbiAgICAvLyBzd2l0Y2ggZmlyc3QgZGlzcGF0Y2hlcyBvbiB0aGUgbGVuZ3RocywgdG8gc2F2ZSBvbiBjb21wYXJpc29ucy5cbiAgICBpZiAoY2F0cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIGNhdHMuc29ydChmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7fSk7XG4gICAgICAgIGYgKz0gXCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNhdCA9IGNhdHNbaV07XG4gICAgICAgICAgICBmICs9IFwiY2FzZSBcIiArIGNhdFswXS5sZW5ndGggKyBcIjpcIjtcbiAgICAgICAgICAgIGNvbXBhcmVUbyhjYXQpO1xuICAgICAgICB9XG4gICAgICAgIGYgKz0gXCJ9XCI7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2ltcGx5IGdlbmVyYXRlIGEgZmxhdCBgc3dpdGNoYCBzdGF0ZW1lbnQuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGFyZVRvKHdvcmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLCBmKTtcbn07XG5cbmZ1bmN0aW9uIGFsbChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KVxuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBEaWN0aW9uYXJ5KCkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG59O1xuRGljdGlvbmFyeS5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpICsrdGhpcy5fc2l6ZTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmdldChrZXkpLnB1c2godmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgWyB2YWwgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XSB9LFxuICAgIGRlbDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAtLXRoaXMuX3NpemU7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsdWVzW1wiJFwiICsga2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24oa2V5KSB7IHJldHVybiAoXCIkXCIgKyBrZXkpIGluIHRoaXMuX3ZhbHVlcyB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl92YWx1ZXMpXG4gICAgICAgICAgICBmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpO1xuICAgIH0sXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl92YWx1ZXMpXG4gICAgICAgICAgICByZXQucHVzaChmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBERUZOT0RFKHR5cGUsIHByb3BzLCBtZXRob2RzLCBiYXNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBiYXNlID0gQVNUX05vZGU7XG4gICAgaWYgKCFwcm9wcykgcHJvcHMgPSBbXTtcbiAgICBlbHNlIHByb3BzID0gcHJvcHMuc3BsaXQoL1xccysvKTtcbiAgICB2YXIgc2VsZl9wcm9wcyA9IHByb3BzO1xuICAgIGlmIChiYXNlICYmIGJhc2UuUFJPUFMpXG4gICAgICAgIHByb3BzID0gcHJvcHMuY29uY2F0KGJhc2UuUFJPUFMpO1xuICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24gQVNUX1wiICsgdHlwZSArIFwiKHByb3BzKXsgaWYgKHByb3BzKSB7IFwiO1xuICAgIGZvciAodmFyIGkgPSBwcm9wcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICBjb2RlICs9IFwidGhpcy5cIiArIHByb3BzW2ldICsgXCIgPSBwcm9wcy5cIiArIHByb3BzW2ldICsgXCI7XCI7XG4gICAgfVxuICAgIHZhciBwcm90byA9IGJhc2UgJiYgbmV3IGJhc2U7XG4gICAgaWYgKHByb3RvICYmIHByb3RvLmluaXRpYWxpemUgfHwgKG1ldGhvZHMgJiYgbWV0aG9kcy5pbml0aWFsaXplKSlcbiAgICAgICAgY29kZSArPSBcInRoaXMuaW5pdGlhbGl6ZSgpO1wiO1xuICAgIGNvZGUgKz0gXCJ9fVwiO1xuICAgIHZhciBjdG9yID0gbmV3IEZ1bmN0aW9uKGNvZGUpKCk7XG4gICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIGN0b3IuQkFTRSA9IGJhc2U7XG4gICAgfVxuICAgIGlmIChiYXNlKSBiYXNlLlNVQkNMQVNTRVMucHVzaChjdG9yKTtcbiAgICBjdG9yLnByb3RvdHlwZS5DVE9SID0gY3RvcjtcbiAgICBjdG9yLlBST1BTID0gcHJvcHMgfHwgbnVsbDtcbiAgICBjdG9yLlNFTEZfUFJPUFMgPSBzZWxmX3Byb3BzO1xuICAgIGN0b3IuU1VCQ0xBU1NFUyA9IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlLlRZUEUgPSBjdG9yLlRZUEUgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAobWV0aG9kcykgZm9yIChpIGluIG1ldGhvZHMpIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmICgvXlxcJC8udGVzdChpKSkge1xuICAgICAgICAgICAgY3RvcltpLnN1YnN0cigxKV0gPSBtZXRob2RzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGVbaV0gPSBtZXRob2RzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0b3IuREVGTUVUSE9EID0gZnVuY3Rpb24obmFtZSwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgIH07XG4gICAgcmV0dXJuIGN0b3I7XG59O1xuXG52YXIgQVNUX1Rva2VuID0gREVGTk9ERShcIlRva2VuXCIsIFwidHlwZSB2YWx1ZSBsaW5lIGNvbCBwb3MgZW5kcG9zIG5sYiBjb21tZW50c19iZWZvcmUgZmlsZVwiLCB7XG59LCBudWxsKTtcblxudmFyIEFTVF9Ob2RlID0gREVGTk9ERShcIk5vZGVcIiwgXCJzdGFydCBlbmRcIiwge1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNUT1IodGhpcyk7XG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIG9mIGFsbCBBU1Qgbm9kZXNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBzdGFydDogXCJbQVNUX1Rva2VuXSBUaGUgZmlyc3QgdG9rZW4gb2YgdGhpcyBub2RlXCIsXG4gICAgICAgIGVuZDogXCJbQVNUX1Rva2VuXSBUaGUgbGFzdCB0b2tlbiBvZiB0aGlzIG5vZGVcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMpO1xuICAgIH0sXG4gICAgd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Fsayh2aXNpdG9yKTsgLy8gbm90IHN1cmUgdGhlIGluZGlyZWN0aW9uIHdpbGwgYmUgYW55IGhlbHBcbiAgICB9XG59LCBudWxsKTtcblxuQVNUX05vZGUud2Fybl9mdW5jdGlvbiA9IG51bGw7XG5BU1RfTm9kZS53YXJuID0gZnVuY3Rpb24odHh0LCBwcm9wcykge1xuICAgIGlmIChBU1RfTm9kZS53YXJuX2Z1bmN0aW9uKVxuICAgICAgICBBU1RfTm9kZS53YXJuX2Z1bmN0aW9uKHN0cmluZ190ZW1wbGF0ZSh0eHQsIHByb3BzKSk7XG59O1xuXG4vKiAtLS0tLVsgc3RhdGVtZW50cyBdLS0tLS0gKi9cblxudmFyIEFTVF9TdGF0ZW1lbnQgPSBERUZOT0RFKFwiU3RhdGVtZW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIG9mIGFsbCBzdGF0ZW1lbnRzXCIsXG59KTtcblxudmFyIEFTVF9EZWJ1Z2dlciA9IERFRk5PREUoXCJEZWJ1Z2dlclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiUmVwcmVzZW50cyBhIGRlYnVnZ2VyIHN0YXRlbWVudFwiLFxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfRGlyZWN0aXZlID0gREVGTk9ERShcIkRpcmVjdGl2ZVwiLCBcInZhbHVlIHNjb3BlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZXByZXNlbnRzIGEgZGlyZWN0aXZlLCBsaWtlIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSBUaGUgdmFsdWUgb2YgdGhpcyBkaXJlY3RpdmUgYXMgYSBwbGFpbiBzdHJpbmcgKGl0J3Mgbm90IGFuIEFTVF9TdHJpbmchKVwiLFxuICAgICAgICBzY29wZTogXCJbQVNUX1Njb3BlL1NdIFRoZSBzY29wZSB0aGF0IHRoaXMgZGlyZWN0aXZlIGFmZmVjdHNcIlxuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9TaW1wbGVTdGF0ZW1lbnQgPSBERUZOT0RFKFwiU2ltcGxlU3RhdGVtZW50XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzdGF0ZW1lbnQgY29uc2lzdGluZyBvZiBhbiBleHByZXNzaW9uLCBpLmUuIGEgPSAxICsgMlwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9Ob2RlXSBhbiBleHByZXNzaW9uIG5vZGUgKHNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbmZ1bmN0aW9uIHdhbGtfYm9keShub2RlLCB2aXNpdG9yKSB7XG4gICAgaWYgKG5vZGUuYm9keSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgbm9kZS5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgIH1cbiAgICBlbHNlIG5vZGUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpe1xuICAgICAgICBzdGF0Ll93YWxrKHZpc2l0b3IpO1xuICAgIH0pO1xufTtcblxudmFyIEFTVF9CbG9jayA9IERFRk5PREUoXCJCbG9ja1wiLCBcImJvZHlcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYm9keSBvZiBzdGF0ZW1lbnRzICh1c3VhbGx5IGJyYWNrZXRlZClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBib2R5OiBcIltBU1RfU3RhdGVtZW50Kl0gYW4gYXJyYXkgb2Ygc3RhdGVtZW50c1wiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfQmxvY2tTdGF0ZW1lbnQgPSBERUZOT0RFKFwiQmxvY2tTdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYmxvY2sgc3RhdGVtZW50XCIsXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0VtcHR5U3RhdGVtZW50ID0gREVGTk9ERShcIkVtcHR5U3RhdGVtZW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgZW1wdHkgc3RhdGVtZW50IChlbXB0eSBibG9jayBvciBzaW1wbHkgYSBzZW1pY29sb24pXCIsXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMpO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1N0YXRlbWVudFdpdGhCb2R5ID0gREVGTk9ERShcIlN0YXRlbWVudFdpdGhCb2R5XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHMgdGhhdCBjb250YWluIG9uZSBuZXN0ZWQgYm9keTogYEZvcmAsIGBGb3JJbmAsIGBEb2AsIGBXaGlsZWAsIGBXaXRoYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9TdGF0ZW1lbnRdIHRoZSBib2R5OyB0aGlzIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCwgZXZlbiBpZiBpdCdzIGFuIEFTVF9FbXB0eVN0YXRlbWVudFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfTGFiZWxlZFN0YXRlbWVudCA9IERFRk5PREUoXCJMYWJlbGVkU3RhdGVtZW50XCIsIFwibGFiZWxcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN0YXRlbWVudCB3aXRoIGEgbGFiZWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsXSBhIGxhYmVsIGRlZmluaXRpb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG52YXIgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCA9IERFRk5PREUoXCJJdGVyYXRpb25TdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkludGVybmFsIGNsYXNzLiAgQWxsIGxvb3BzIGluaGVyaXQgZnJvbSBpdC5cIlxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcblxudmFyIEFTVF9EV0xvb3AgPSBERUZOT0RFKFwiRFdMb29wXCIsIFwiY29uZGl0aW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBkby93aGlsZSBzdGF0ZW1lbnRzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgY29uZGl0aW9uOiBcIltBU1RfTm9kZV0gdGhlIGxvb3AgY29uZGl0aW9uLiAgU2hvdWxkIG5vdCBiZSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSwgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCk7XG5cbnZhciBBU1RfRG8gPSBERUZOT0RFKFwiRG9cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGRvYCBzdGF0ZW1lbnRcIixcbn0sIEFTVF9EV0xvb3ApO1xuXG52YXIgQVNUX1doaWxlID0gREVGTk9ERShcIldoaWxlXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB3aGlsZWAgc3RhdGVtZW50XCIsXG59LCBBU1RfRFdMb29wKTtcblxudmFyIEFTVF9Gb3IgPSBERUZOT0RFKFwiRm9yXCIsIFwiaW5pdCBjb25kaXRpb24gc3RlcFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZm9yYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCBpbml0aWFsaXphdGlvbiBjb2RlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGU/XSB0aGUgYGZvcmAgdGVybWluYXRpb24gY2xhdXNlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIHN0ZXA6IFwiW0FTVF9Ob2RlP10gdGhlIGBmb3JgIHVwZGF0ZSBjbGF1c2UsIG9yIG51bGwgaWYgZW1wdHlcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25kaXRpb24pIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcCkgdGhpcy5zdGVwLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcblxudmFyIEFTVF9Gb3JJbiA9IERFRk5PREUoXCJGb3JJblwiLCBcImluaXQgbmFtZSBvYmplY3RcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGZvciAuLi4gaW5gIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGluaXQ6IFwiW0FTVF9Ob2RlXSB0aGUgYGZvci9pbmAgaW5pdGlhbGl6YXRpb24gY29kZVwiLFxuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sUmVmP10gdGhlIGxvb3AgdmFyaWFibGUsIG9ubHkgaWYgYGluaXRgIGlzIEFTVF9WYXJcIixcbiAgICAgICAgb2JqZWN0OiBcIltBU1RfTm9kZV0gdGhlIG9iamVjdCB0aGF0IHdlJ3JlIGxvb3BpbmcgdGhyb3VnaFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcblxudmFyIEFTVF9XaXRoID0gREVGTk9ERShcIldpdGhcIiwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB3aXRoYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIGB3aXRoYCBleHByZXNzaW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG4vKiAtLS0tLVsgc2NvcGUgYW5kIGZ1bmN0aW9ucyBdLS0tLS0gKi9cblxudmFyIEFTVF9TY29wZSA9IERFRk5PREUoXCJTY29wZVwiLCBcImRpcmVjdGl2ZXMgdmFyaWFibGVzIGZ1bmN0aW9ucyB1c2VzX3dpdGggdXNlc19ldmFsIHBhcmVudF9zY29wZSBlbmNsb3NlZCBjbmFtZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHMgaW50cm9kdWNpbmcgYSBsZXhpY2FsIHNjb3BlXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZGlyZWN0aXZlczogXCJbc3RyaW5nKi9TXSBhbiBhcnJheSBvZiBkaXJlY3RpdmVzIGRlY2xhcmVkIGluIHRoaXMgc2NvcGVcIixcbiAgICAgICAgdmFyaWFibGVzOiBcIltPYmplY3QvU10gYSBtYXAgb2YgbmFtZSAtPiBTeW1ib2xEZWYgZm9yIGFsbCB2YXJpYWJsZXMvZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBzY29wZVwiLFxuICAgICAgICBmdW5jdGlvbnM6IFwiW09iamVjdC9TXSBsaWtlIGB2YXJpYWJsZXNgLCBidXQgb25seSBsaXN0cyBmdW5jdGlvbiBkZWNsYXJhdGlvbnNcIixcbiAgICAgICAgdXNlc193aXRoOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XCIsXG4gICAgICAgIHVzZXNfZXZhbDogXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgc2NvcGUgY29udGFpbnMgYSBkaXJlY3QgY2FsbCB0byB0aGUgZ2xvYmFsIGBldmFsYFwiLFxuICAgICAgICBwYXJlbnRfc2NvcGU6IFwiW0FTVF9TY29wZT8vU10gbGluayB0byB0aGUgcGFyZW50IHNjb3BlXCIsXG4gICAgICAgIGVuY2xvc2VkOiBcIltTeW1ib2xEZWYqL1NdIGEgbGlzdCBvZiBhbGwgc3ltYm9sIGRlZmluaXRpb25zIHRoYXQgYXJlIGFjY2Vzc2VkIGZyb20gdGhpcyBzY29wZSBvciBhbnkgc3Vic2NvcGVzXCIsXG4gICAgICAgIGNuYW1lOiBcIltpbnRlZ2VyL1NdIGN1cnJlbnQgaW5kZXggZm9yIG1hbmdsaW5nIHZhcmlhYmxlcyAodXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBtYW5nbGVyKVwiLFxuICAgIH0sXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX1RvcGxldmVsID0gREVGTk9ERShcIlRvcGxldmVsXCIsIFwiZ2xvYmFsc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIHRvcGxldmVsIHNjb3BlXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZ2xvYmFsczogXCJbT2JqZWN0L1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdW5kZWNsYXJlZCBuYW1lc1wiLFxuICAgIH0sXG4gICAgd3JhcF9lbmNsb3NlOiBmdW5jdGlvbihhcmdfcGFyYW1ldGVyX3BhaXJzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcblxuICAgICAgICBhcmdfcGFyYW1ldGVyX3BhaXJzLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgICAgdmFyIHNwbGl0QXQgPSBwYWlyLmxhc3RJbmRleE9mKFwiOlwiKTtcblxuICAgICAgICAgICAgYXJncy5wdXNoKHBhaXIuc3Vic3RyKDAsIHNwbGl0QXQpKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChwYWlyLnN1YnN0cihzcGxpdEF0ICsgMSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgd3JhcHBlZF90bCA9IFwiKGZ1bmN0aW9uKFwiICsgcGFyYW1ldGVycy5qb2luKFwiLFwiKSArIFwiKXsgJyRPUklHJzsgfSkoXCIgKyBhcmdzLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICAgIHdyYXBwZWRfdGwgPSBwYXJzZSh3cmFwcGVkX3RsKTtcbiAgICAgICAgd3JhcHBlZF90bCA9IHdyYXBwZWRfdGwudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24gYmVmb3JlKG5vZGUpe1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlICYmIG5vZGUudmFsdWUgPT0gXCIkT1JJR1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5zcGxpY2Uoc2VsZi5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gd3JhcHBlZF90bDtcbiAgICB9LFxuICAgIHdyYXBfY29tbW9uanM6IGZ1bmN0aW9uKG5hbWUsIGV4cG9ydF9hbGwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdG9fZXhwb3J0ID0gW107XG4gICAgICAgIGlmIChleHBvcnRfYWxsKSB7XG4gICAgICAgICAgICBzZWxmLmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgICAgIHNlbGYud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiAmJiBub2RlLmRlZmluaXRpb24oKS5nbG9iYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaW5kX2lmKGZ1bmN0aW9uKG4peyByZXR1cm4gbi5uYW1lID09IG5vZGUubmFtZSB9LCB0b19leHBvcnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9fZXhwb3J0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwcGVkX3RsID0gXCIoZnVuY3Rpb24oZXhwb3J0cywgZ2xvYmFsKXsgZ2xvYmFsWydcIiArIG5hbWUgKyBcIiddID0gZXhwb3J0czsgJyRPUklHJzsgJyRFWFBPUlRTJzsgfSh7fSwgKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCkpKSlcIjtcbiAgICAgICAgd3JhcHBlZF90bCA9IHBhcnNlKHdyYXBwZWRfdGwpO1xuICAgICAgICB3cmFwcGVkX3RsID0gd3JhcHBlZF90bC50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbiBiZWZvcmUobm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0cmluZykgc3dpdGNoIChub2RlLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCIkT1JJR1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNwbGljZShzZWxmLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIiRFWFBPUlRTXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRvX2V4cG9ydC5mb3JFYWNoKGZ1bmN0aW9uKHN5bSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobmV3IEFTVF9TaW1wbGVTdGF0ZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG5ldyBBU1RfQXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3IEFTVF9TdWIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbmV3IEFTVF9TeW1ib2xSZWYoeyBuYW1lOiBcImV4cG9ydHNcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBuZXcgQVNUX1N0cmluZyh7IHZhbHVlOiBzeW0ubmFtZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG5ldyBBU1RfU3ltYm9sUmVmKHN5bSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNwbGljZShib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRfdGw7XG4gICAgfVxufSwgQVNUX1Njb3BlKTtcblxudmFyIEFTVF9MYW1iZGEgPSBERUZOT0RFKFwiTGFtYmRhXCIsIFwibmFtZSBhcmduYW1lcyB1c2VzX2FyZ3VtZW50c1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgZnVuY3Rpb25zXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbmFtZTogXCJbQVNUX1N5bWJvbERlY2xhcmF0aW9uP10gdGhlIG5hbWUgb2YgdGhpcyBmdW5jdGlvblwiLFxuICAgICAgICBhcmduYW1lczogXCJbQVNUX1N5bWJvbEZ1bmFyZypdIGFycmF5IG9mIGZ1bmN0aW9uIGFyZ3VtZW50c1wiLFxuICAgICAgICB1c2VzX2FyZ3VtZW50czogXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgZnVuY3Rpb24gYWNjZXNzZXMgdGhlIGFyZ3VtZW50cyBhcnJheVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUpIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYXJnbmFtZXMuZm9yRWFjaChmdW5jdGlvbihhcmcpe1xuICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU2NvcGUpO1xuXG52YXIgQVNUX0FjY2Vzc29yID0gREVGTk9ERShcIkFjY2Vzc29yXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHNldHRlci9nZXR0ZXIgZnVuY3Rpb24uICBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIGFsd2F5cyBudWxsLlwiXG59LCBBU1RfTGFtYmRhKTtcblxudmFyIEFTVF9GdW5jdGlvbiA9IERFRk5PREUoXCJGdW5jdGlvblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBleHByZXNzaW9uXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG52YXIgQVNUX0RlZnVuID0gREVGTk9ERShcIkRlZnVuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGZ1bmN0aW9uIGRlZmluaXRpb25cIlxufSwgQVNUX0xhbWJkYSk7XG5cbi8qIC0tLS0tWyBKVU1QUyBdLS0tLS0gKi9cblxudmFyIEFTVF9KdW1wID0gREVGTk9ERShcIkp1bXBcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIOKAnGp1bXBz4oCdIChmb3Igbm93IHRoYXQncyBgcmV0dXJuYCwgYHRocm93YCwgYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIlxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfRXhpdCA9IERFRk5PREUoXCJFeGl0XCIsIFwidmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIOKAnGV4aXRz4oCdIChgcmV0dXJuYCBhbmQgYHRocm93YClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGU/XSB0aGUgdmFsdWUgcmV0dXJuZWQgb3IgdGhyb3duIGJ5IHRoaXMgc3RhdGVtZW50OyBjb3VsZCBiZSBudWxsIGZvciBBU1RfUmV0dXJuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLnZhbHVlICYmIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfUmV0dXJuID0gREVGTk9ERShcIlJldHVyblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgcmV0dXJuYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0V4aXQpO1xuXG52YXIgQVNUX1Rocm93ID0gREVGTk9ERShcIlRocm93XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB0aHJvd2Agc3RhdGVtZW50XCJcbn0sIEFTVF9FeGl0KTtcblxudmFyIEFTVF9Mb29wQ29udHJvbCA9IERFRk5PREUoXCJMb29wQ29udHJvbFwiLCBcImxhYmVsXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBsb29wIGNvbnRyb2wgc3RhdGVtZW50cyAoYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsUmVmP10gdGhlIGxhYmVsLCBvciBudWxsIGlmIG5vbmVcIixcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLmxhYmVsICYmIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfQnJlYWsgPSBERUZOT0RFKFwiQnJlYWtcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGJyZWFrYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0xvb3BDb250cm9sKTtcblxudmFyIEFTVF9Db250aW51ZSA9IERFRk5PREUoXCJDb250aW51ZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY29udGludWVgIHN0YXRlbWVudFwiXG59LCBBU1RfTG9vcENvbnRyb2wpO1xuXG4vKiAtLS0tLVsgSUYgXS0tLS0tICovXG5cbnZhciBBU1RfSWYgPSBERUZOT0RFKFwiSWZcIiwgXCJjb25kaXRpb24gYWx0ZXJuYXRpdmVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGlmYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXSB0aGUgYGlmYCBjb25kaXRpb25cIixcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFwiW0FTVF9TdGF0ZW1lbnQ/XSB0aGUgYGVsc2VgIHBhcnQsIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsdGVybmF0aXZlKSB0aGlzLmFsdGVybmF0aXZlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG4vKiAtLS0tLVsgU1dJVENIIF0tLS0tLSAqL1xuXG52YXIgQVNUX1N3aXRjaCA9IERFRk5PREUoXCJTd2l0Y2hcIiwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBzd2l0Y2hgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYHN3aXRjaGAg4oCcZGlzY3JpbWluYW504oCdXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX1N3aXRjaEJyYW5jaCA9IERFRk5PREUoXCJTd2l0Y2hCcmFuY2hcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGBzd2l0Y2hgIGJyYW5jaGVzXCIsXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0RlZmF1bHQgPSBERUZOT0RFKFwiRGVmYXVsdFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZGVmYXVsdGAgc3dpdGNoIGJyYW5jaFwiLFxufSwgQVNUX1N3aXRjaEJyYW5jaCk7XG5cbnZhciBBU1RfQ2FzZSA9IERFRk5PREUoXCJDYXNlXCIsIFwiZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY2FzZWAgc3dpdGNoIGJyYW5jaFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUgYGNhc2VgIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9Td2l0Y2hCcmFuY2gpO1xuXG4vKiAtLS0tLVsgRVhDRVBUSU9OUyBdLS0tLS0gKi9cblxudmFyIEFTVF9UcnkgPSBERUZOT0RFKFwiVHJ5XCIsIFwiYmNhdGNoIGJmaW5hbGx5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB0cnlgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJjYXRjaDogXCJbQVNUX0NhdGNoP10gdGhlIGNhdGNoIGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCIsXG4gICAgICAgIGJmaW5hbGx5OiBcIltBU1RfRmluYWxseT9dIHRoZSBmaW5hbGx5IGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmNhdGNoKSB0aGlzLmJjYXRjaC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJmaW5hbGx5KSB0aGlzLmJmaW5hbGx5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0NhdGNoID0gREVGTk9ERShcIkNhdGNoXCIsIFwiYXJnbmFtZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY2F0Y2hgIG5vZGU7IG9ubHkgbWFrZXMgc2Vuc2UgYXMgcGFydCBvZiBhIGB0cnlgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGFyZ25hbWU6IFwiW0FTVF9TeW1ib2xDYXRjaF0gc3ltYm9sIGZvciB0aGUgZXhjZXB0aW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5hcmduYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0ZpbmFsbHkgPSBERUZOT0RFKFwiRmluYWxseVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZmluYWxseWAgbm9kZTsgb25seSBtYWtlcyBzZW5zZSBhcyBwYXJ0IG9mIGEgYHRyeWAgc3RhdGVtZW50XCJcbn0sIEFTVF9CbG9jayk7XG5cbi8qIC0tLS0tWyBWQVIvQ09OU1QgXS0tLS0tICovXG5cbnZhciBBU1RfRGVmaW5pdGlvbnMgPSBERUZOT0RFKFwiRGVmaW5pdGlvbnNcIiwgXCJkZWZpbml0aW9uc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYHZhcmAgb3IgYGNvbnN0YCBub2RlcyAodmFyaWFibGUgZGVjbGFyYXRpb25zL2luaXRpYWxpemF0aW9ucylcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBkZWZpbml0aW9uczogXCJbQVNUX1ZhckRlZipdIGFycmF5IG9mIHZhcmlhYmxlIGRlZmluaXRpb25zXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgZGVmLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1ZhciA9IERFRk5PREUoXCJWYXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHZhcmAgc3RhdGVtZW50XCJcbn0sIEFTVF9EZWZpbml0aW9ucyk7XG5cbnZhciBBU1RfQ29uc3QgPSBERUZOT0RFKFwiQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGNvbnN0YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0RlZmluaXRpb25zKTtcblxudmFyIEFTVF9WYXJEZWYgPSBERUZOT0RFKFwiVmFyRGVmXCIsIFwibmFtZSB2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSB2YXJpYWJsZSBkZWNsYXJhdGlvbjsgb25seSBhcHBlYXJzIGluIGEgQVNUX0RlZmluaXRpb25zIG5vZGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sVmFyfEFTVF9TeW1ib2xDb25zdF0gbmFtZSBvZiB0aGUgdmFyaWFibGVcIixcbiAgICAgICAgdmFsdWU6IFwiW0FTVF9Ob2RlP10gaW5pdGlhbGl6ZXIsIG9yIG51bGwgb2YgdGhlcmUncyBubyBpbml0aWFsaXplclwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyogLS0tLS1bIE9USEVSIF0tLS0tLSAqL1xuXG52YXIgQVNUX0NhbGwgPSBERUZOT0RFKFwiQ2FsbFwiLCBcImV4cHJlc3Npb24gYXJnc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBjYWxsIGV4cHJlc3Npb25cIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0byBpbnZva2UgYXMgZnVuY3Rpb25cIixcbiAgICAgICAgYXJnczogXCJbQVNUX05vZGUqXSBhcnJheSBvZiBhcmd1bWVudHNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpe1xuICAgICAgICAgICAgICAgIGFyZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9OZXcgPSBERUZOT0RFKFwiTmV3XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3QgaW5zdGFudGlhdGlvbi4gIERlcml2ZXMgZnJvbSBhIGZ1bmN0aW9uIGNhbGwgc2luY2UgaXQgaGFzIGV4YWN0bHkgdGhlIHNhbWUgcHJvcGVydGllc1wiXG59LCBBU1RfQ2FsbCk7XG5cbnZhciBBU1RfU2VxID0gREVGTk9ERShcIlNlcVwiLCBcImNhciBjZHJcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc2VxdWVuY2UgZXhwcmVzc2lvbiAodHdvIGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9ucylcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjYXI6IFwiW0FTVF9Ob2RlXSBmaXJzdCBlbGVtZW50IGluIHNlcXVlbmNlXCIsXG4gICAgICAgIGNkcjogXCJbQVNUX05vZGVdIHNlY29uZCBlbGVtZW50IGluIHNlcXVlbmNlXCJcbiAgICB9LFxuICAgICRjb25zOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBzZXEgPSBuZXcgQVNUX1NlcSh4KTtcbiAgICAgICAgc2VxLmNhciA9IHg7XG4gICAgICAgIHNlcS5jZHIgPSB5O1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH0sXG4gICAgJGZyb21fYXJyYXk6IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMSkgcmV0dXJuIGFycmF5WzBdLmNsb25lKCk7XG4gICAgICAgIHZhciBsaXN0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICBsaXN0ID0gQVNUX1NlcS5jb25zKGFycmF5W2ldLCBsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IGxpc3Q7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAocC5jZHIgJiYgIXAuY2RyLmNkcikge1xuICAgICAgICAgICAgICAgIHAuY2RyID0gcC5jZHIuY2FyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAuY2RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sXG4gICAgdG9fYXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMsIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIGEucHVzaChwLmNhcik7XG4gICAgICAgICAgICBpZiAocC5jZHIgJiYgIShwLmNkciBpbnN0YW5jZW9mIEFTVF9TZXEpKSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKHAuY2RyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLmNkcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBpZiAoIShwLmNkciBpbnN0YW5jZW9mIEFTVF9TZXEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBBU1RfU2VxLmNvbnMocC5jZHIsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmNkciA9IGNlbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5jZHI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5jYXIuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5jZHIpIHRoaXMuY2RyLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9Qcm9wQWNjZXNzID0gREVGTk9ERShcIlByb3BBY2Nlc3NcIiwgXCJleHByZXNzaW9uIHByb3BlcnR5XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvbnMsIGkuZS4gYGEuZm9vYCBvciBgYVtcXFwiZm9vXFxcIl1gXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSDigJxjb250YWluZXLigJ0gZXhwcmVzc2lvblwiLFxuICAgICAgICBwcm9wZXJ0eTogXCJbQVNUX05vZGV8c3RyaW5nXSB0aGUgcHJvcGVydHkgdG8gYWNjZXNzLiAgRm9yIEFTVF9Eb3QgdGhpcyBpcyBhbHdheXMgYSBwbGFpbiBzdHJpbmcsIHdoaWxlIGZvciBBU1RfU3ViIGl0J3MgYW4gYXJiaXRyYXJ5IEFTVF9Ob2RlXCJcbiAgICB9XG59KTtcblxudmFyIEFTVF9Eb3QgPSBERUZOT0RFKFwiRG90XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRvdHRlZCBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvblwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59LCBBU1RfUHJvcEFjY2Vzcyk7XG5cbnZhciBBU1RfU3ViID0gREVGTk9ERShcIlN1YlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiSW5kZXgtc3R5bGUgcHJvcGVydHkgYWNjZXNzLCBpLmUuIGBhW1xcXCJmb29cXFwiXWBcIixcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0sIEFTVF9Qcm9wQWNjZXNzKTtcblxudmFyIEFTVF9VbmFyeSA9IERFRk5PREUoXCJVbmFyeVwiLCBcIm9wZXJhdG9yIGV4cHJlc3Npb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIHVuYXJ5IGV4cHJlc3Npb25zXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgb3BlcmF0b3I6IFwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXCIsXG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSBleHByZXNzaW9uIHRoYXQgdGhpcyB1bmFyeSBvcGVyYXRvciBhcHBsaWVzIHRvXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9VbmFyeVByZWZpeCA9IERFRk5PREUoXCJVbmFyeVByZWZpeFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVW5hcnkgcHJlZml4IGV4cHJlc3Npb24sIGkuZS4gYHR5cGVvZiBpYCBvciBgKytpYFwiXG59LCBBU1RfVW5hcnkpO1xuXG52YXIgQVNUX1VuYXJ5UG9zdGZpeCA9IERFRk5PREUoXCJVbmFyeVBvc3RmaXhcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlVuYXJ5IHBvc3RmaXggZXhwcmVzc2lvbiwgaS5lLiBgaSsrYFwiXG59LCBBU1RfVW5hcnkpO1xuXG52YXIgQVNUX0JpbmFyeSA9IERFRk5PREUoXCJCaW5hcnlcIiwgXCJsZWZ0IG9wZXJhdG9yIHJpZ2h0XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCaW5hcnkgZXhwcmVzc2lvbiwgaS5lLiBgYSArIGJgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbGVmdDogXCJbQVNUX05vZGVdIGxlZnQtaGFuZCBzaWRlIGV4cHJlc3Npb25cIixcbiAgICAgICAgb3BlcmF0b3I6IFwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXCIsXG4gICAgICAgIHJpZ2h0OiBcIltBU1RfTm9kZV0gcmlnaHQtaGFuZCBzaWRlIGV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxlZnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9Db25kaXRpb25hbCA9IERFRk5PREUoXCJDb25kaXRpb25hbFwiLCBcImNvbmRpdGlvbiBjb25zZXF1ZW50IGFsdGVybmF0aXZlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJDb25kaXRpb25hbCBleHByZXNzaW9uIHVzaW5nIHRoZSB0ZXJuYXJ5IG9wZXJhdG9yLCBpLmUuIGBhID8gYiA6IGNgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgY29uZGl0aW9uOiBcIltBU1RfTm9kZV1cIixcbiAgICAgICAgY29uc2VxdWVudDogXCJbQVNUX05vZGVdXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIltBU1RfTm9kZV1cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG52YXIgQVNUX0Fzc2lnbiA9IERFRk5PREUoXCJBc3NpZ25cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiDigJQgYGEgPSBiICsgNWBcIixcbn0sIEFTVF9CaW5hcnkpO1xuXG4vKiAtLS0tLVsgTElURVJBTFMgXS0tLS0tICovXG5cbnZhciBBU1RfQXJyYXkgPSBERUZOT0RFKFwiQXJyYXlcIiwgXCJlbGVtZW50c1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gYXJyYXkgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGVsZW1lbnRzOiBcIltBU1RfTm9kZSpdIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgICAgICBlbC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3QgPSBERUZOT0RFKFwiT2JqZWN0XCIsIFwicHJvcGVydGllc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gb2JqZWN0IGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBwcm9wZXJ0aWVzOiBcIltBU1RfT2JqZWN0UHJvcGVydHkqXSBhcnJheSBvZiBwcm9wZXJ0aWVzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICAgICAgcHJvcC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3RQcm9wZXJ0eSA9IERFRk5PREUoXCJPYmplY3RQcm9wZXJ0eVwiLCBcImtleSB2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgbGl0ZXJhbCBvYmplY3QgcHJvcGVydGllc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGtleTogXCJbc3RyaW5nXSB0aGUgcHJvcGVydHkgbmFtZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgZm9yIE9iamVjdEtleVZhbC4gIEZvciBzZXR0ZXJzIGFuZCBnZXR0ZXJzIHRoaXMgaXMgYW4gYXJiaXRyYXJ5IEFTVF9Ob2RlLlwiLFxuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGVdIHByb3BlcnR5IHZhbHVlLiAgRm9yIHNldHRlcnMgYW5kIGdldHRlcnMgdGhpcyBpcyBhbiBBU1RfRnVuY3Rpb24uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBBU1RfT2JqZWN0S2V5VmFsID0gREVGTk9ERShcIk9iamVjdEtleVZhbFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBrZXk6IHZhbHVlIG9iamVjdCBwcm9wZXJ0eVwiLFxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9PYmplY3RTZXR0ZXIgPSBERUZOT0RFKFwiT2JqZWN0U2V0dGVyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBvYmplY3Qgc2V0dGVyIHByb3BlcnR5XCIsXG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX09iamVjdEdldHRlciA9IERFRk5PREUoXCJPYmplY3RHZXR0ZXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBnZXR0ZXIgcHJvcGVydHlcIixcbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XG5cbnZhciBBU1RfU3ltYm9sID0gREVGTk9ERShcIlN5bWJvbFwiLCBcInNjb3BlIG5hbWUgdGhlZGVmXCIsIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltzdHJpbmddIG5hbWUgb2YgdGhpcyBzeW1ib2xcIixcbiAgICAgICAgc2NvcGU6IFwiW0FTVF9TY29wZS9TXSB0aGUgY3VycmVudCBzY29wZSAobm90IG5lY2Vzc2FyaWx5IHRoZSBkZWZpbml0aW9uIHNjb3BlKVwiLFxuICAgICAgICB0aGVkZWY6IFwiW1N5bWJvbERlZi9TXSB0aGUgZGVmaW5pdGlvbiBvZiB0aGlzIHN5bWJvbFwiXG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgc3ltYm9sc1wiLFxufSk7XG5cbnZhciBBU1RfU3ltYm9sQWNjZXNzb3IgPSBERUZOT0RFKFwiU3ltYm9sQWNjZXNzb3JcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBuYW1lIG9mIGEgcHJvcGVydHkgYWNjZXNzb3IgKHNldHRlci9nZXR0ZXIgZnVuY3Rpb24pXCJcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1N5bWJvbERlY2xhcmF0aW9uID0gREVGTk9ERShcIlN5bWJvbERlY2xhcmF0aW9uXCIsIFwiaW5pdFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBkZWNsYXJhdGlvbiBzeW1ib2wgKHN5bWJvbCBpbiB2YXIvY29uc3QsIGZ1bmN0aW9uIG5hbWUgb3IgYXJndW1lbnQsIHN5bWJvbCBpbiBjYXRjaClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZSovU10gYXJyYXkgb2YgaW5pdGlhbGl6ZXJzIGZvciB0aGlzIGRlY2xhcmF0aW9uLlwiXG4gICAgfVxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sVmFyID0gREVGTk9ERShcIlN5bWJvbFZhclwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIGRlZmluaW5nIGEgdmFyaWFibGVcIixcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sQ29uc3QgPSBERUZOT0RFKFwiU3ltYm9sQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgY29uc3RhbnQgZGVjbGFyYXRpb25cIlxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xGdW5hcmcgPSBERUZOT0RFKFwiU3ltYm9sRnVuYXJnXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gYXJndW1lbnRcIixcbn0sIEFTVF9TeW1ib2xWYXIpO1xuXG52YXIgQVNUX1N5bWJvbERlZnVuID0gREVGTk9ERShcIlN5bWJvbERlZnVuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZGVmaW5pbmcgYSBmdW5jdGlvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xMYW1iZGEgPSBERUZOT0RFKFwiU3ltYm9sTGFtYmRhXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gZXhwcmVzc2lvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xDYXRjaCA9IERFRk5PREUoXCJTeW1ib2xDYXRjaFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyB0aGUgZXhjZXB0aW9uIGluIGNhdGNoXCIsXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX0xhYmVsID0gREVGTk9ERShcIkxhYmVsXCIsIFwicmVmZXJlbmNlc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyBhIGxhYmVsIChkZWNsYXJhdGlvbilcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICByZWZlcmVuY2VzOiBcIltBU1RfTG9vcENvbnRyb2wqXSBhIGxpc3Qgb2Ygbm9kZXMgcmVmZXJyaW5nIHRvIHRoaXMgbGFiZWxcIlxuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnRoZWRlZiA9IHRoaXM7XG4gICAgfVxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sUmVmID0gREVGTk9ERShcIlN5bWJvbFJlZlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiUmVmZXJlbmNlIHRvIHNvbWUgc3ltYm9sIChub3QgZGVmaW5pdGlvbi9kZWNsYXJhdGlvbilcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX0xhYmVsUmVmID0gREVGTk9ERShcIkxhYmVsUmVmXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZWZlcmVuY2UgdG8gYSBsYWJlbCBzeW1ib2xcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1RoaXMgPSBERUZOT0RFKFwiVGhpc1wiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGB0aGlzYCBzeW1ib2xcIixcbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX0NvbnN0YW50ID0gREVGTk9ERShcIkNvbnN0YW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgY29uc3RhbnRzXCIsXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9TdHJpbmcgPSBERUZOT0RFKFwiU3RyaW5nXCIsIFwidmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc3RyaW5nIGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSB0aGUgY29udGVudHMgb2YgdGhpcyBzdHJpbmdcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfTnVtYmVyID0gREVGTk9ERShcIk51bWJlclwiLCBcInZhbHVlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIG51bWJlciBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdmFsdWU6IFwiW251bWJlcl0gdGhlIG51bWVyaWMgdmFsdWVcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfUmVnRXhwID0gREVGTk9ERShcIlJlZ0V4cFwiLCBcInZhbHVlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHJlZ2V4cCBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdmFsdWU6IFwiW1JlZ0V4cF0gdGhlIGFjdHVhbCByZWdleHBcIlxuICAgIH1cbn0sIEFTVF9Db25zdGFudCk7XG5cbnZhciBBU1RfQXRvbSA9IERFRk5PREUoXCJBdG9tXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhdG9tc1wiLFxufSwgQVNUX0NvbnN0YW50KTtcblxudmFyIEFTVF9OdWxsID0gREVGTk9ERShcIk51bGxcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgbnVsbGAgYXRvbVwiLFxuICAgIHZhbHVlOiBudWxsXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfTmFOID0gREVGTk9ERShcIk5hTlwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGltcG9zc2libGUgdmFsdWVcIixcbiAgICB2YWx1ZTogMC8wXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfVW5kZWZpbmVkID0gREVGTk9ERShcIlVuZGVmaW5lZFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGB1bmRlZmluZWRgIHZhbHVlXCIsXG4gICAgdmFsdWU6IChmdW5jdGlvbigpe30oKSlcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9Ib2xlID0gREVGTk9ERShcIkhvbGVcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgaG9sZSBpbiBhbiBhcnJheVwiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24oKXt9KCkpXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfSW5maW5pdHkgPSBERUZOT0RFKFwiSW5maW5pdHlcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgSW5maW5pdHlgIHZhbHVlXCIsXG4gICAgdmFsdWU6IDEvMFxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX0Jvb2xlYW4gPSBERUZOT0RFKFwiQm9vbGVhblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYm9vbGVhbnNcIixcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9GYWxzZSA9IERFRk5PREUoXCJGYWxzZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGBmYWxzZWAgYXRvbVwiLFxuICAgIHZhbHVlOiBmYWxzZVxufSwgQVNUX0Jvb2xlYW4pO1xuXG52YXIgQVNUX1RydWUgPSBERUZOT0RFKFwiVHJ1ZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGB0cnVlYCBhdG9tXCIsXG4gICAgdmFsdWU6IHRydWVcbn0sIEFTVF9Cb29sZWFuKTtcblxuLyogLS0tLS1bIFRyZWVXYWxrZXIgXS0tLS0tICovXG5cbmZ1bmN0aW9uIFRyZWVXYWxrZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLnZpc2l0ID0gY2FsbGJhY2s7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xufTtcblRyZWVXYWxrZXIucHJvdG90eXBlID0ge1xuICAgIF92aXNpdDogZnVuY3Rpb24obm9kZSwgZGVzY2VuZCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLnZpc2l0KG5vZGUsIGRlc2NlbmQgPyBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZGVzY2VuZC5jYWxsKG5vZGUpO1xuICAgICAgICB9IDogbm9vcCk7XG4gICAgICAgIGlmICghcmV0ICYmIGRlc2NlbmQpIHtcbiAgICAgICAgICAgIGRlc2NlbmQuY2FsbChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMiAtIChuIHx8IDApXTtcbiAgICB9LFxuICAgIHB1c2g6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcbiAgICB9LFxuICAgIHBvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH0sXG4gICAgc2VsZjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfSxcbiAgICBmaW5kX3BhcmVudDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciB4ID0gc3RhY2tbaV07XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIHR5cGUpIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYXNfZGlyZWN0aXZlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRfcGFyZW50KEFTVF9TY29wZSkuaGFzX2RpcmVjdGl2ZSh0eXBlKTtcbiAgICB9LFxuICAgIGluX2Jvb2xlYW5fY29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoLCBzZWxmID0gc3RhY2tbLS1pXTtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHN0YWNrWy0taV07XG4gICAgICAgICAgICBpZiAoKHAgaW5zdGFuY2VvZiBBU1RfSWYgICAgICAgICAgICYmIHAuY29uZGl0aW9uID09PSBzZWxmKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICAmJiBwLmNvbmRpdGlvbiA9PT0gc2VsZikgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9EV0xvb3AgICAgICAgJiYgcC5jb25kaXRpb24gPT09IHNlbGYpIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfRm9yICAgICAgICAgICYmIHAuY29uZGl0aW9uID09PSBzZWxmKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICAmJiBwLm9wZXJhdG9yID09IFwiIVwiICYmIHAuZXhwcmVzc2lvbiA9PT0gc2VsZikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiAocC5vcGVyYXRvciA9PSBcIiYmXCIgfHwgcC5vcGVyYXRvciA9PSBcInx8XCIpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzZWxmID0gcDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbG9vcGNvbnRyb2xfdGFyZ2V0OiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgICAgICBpZiAobGFiZWwpIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHggPSBzdGFja1tpXTtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0xhYmVsZWRTdGF0ZW1lbnQgJiYgeC5sYWJlbC5uYW1lID09IGxhYmVsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBU1RfU3dpdGNoIHx8IHggaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgIFBhcnNlciBiYXNlZCBvbiBwYXJzZS1qcyAoaHR0cDovL21hcmlqbi5oYXZlcmJla2UubmwvcGFyc2UtanMvKS5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBLRVlXT1JEUyA9ICdicmVhayBjYXNlIGNhdGNoIGNvbnN0IGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZGVsZXRlIGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgaW4gaW5zdGFuY2VvZiBuZXcgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdHlwZW9mIHZhciB2b2lkIHdoaWxlIHdpdGgnO1xudmFyIEtFWVdPUkRTX0FUT00gPSAnZmFsc2UgbnVsbCB0cnVlJztcbnZhciBSRVNFUlZFRF9XT1JEUyA9ICdhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aGlzIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGUgeWllbGQnXG4gICAgKyBcIiBcIiArIEtFWVdPUkRTX0FUT00gKyBcIiBcIiArIEtFWVdPUkRTO1xudmFyIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gJ3JldHVybiBuZXcgZGVsZXRlIHRocm93IGVsc2UgY2FzZSc7XG5cbktFWVdPUkRTID0gbWFrZVByZWRpY2F0ZShLRVlXT1JEUyk7XG5SRVNFUlZFRF9XT1JEUyA9IG1ha2VQcmVkaWNhdGUoUkVTRVJWRURfV09SRFMpO1xuS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04gPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OKTtcbktFWVdPUkRTX0FUT00gPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTX0FUT00pO1xuXG52YXIgT1BFUkFUT1JfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCIrLSomJT08PiE/fH5eXCIpKTtcblxudmFyIFJFX0hFWF9OVU1CRVIgPSAvXjB4WzAtOWEtZl0rJC9pO1xudmFyIFJFX09DVF9OVU1CRVIgPSAvXjBbMC03XSskLztcbnZhciBSRV9ERUNfTlVNQkVSID0gL15cXGQqXFwuP1xcZCooPzplWystXT9cXGQqKD86XFxkXFwuP3xcXC4/XFxkKVxcZCopPyQvaTtcblxudmFyIE9QRVJBVE9SUyA9IG1ha2VQcmVkaWNhdGUoW1xuICAgIFwiaW5cIixcbiAgICBcImluc3RhbmNlb2ZcIixcbiAgICBcInR5cGVvZlwiLFxuICAgIFwibmV3XCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJkZWxldGVcIixcbiAgICBcIisrXCIsXG4gICAgXCItLVwiLFxuICAgIFwiK1wiLFxuICAgIFwiLVwiLFxuICAgIFwiIVwiLFxuICAgIFwiflwiLFxuICAgIFwiJlwiLFxuICAgIFwifFwiLFxuICAgIFwiXlwiLFxuICAgIFwiKlwiLFxuICAgIFwiL1wiLFxuICAgIFwiJVwiLFxuICAgIFwiPj5cIixcbiAgICBcIjw8XCIsXG4gICAgXCI+Pj5cIixcbiAgICBcIjxcIixcbiAgICBcIj5cIixcbiAgICBcIjw9XCIsXG4gICAgXCI+PVwiLFxuICAgIFwiPT1cIixcbiAgICBcIj09PVwiLFxuICAgIFwiIT1cIixcbiAgICBcIiE9PVwiLFxuICAgIFwiP1wiLFxuICAgIFwiPVwiLFxuICAgIFwiKz1cIixcbiAgICBcIi09XCIsXG4gICAgXCIvPVwiLFxuICAgIFwiKj1cIixcbiAgICBcIiU9XCIsXG4gICAgXCI+Pj1cIixcbiAgICBcIjw8PVwiLFxuICAgIFwiPj4+PVwiLFxuICAgIFwifD1cIixcbiAgICBcIl49XCIsXG4gICAgXCImPVwiLFxuICAgIFwiJiZcIixcbiAgICBcInx8XCJcbl0pO1xuXG52YXIgV0hJVEVTUEFDRV9DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIiBcXHUwMGEwXFxuXFxyXFx0XFxmXFx1MDAwYlxcdTIwMGJcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcIikpO1xuXG52YXIgUFVOQ19CRUZPUkVfRVhQUkVTU0lPTiA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIlt7KCwuOzpcIikpO1xuXG52YXIgUFVOQ19DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIltde30oKSw7OlwiKSk7XG5cbnZhciBSRUdFWFBfTU9ESUZJRVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiZ21zaXlcIikpO1xuXG4vKiAtLS0tLVsgVG9rZW5pemVyIF0tLS0tLSAqL1xuXG4vLyByZWdleHBzIGFkYXB0ZWQgZnJvbSBodHRwOi8veHJlZ2V4cC5jb20vcGx1Z2lucy8jdW5pY29kZVxudmFyIFVOSUNPREUgPSB7XG4gICAgbGV0dGVyOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDA0MS1cXFxcdTAwNUFcXFxcdTAwNjEtXFxcXHUwMDdBXFxcXHUwMEFBXFxcXHUwMEI1XFxcXHUwMEJBXFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkMxXFxcXHUwMkM2LVxcXFx1MDJEMVxcXFx1MDJFMC1cXFxcdTAyRTRcXFxcdTAyRUNcXFxcdTAyRUVcXFxcdTAzNzAtXFxcXHUwMzc0XFxcXHUwMzc2XFxcXHUwMzc3XFxcXHUwMzdBLVxcXFx1MDM3RFxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOEFcXFxcdTAzOENcXFxcdTAzOEUtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNGNVxcXFx1MDNGNy1cXFxcdTA0ODFcXFxcdTA0OEEtXFxcXHUwNTIzXFxcXHUwNTMxLVxcXFx1MDU1NlxcXFx1MDU1OVxcXFx1MDU2MS1cXFxcdTA1ODdcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUYwLVxcXFx1MDVGMlxcXFx1MDYyMS1cXFxcdTA2NEFcXFxcdTA2NkVcXFxcdTA2NkZcXFxcdTA2NzEtXFxcXHUwNkQzXFxcXHUwNkQ1XFxcXHUwNkU1XFxcXHUwNkU2XFxcXHUwNkVFXFxcXHUwNkVGXFxcXHUwNkZBLVxcXFx1MDZGQ1xcXFx1MDZGRlxcXFx1MDcxMFxcXFx1MDcxMi1cXFxcdTA3MkZcXFxcdTA3NEQtXFxcXHUwN0E1XFxcXHUwN0IxXFxcXHUwN0NBLVxcXFx1MDdFQVxcXFx1MDdGNFxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDkwNC1cXFxcdTA5MzlcXFxcdTA5M0RcXFxcdTA5NTBcXFxcdTA5NTgtXFxcXHUwOTYxXFxcXHUwOTcxXFxcXHUwOTcyXFxcXHUwOTdCLVxcXFx1MDk3RlxcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkRcXFxcdTA5Q0VcXFxcdTA5RENcXFxcdTA5RERcXFxcdTA5REYtXFxcXHUwOUUxXFxcXHUwOUYwXFxcXHUwOUYxXFxcXHUwQTA1LVxcXFx1MEEwQVxcXFx1MEEwRlxcXFx1MEExMFxcXFx1MEExMy1cXFxcdTBBMjhcXFxcdTBBMkEtXFxcXHUwQTMwXFxcXHUwQTMyXFxcXHUwQTMzXFxcXHUwQTM1XFxcXHUwQTM2XFxcXHUwQTM4XFxcXHUwQTM5XFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE3Mi1cXFxcdTBBNzRcXFxcdTBBODUtXFxcXHUwQThEXFxcXHUwQThGLVxcXFx1MEE5MVxcXFx1MEE5My1cXFxcdTBBQThcXFxcdTBBQUEtXFxcXHUwQUIwXFxcXHUwQUIyXFxcXHUwQUIzXFxcXHUwQUI1LVxcXFx1MEFCOVxcXFx1MEFCRFxcXFx1MEFEMFxcXFx1MEFFMFxcXFx1MEFFMVxcXFx1MEIwNS1cXFxcdTBCMENcXFxcdTBCMEZcXFxcdTBCMTBcXFxcdTBCMTMtXFxcXHUwQjI4XFxcXHUwQjJBLVxcXFx1MEIzMFxcXFx1MEIzMlxcXFx1MEIzM1xcXFx1MEIzNS1cXFxcdTBCMzlcXFxcdTBCM0RcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYxXFxcXHUwQjcxXFxcXHUwQjgzXFxcXHUwQjg1LVxcXFx1MEI4QVxcXFx1MEI4RS1cXFxcdTBCOTBcXFxcdTBCOTItXFxcXHUwQjk1XFxcXHUwQjk5XFxcXHUwQjlBXFxcXHUwQjlDXFxcXHUwQjlFXFxcXHUwQjlGXFxcXHUwQkEzXFxcXHUwQkE0XFxcXHUwQkE4LVxcXFx1MEJBQVxcXFx1MEJBRS1cXFxcdTBCQjlcXFxcdTBCRDBcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzMzXFxcXHUwQzM1LVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OFxcXFx1MEM1OVxcXFx1MEM2MFxcXFx1MEM2MVxcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JEXFxcXHUwQ0RFXFxcXHUwQ0UwXFxcXHUwQ0UxXFxcXHUwRDA1LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDI4XFxcXHUwRDJBLVxcXFx1MEQzOVxcXFx1MEQzRFxcXFx1MEQ2MFxcXFx1MEQ2MVxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRTAxLVxcXFx1MEUzMFxcXFx1MEUzMlxcXFx1MEUzM1xcXFx1MEU0MC1cXFxcdTBFNDZcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUIwXFxcXHUwRUIyXFxcXHUwRUIzXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVDNlxcXFx1MEVEQ1xcXFx1MEVERFxcXFx1MEYwMFxcXFx1MEY0MC1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjg4LVxcXFx1MEY4QlxcXFx1MTAwMC1cXFxcdTEwMkFcXFxcdTEwM0ZcXFxcdTEwNTAtXFxcXHUxMDU1XFxcXHUxMDVBLVxcXFx1MTA1RFxcXFx1MTA2MVxcXFx1MTA2NVxcXFx1MTA2NlxcXFx1MTA2RS1cXFxcdTEwNzBcXFxcdTEwNzUtXFxcXHUxMDgxXFxcXHUxMDhFXFxcXHUxMEEwLVxcXFx1MTBDNVxcXFx1MTBEMC1cXFxcdTEwRkFcXFxcdTEwRkNcXFxcdTExMDAtXFxcXHUxMTU5XFxcXHUxMTVGLVxcXFx1MTFBMlxcXFx1MTFBOC1cXFxcdTExRjlcXFxcdTEyMDAtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2NzZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTcwMC1cXFxcdTE3MENcXFxcdTE3MEUtXFxcXHUxNzExXFxcXHUxNzIwLVxcXFx1MTczMVxcXFx1MTc0MC1cXFxcdTE3NTFcXFxcdTE3NjAtXFxcXHUxNzZDXFxcXHUxNzZFLVxcXFx1MTc3MFxcXFx1MTc4MC1cXFxcdTE3QjNcXFxcdTE3RDdcXFxcdTE3RENcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThBOFxcXFx1MThBQVxcXFx1MTkwMC1cXFxcdTE5MUNcXFxcdTE5NTAtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QTlcXFxcdTE5QzEtXFxcXHUxOUM3XFxcXHUxQTAwLVxcXFx1MUExNlxcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUMwMC1cXFxcdTFDMjNcXFxcdTFDNEQtXFxcXHUxQzRGXFxcXHUxQzVBLVxcXFx1MUM3RFxcXFx1MUQwMC1cXFxcdTFEQkZcXFxcdTFFMDAtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDk0XFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTgzXFxcXHUyMTg0XFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjAtXFxcXHUyQzZGXFxcXHUyQzcxLVxcXFx1MkM3RFxcXFx1MkM4MC1cXFxcdTJDRTRcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDMwLVxcXFx1MkQ2NVxcXFx1MkQ2RlxcXFx1MkQ4MC1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkUyRlxcXFx1MzAwNVxcXFx1MzAwNlxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwM0JcXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUI3XFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMFxcXFx1NERCNVxcXFx1NEUwMFxcXFx1OUZDM1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYxRlxcXFx1QTYyQVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NUZcXFxcdUE2NjItXFxcXHVBNjZFXFxcXHVBNjdGLVxcXFx1QTY5N1xcXFx1QTcxNy1cXFxcdUE3MUZcXFxcdUE3MjItXFxcXHVBNzg4XFxcXHVBNzhCXFxcXHVBNzhDXFxcXHVBN0ZCLVxcXFx1QTgwMVxcXFx1QTgwMy1cXFxcdUE4MDVcXFxcdUE4MDctXFxcXHVBODBBXFxcXHVBODBDLVxcXFx1QTgyMlxcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODItXFxcXHVBOEIzXFxcXHVBOTBBLVxcXFx1QTkyNVxcXFx1QTkzMC1cXFxcdUE5NDZcXFxcdUFBMDAtXFxcXHVBQTI4XFxcXHVBQTQwLVxcXFx1QUE0MlxcXFx1QUE0NC1cXFxcdUFBNEJcXFxcdUFDMDBcXFxcdUQ3QTNcXFxcdUY5MDAtXFxcXHVGQTJEXFxcXHVGQTMwLVxcXFx1RkE2QVxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMDAtXFxcXHVGQjA2XFxcXHVGQjEzLVxcXFx1RkIxN1xcXFx1RkIxRFxcXFx1RkIxRi1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQjM2XFxcXHVGQjM4LVxcXFx1RkIzQ1xcXFx1RkIzRVxcXFx1RkI0MFxcXFx1RkI0MVxcXFx1RkI0M1xcXFx1RkI0NFxcXFx1RkI0Ni1cXFxcdUZCQjFcXFxcdUZCRDMtXFxcXHVGRDNEXFxcXHVGRDUwLVxcXFx1RkQ4RlxcXFx1RkQ5Mi1cXFxcdUZEQzdcXFxcdUZERjAtXFxcXHVGREZCXFxcXHVGRTcwLVxcXFx1RkU3NFxcXFx1RkU3Ni1cXFxcdUZFRkNcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXVwiKSxcbiAgICBub25fc3BhY2luZ19tYXJrOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNTkxLVxcXFx1MDVCRFxcXFx1MDVCRlxcXFx1MDVDMVxcXFx1MDVDMlxcXFx1MDVDNFxcXFx1MDVDNVxcXFx1MDVDN1xcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2NEItXFxcXHUwNjVFXFxcXHUwNjcwXFxcXHUwNkQ2LVxcXFx1MDZEQ1xcXFx1MDZERi1cXFxcdTA2RTRcXFxcdTA2RTdcXFxcdTA2RThcXFxcdTA2RUEtXFxcXHUwNkVEXFxcXHUwNzExXFxcXHUwNzMwLVxcXFx1MDc0QVxcXFx1MDdBNi1cXFxcdTA3QjBcXFxcdTA3RUItXFxcXHUwN0YzXFxcXHUwODE2LVxcXFx1MDgxOVxcXFx1MDgxQi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyRFxcXFx1MDkwMC1cXFxcdTA5MDJcXFxcdTA5M0NcXFxcdTA5NDEtXFxcXHUwOTQ4XFxcXHUwOTREXFxcXHUwOTUxLVxcXFx1MDk1NVxcXFx1MDk2MlxcXFx1MDk2M1xcXFx1MDk4MVxcXFx1MDlCQ1xcXFx1MDlDMS1cXFxcdTA5QzRcXFxcdTA5Q0RcXFxcdTA5RTJcXFxcdTA5RTNcXFxcdTBBMDFcXFxcdTBBMDJcXFxcdTBBM0NcXFxcdTBBNDFcXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTcwXFxcXHUwQTcxXFxcXHUwQTc1XFxcXHUwQTgxXFxcXHUwQTgyXFxcXHUwQUJDXFxcXHUwQUMxLVxcXFx1MEFDNVxcXFx1MEFDN1xcXFx1MEFDOFxcXFx1MEFDRFxcXFx1MEFFMlxcXFx1MEFFM1xcXFx1MEIwMVxcXFx1MEIzQ1xcXFx1MEIzRlxcXFx1MEI0MS1cXFxcdTBCNDRcXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNjJcXFxcdTBCNjNcXFxcdTBCODJcXFxcdTBCQzBcXFxcdTBCQ0RcXFxcdTBDM0UtXFxcXHUwQzQwXFxcXHUwQzQ2LVxcXFx1MEM0OFxcXFx1MEM0QS1cXFxcdTBDNERcXFxcdTBDNTVcXFxcdTBDNTZcXFxcdTBDNjJcXFxcdTBDNjNcXFxcdTBDQkNcXFxcdTBDQkZcXFxcdTBDQzZcXFxcdTBDQ0NcXFxcdTBDQ0RcXFxcdTBDRTJcXFxcdTBDRTNcXFxcdTBENDEtXFxcXHUwRDQ0XFxcXHUwRDREXFxcXHUwRDYyXFxcXHUwRDYzXFxcXHUwRENBXFxcXHUwREQyLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEUzMVxcXFx1MEUzNC1cXFxcdTBFM0FcXFxcdTBFNDctXFxcXHUwRTRFXFxcXHUwRUIxXFxcXHUwRUI0LVxcXFx1MEVCOVxcXFx1MEVCQlxcXFx1MEVCQ1xcXFx1MEVDOC1cXFxcdTBFQ0RcXFxcdTBGMThcXFxcdTBGMTlcXFxcdTBGMzVcXFxcdTBGMzdcXFxcdTBGMzlcXFxcdTBGNzEtXFxcXHUwRjdFXFxcXHUwRjgwLVxcXFx1MEY4NFxcXFx1MEY4NlxcXFx1MEY4N1xcXFx1MEY5MC1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDJELVxcXFx1MTAzMFxcXFx1MTAzMi1cXFxcdTEwMzdcXFxcdTEwMzlcXFxcdTEwM0FcXFxcdTEwM0RcXFxcdTEwM0VcXFxcdTEwNThcXFxcdTEwNTlcXFxcdTEwNUUtXFxcXHUxMDYwXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4MlxcXFx1MTA4NVxcXFx1MTA4NlxcXFx1MTA4RFxcXFx1MTA5RFxcXFx1MTM1RlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN0I3LVxcXFx1MTdCRFxcXFx1MTdDNlxcXFx1MTdDOS1cXFxcdTE3RDNcXFxcdTE3RERcXFxcdTE4MEItXFxcXHUxODBEXFxcXHUxOEE5XFxcXHUxOTIwLVxcXFx1MTkyMlxcXFx1MTkyN1xcXFx1MTkyOFxcXFx1MTkzMlxcXFx1MTkzOS1cXFxcdTE5M0JcXFxcdTFBMTdcXFxcdTFBMThcXFxcdTFBNTZcXFxcdTFBNTgtXFxcXHUxQTVFXFxcXHUxQTYwXFxcXHUxQTYyXFxcXHUxQTY1LVxcXFx1MUE2Q1xcXFx1MUE3My1cXFxcdTFBN0NcXFxcdTFBN0ZcXFxcdTFCMDAtXFxcXHUxQjAzXFxcXHUxQjM0XFxcXHUxQjM2LVxcXFx1MUIzQVxcXFx1MUIzQ1xcXFx1MUI0MlxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODBcXFxcdTFCODFcXFxcdTFCQTItXFxcXHUxQkE1XFxcXHUxQkE4XFxcXHUxQkE5XFxcXHUxQzJDLVxcXFx1MUMzM1xcXFx1MUMzNlxcXFx1MUMzN1xcXFx1MUNEMC1cXFxcdTFDRDJcXFxcdTFDRDQtXFxcXHUxQ0UwXFxcXHUxQ0UyLVxcXFx1MUNFOFxcXFx1MUNFRFxcXFx1MURDMC1cXFxcdTFERTZcXFxcdTFERkQtXFxcXHUxREZGXFxcXHUyMEQwLVxcXFx1MjBEQ1xcXFx1MjBFMVxcXFx1MjBFNS1cXFxcdTIwRjBcXFxcdTJDRUYtXFxcXHUyQ0YxXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MzAyQS1cXFxcdTMwMkZcXFxcdTMwOTlcXFxcdTMwOUFcXFxcdUE2NkZcXFxcdUE2N0NcXFxcdUE2N0RcXFxcdUE2RjBcXFxcdUE2RjFcXFxcdUE4MDJcXFxcdUE4MDZcXFxcdUE4MEJcXFxcdUE4MjVcXFxcdUE4MjZcXFxcdUE4QzRcXFxcdUE4RTAtXFxcXHVBOEYxXFxcXHVBOTI2LVxcXFx1QTkyRFxcXFx1QTk0Ny1cXFxcdUE5NTFcXFxcdUE5ODAtXFxcXHVBOTgyXFxcXHVBOUIzXFxcXHVBOUI2LVxcXFx1QTlCOVxcXFx1QTlCQ1xcXFx1QUEyOS1cXFxcdUFBMkVcXFxcdUFBMzFcXFxcdUFBMzJcXFxcdUFBMzVcXFxcdUFBMzZcXFxcdUFBNDNcXFxcdUFBNENcXFxcdUFBQjBcXFxcdUFBQjItXFxcXHVBQUI0XFxcXHVBQUI3XFxcXHVBQUI4XFxcXHVBQUJFXFxcXHVBQUJGXFxcXHVBQUMxXFxcXHVBQkU1XFxcXHVBQkU4XFxcXHVBQkVEXFxcXHVGQjFFXFxcXHVGRTAwLVxcXFx1RkUwRlxcXFx1RkUyMC1cXFxcdUZFMjZdXCIpLFxuICAgIHNwYWNlX2NvbWJpbmluZ19tYXJrOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDkwM1xcXFx1MDkzRS1cXFxcdTA5NDBcXFxcdTA5NDktXFxcXHUwOTRDXFxcXHUwOTRFXFxcXHUwOTgyXFxcXHUwOTgzXFxcXHUwOUJFLVxcXFx1MDlDMFxcXFx1MDlDN1xcXFx1MDlDOFxcXFx1MDlDQlxcXFx1MDlDQ1xcXFx1MDlEN1xcXFx1MEEwM1xcXFx1MEEzRS1cXFxcdTBBNDBcXFxcdTBBODNcXFxcdTBBQkUtXFxcXHUwQUMwXFxcXHUwQUM5XFxcXHUwQUNCXFxcXHUwQUNDXFxcXHUwQjAyXFxcXHUwQjAzXFxcXHUwQjNFXFxcXHUwQjQwXFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCXFxcXHUwQjRDXFxcXHUwQjU3XFxcXHUwQkJFXFxcXHUwQkJGXFxcXHUwQkMxXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0NcXFxcdTBCRDdcXFxcdTBDMDEtXFxcXHUwQzAzXFxcXHUwQzQxLVxcXFx1MEM0NFxcXFx1MEM4MlxcXFx1MEM4M1xcXFx1MENCRVxcXFx1MENDMC1cXFxcdTBDQzRcXFxcdTBDQzdcXFxcdTBDQzhcXFxcdTBDQ0FcXFxcdTBDQ0JcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBEMDJcXFxcdTBEMDNcXFxcdTBEM0UtXFxcXHUwRDQwXFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENENcXFxcdTBENTdcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEQ0YtXFxcXHUwREQxXFxcXHUwREQ4LVxcXFx1MERERlxcXFx1MERGMlxcXFx1MERGM1xcXFx1MEYzRVxcXFx1MEYzRlxcXFx1MEY3RlxcXFx1MTAyQlxcXFx1MTAyQ1xcXFx1MTAzMVxcXFx1MTAzOFxcXFx1MTAzQlxcXFx1MTAzQ1xcXFx1MTA1NlxcXFx1MTA1N1xcXFx1MTA2Mi1cXFxcdTEwNjRcXFxcdTEwNjctXFxcXHUxMDZEXFxcXHUxMDgzXFxcXHUxMDg0XFxcXHUxMDg3LVxcXFx1MTA4Q1xcXFx1MTA4RlxcXFx1MTA5QS1cXFxcdTEwOUNcXFxcdTE3QjZcXFxcdTE3QkUtXFxcXHUxN0M1XFxcXHUxN0M3XFxcXHUxN0M4XFxcXHUxOTIzLVxcXFx1MTkyNlxcXFx1MTkyOS1cXFxcdTE5MkJcXFxcdTE5MzBcXFxcdTE5MzFcXFxcdTE5MzMtXFxcXHUxOTM4XFxcXHUxOUIwLVxcXFx1MTlDMFxcXFx1MTlDOFxcXFx1MTlDOVxcXFx1MUExOS1cXFxcdTFBMUJcXFxcdTFBNTVcXFxcdTFBNTdcXFxcdTFBNjFcXFxcdTFBNjNcXFxcdTFBNjRcXFxcdTFBNkQtXFxcXHUxQTcyXFxcXHUxQjA0XFxcXHUxQjM1XFxcXHUxQjNCXFxcXHUxQjNELVxcXFx1MUI0MVxcXFx1MUI0M1xcXFx1MUI0NFxcXFx1MUI4MlxcXFx1MUJBMVxcXFx1MUJBNlxcXFx1MUJBN1xcXFx1MUJBQVxcXFx1MUMyNC1cXFxcdTFDMkJcXFxcdTFDMzRcXFxcdTFDMzVcXFxcdTFDRTFcXFxcdTFDRjJcXFxcdUE4MjNcXFxcdUE4MjRcXFxcdUE4MjdcXFxcdUE4ODBcXFxcdUE4ODFcXFxcdUE4QjQtXFxcXHVBOEMzXFxcXHVBOTUyXFxcXHVBOTUzXFxcXHVBOTgzXFxcXHVBOUI0XFxcXHVBOUI1XFxcXHVBOUJBXFxcXHVBOUJCXFxcXHVBOUJELVxcXFx1QTlDMFxcXFx1QUEyRlxcXFx1QUEzMFxcXFx1QUEzM1xcXFx1QUEzNFxcXFx1QUE0RFxcXFx1QUE3QlxcXFx1QUJFM1xcXFx1QUJFNFxcXFx1QUJFNlxcXFx1QUJFN1xcXFx1QUJFOVxcXFx1QUJFQVxcXFx1QUJFQ11cIiksXG4gICAgY29ubmVjdG9yX3B1bmN0dWF0aW9uOiBuZXcgUmVnRXhwKFwiW1xcXFx1MDA1RlxcXFx1MjAzRlxcXFx1MjA0MFxcXFx1MjA1NFxcXFx1RkUzM1xcXFx1RkUzNFxcXFx1RkU0RC1cXFxcdUZFNEZcXFxcdUZGM0ZdXCIpXG59O1xuXG5mdW5jdGlvbiBpc19sZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMilcbiAgICAgICAgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MClcbiAgICAgICAgfHwgKGNvZGUgPj0gMHhhYSAmJiBVTklDT0RFLmxldHRlci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpKTtcbn07XG5cbmZ1bmN0aW9uIGlzX2RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3OyAvL1hYWDogZmluZCBvdXQgaWYgXCJVbmljb2RlRGlnaXRcIiBtZWFucyBzb21ldGhpbmcgZWxzZSB0aGFuIDAuLjlcbn07XG5cbmZ1bmN0aW9uIGlzX2FscGhhbnVtZXJpY19jaGFyKGNvZGUpIHtcbiAgICByZXR1cm4gaXNfZGlnaXQoY29kZSkgfHwgaXNfbGV0dGVyKGNvZGUpO1xufTtcblxuZnVuY3Rpb24gaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayhjaCkge1xuICAgIHJldHVybiBVTklDT0RFLm5vbl9zcGFjaW5nX21hcmsudGVzdChjaCkgfHwgVU5JQ09ERS5zcGFjZV9jb21iaW5pbmdfbWFyay50ZXN0KGNoKTtcbn07XG5cbmZ1bmN0aW9uIGlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uKGNoKSB7XG4gICAgcmV0dXJuIFVOSUNPREUuY29ubmVjdG9yX3B1bmN0dWF0aW9uLnRlc3QoY2gpO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuICFSRVNFUlZFRF9XT1JEUyhuYW1lKSAmJiAvXlthLXpfJF1bYS16MC05XyRdKiQvaS50ZXN0KG5hbWUpO1xufTtcblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gMzYgfHwgY29kZSA9PSA5NSB8fCBpc19sZXR0ZXIoY29kZSk7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX2NoYXIoY2gpIHtcbiAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGlzX2lkZW50aWZpZXJfc3RhcnQoY29kZSlcbiAgICAgICAgfHwgaXNfZGlnaXQoY29kZSlcbiAgICAgICAgfHwgY29kZSA9PSA4MjA0IC8vIFxcdTIwMGM6IHplcm8td2lkdGggbm9uLWpvaW5lciA8WldOSj5cbiAgICAgICAgfHwgY29kZSA9PSA4MjA1IC8vIFxcdTIwMGQ6IHplcm8td2lkdGggam9pbmVyIDxaV0o+IChpbiBteSBFQ01BLTI2MiBQREYsIHRoaXMgaXMgYWxzbyAyMDBjKVxuICAgICAgICB8fCBpc191bmljb2RlX2NvbWJpbmluZ19tYXJrKGNoKVxuICAgICAgICB8fCBpc191bmljb2RlX2Nvbm5lY3Rvcl9wdW5jdHVhdGlvbihjaClcbiAgICA7XG59O1xuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX3N0cmluZyhzdHIpe1xuICAgIHJldHVybiAvXlthLXpfJF1bYS16MC05XyRdKiQvaS50ZXN0KHN0cik7XG59O1xuXG5mdW5jdGlvbiBwYXJzZV9qc19udW1iZXIobnVtKSB7XG4gICAgaWYgKFJFX0hFWF9OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDIpLCAxNik7XG4gICAgfSBlbHNlIGlmIChSRV9PQ1RfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigxKSwgOCk7XG4gICAgfSBlbHNlIGlmIChSRV9ERUNfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0pO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEpTX1BhcnNlX0Vycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCwgcG9zKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sID0gY29sO1xuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbn07XG5cbkpTX1BhcnNlX0Vycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyBcIiAobGluZTogXCIgKyB0aGlzLmxpbmUgKyBcIiwgY29sOiBcIiArIHRoaXMuY29sICsgXCIsIHBvczogXCIgKyB0aGlzLnBvcyArIFwiKVwiICsgXCJcXG5cXG5cIiArIHRoaXMuc3RhY2s7XG59O1xuXG5mdW5jdGlvbiBqc19lcnJvcihtZXNzYWdlLCBmaWxlbmFtZSwgbGluZSwgY29sLCBwb3MpIHtcbiAgICB0aHJvdyBuZXcgSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgbGluZSwgY29sLCBwb3MpO1xufTtcblxuZnVuY3Rpb24gaXNfdG9rZW4odG9rZW4sIHR5cGUsIHZhbCkge1xuICAgIHJldHVybiB0b2tlbi50eXBlID09IHR5cGUgJiYgKHZhbCA9PSBudWxsIHx8IHRva2VuLnZhbHVlID09IHZhbCk7XG59O1xuXG52YXIgRVhfRU9GID0ge307XG5cbmZ1bmN0aW9uIHRva2VuaXplcigkVEVYVCwgZmlsZW5hbWUsIGh0bWw1X2NvbW1lbnRzKSB7XG5cbiAgICB2YXIgUyA9IHtcbiAgICAgICAgdGV4dCAgICAgICAgICAgIDogJFRFWFQucmVwbGFjZSgvXFxyXFxuP3xbXFxuXFx1MjAyOFxcdTIwMjldL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdUZFRkYvZywgJycpLFxuICAgICAgICBmaWxlbmFtZSAgICAgICAgOiBmaWxlbmFtZSxcbiAgICAgICAgcG9zICAgICAgICAgICAgIDogMCxcbiAgICAgICAgdG9rcG9zICAgICAgICAgIDogMCxcbiAgICAgICAgbGluZSAgICAgICAgICAgIDogMSxcbiAgICAgICAgdG9rbGluZSAgICAgICAgIDogMCxcbiAgICAgICAgY29sICAgICAgICAgICAgIDogMCxcbiAgICAgICAgdG9rY29sICAgICAgICAgIDogMCxcbiAgICAgICAgbmV3bGluZV9iZWZvcmUgIDogZmFsc2UsXG4gICAgICAgIHJlZ2V4X2FsbG93ZWQgICA6IGZhbHNlLFxuICAgICAgICBjb21tZW50c19iZWZvcmUgOiBbXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkgeyByZXR1cm4gUy50ZXh0LmNoYXJBdChTLnBvcyk7IH07XG5cbiAgICBmdW5jdGlvbiBuZXh0KHNpZ25hbF9lb2YsIGluX3N0cmluZykge1xuICAgICAgICB2YXIgY2ggPSBTLnRleHQuY2hhckF0KFMucG9zKyspO1xuICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiAhY2gpXG4gICAgICAgICAgICB0aHJvdyBFWF9FT0Y7XG4gICAgICAgIGlmIChjaCA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gUy5uZXdsaW5lX2JlZm9yZSB8fCAhaW5fc3RyaW5nO1xuICAgICAgICAgICAgKytTLmxpbmU7XG4gICAgICAgICAgICBTLmNvbCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK1MuY29sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yd2FyZChpKSB7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSBuZXh0KCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvb2tpbmdfYXQoc3RyKSB7XG4gICAgICAgIHJldHVybiBTLnRleHQuc3Vic3RyKFMucG9zLCBzdHIubGVuZ3RoKSA9PSBzdHI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZpbmQod2hhdCwgc2lnbmFsX2VvZikge1xuICAgICAgICB2YXIgcG9zID0gUy50ZXh0LmluZGV4T2Yod2hhdCwgUy5wb3MpO1xuICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiBwb3MgPT0gLTEpIHRocm93IEVYX0VPRjtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc3RhcnRfdG9rZW4oKSB7XG4gICAgICAgIFMudG9rbGluZSA9IFMubGluZTtcbiAgICAgICAgUy50b2tjb2wgPSBTLmNvbDtcbiAgICAgICAgUy50b2twb3MgPSBTLnBvcztcbiAgICB9O1xuXG4gICAgdmFyIHByZXZfd2FzX2RvdCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHRva2VuKHR5cGUsIHZhbHVlLCBpc19jb21tZW50KSB7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9ICgodHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgIVVOQVJZX1BPU1RGSVgodmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJrZXl3b3JkXCIgJiYgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04odmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJwdW5jXCIgJiYgUFVOQ19CRUZPUkVfRVhQUkVTU0lPTih2YWx1ZSkpKTtcbiAgICAgICAgcHJldl93YXNfZG90ID0gKHR5cGUgPT0gXCJwdW5jXCIgJiYgdmFsdWUgPT0gXCIuXCIpO1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgdHlwZSAgIDogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlICA6IHZhbHVlLFxuICAgICAgICAgICAgbGluZSAgIDogUy50b2tsaW5lLFxuICAgICAgICAgICAgY29sICAgIDogUy50b2tjb2wsXG4gICAgICAgICAgICBwb3MgICAgOiBTLnRva3BvcyxcbiAgICAgICAgICAgIGVuZHBvcyA6IFMucG9zLFxuICAgICAgICAgICAgbmxiICAgIDogUy5uZXdsaW5lX2JlZm9yZSxcbiAgICAgICAgICAgIGZpbGUgICA6IGZpbGVuYW1lXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNfY29tbWVudCkge1xuICAgICAgICAgICAgcmV0LmNvbW1lbnRzX2JlZm9yZSA9IFMuY29tbWVudHNfYmVmb3JlO1xuICAgICAgICAgICAgUy5jb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgICAgIC8vIG1ha2Ugbm90ZSBvZiBhbnkgbmV3bGluZXMgaW4gdGhlIGNvbW1lbnRzIHRoYXQgY2FtZSBiZWZvcmVcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXQuY29tbWVudHNfYmVmb3JlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm5sYiA9IHJldC5ubGIgfHwgcmV0LmNvbW1lbnRzX2JlZm9yZVtpXS5ubGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Ub2tlbihyZXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBza2lwX3doaXRlc3BhY2UoKSB7XG4gICAgICAgIHdoaWxlIChXSElURVNQQUNFX0NIQVJTKHBlZWsoKSkpXG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfd2hpbGUocHJlZCkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIiwgY2gsIGkgPSAwO1xuICAgICAgICB3aGlsZSAoKGNoID0gcGVlaygpKSAmJiBwcmVkKGNoLCBpKyspKVxuICAgICAgICAgICAgcmV0ICs9IG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VfZXJyb3IoZXJyKSB7XG4gICAgICAgIGpzX2Vycm9yKGVyciwgZmlsZW5hbWUsIFMudG9rbGluZSwgUy50b2tjb2wsIFMudG9rcG9zKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZF9udW0ocHJlZml4KSB7XG4gICAgICAgIHZhciBoYXNfZSA9IGZhbHNlLCBhZnRlcl9lID0gZmFsc2UsIGhhc194ID0gZmFsc2UsIGhhc19kb3QgPSBwcmVmaXggPT0gXCIuXCI7XG4gICAgICAgIHZhciBudW0gPSByZWFkX3doaWxlKGZ1bmN0aW9uKGNoLCBpKXtcbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDEyMDogY2FzZSA4ODogLy8geFhcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzX3ggPyBmYWxzZSA6IChoYXNfeCA9IHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDEwMTogY2FzZSA2OTogLy8gZUVcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzX3ggPyB0cnVlIDogaGFzX2UgPyBmYWxzZSA6IChoYXNfZSA9IGFmdGVyX2UgPSB0cnVlKTtcbiAgICAgICAgICAgICAgY2FzZSA0NTogLy8gLVxuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlcl9lIHx8IChpID09IDAgJiYgIXByZWZpeCk7XG4gICAgICAgICAgICAgIGNhc2UgNDM6IC8vICtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJfZTtcbiAgICAgICAgICAgICAgY2FzZSAoYWZ0ZXJfZSA9IGZhbHNlLCA0Nik6IC8vIC5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCFoYXNfZG90ICYmICFoYXNfeCAmJiAhaGFzX2UpID8gKGhhc19kb3QgPSB0cnVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzX2FscGhhbnVtZXJpY19jaGFyKGNvZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZWZpeCkgbnVtID0gcHJlZml4ICsgbnVtO1xuICAgICAgICB2YXIgdmFsaWQgPSBwYXJzZV9qc19udW1iZXIobnVtKTtcbiAgICAgICAgaWYgKCFpc05hTih2YWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbihcIm51bVwiLCB2YWxpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZV9lcnJvcihcIkludmFsaWQgc3ludGF4OiBcIiArIG51bSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVhZF9lc2NhcGVkX2NoYXIoaW5fc3RyaW5nKSB7XG4gICAgICAgIHZhciBjaCA9IG5leHQodHJ1ZSwgaW5fc3RyaW5nKTtcbiAgICAgICAgc3dpdGNoIChjaC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgY2FzZSAxMTAgOiByZXR1cm4gXCJcXG5cIjtcbiAgICAgICAgICBjYXNlIDExNCA6IHJldHVybiBcIlxcclwiO1xuICAgICAgICAgIGNhc2UgMTE2IDogcmV0dXJuIFwiXFx0XCI7XG4gICAgICAgICAgY2FzZSA5OCAgOiByZXR1cm4gXCJcXGJcIjtcbiAgICAgICAgICBjYXNlIDExOCA6IHJldHVybiBcIlxcdTAwMGJcIjsgLy8gXFx2XG4gICAgICAgICAgY2FzZSAxMDIgOiByZXR1cm4gXCJcXGZcIjtcbiAgICAgICAgICBjYXNlIDQ4ICA6IHJldHVybiBcIlxcMFwiO1xuICAgICAgICAgIGNhc2UgMTIwIDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDIpKTsgLy8gXFx4XG4gICAgICAgICAgY2FzZSAxMTcgOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoZXhfYnl0ZXMoNCkpOyAvLyBcXHVcbiAgICAgICAgICBjYXNlIDEwICA6IHJldHVybiBcIlwiOyAvLyBuZXdsaW5lXG4gICAgICAgICAgZGVmYXVsdCAgOiByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGV4X2J5dGVzKG4pIHtcbiAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgIGZvciAoOyBuID4gMDsgLS1uKSB7XG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBwYXJzZUludChuZXh0KHRydWUpLCAxNik7XG4gICAgICAgICAgICBpZiAoaXNOYU4oZGlnaXQpKVxuICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiSW52YWxpZCBoZXgtY2hhcmFjdGVyIHBhdHRlcm4gaW4gc3RyaW5nXCIpO1xuICAgICAgICAgICAgbnVtID0gKG51bSA8PCA0KSB8IGRpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfTtcblxuICAgIHZhciByZWFkX3N0cmluZyA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiLCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcXVvdGUgPSBuZXh0KCksIHJldCA9IFwiXCI7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IG5leHQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIE9jdGFsRXNjYXBlU2VxdWVuY2UgKFhYWDogZGVwcmVjYXRlZCBpZiBcInN0cmljdCBtb2RlXCIpXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUy9pc3N1ZXMvMTc4XG4gICAgICAgICAgICAgICAgdmFyIG9jdGFsX2xlbiA9IDAsIGZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaCA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI3XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArK29jdGFsX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0IDw9IFwiM1wiICYmIG9jdGFsX2xlbiA8PSAyKSByZXR1cm4gKytvY3RhbF9sZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdCA+PSBcIjRcIiAmJiBvY3RhbF9sZW4gPD0gMSkgcmV0dXJuICsrb2N0YWxfbGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAob2N0YWxfbGVuID4gMCkgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNoLCA4KSk7XG4gICAgICAgICAgICAgICAgZWxzZSBjaCA9IHJlYWRfZXNjYXBlZF9jaGFyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gcXVvdGUpIGJyZWFrO1xuICAgICAgICAgICAgcmV0ICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbihcInN0cmluZ1wiLCByZXQpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2tpcF9saW5lX2NvbW1lbnQodHlwZSkge1xuICAgICAgICB2YXIgcmVnZXhfYWxsb3dlZCA9IFMucmVnZXhfYWxsb3dlZDtcbiAgICAgICAgdmFyIGkgPSBmaW5kKFwiXFxuXCIpLCByZXQ7XG4gICAgICAgIGlmIChpID09IC0xKSB7XG4gICAgICAgICAgICByZXQgPSBTLnRleHQuc3Vic3RyKFMucG9zKTtcbiAgICAgICAgICAgIFMucG9zID0gUy50ZXh0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpO1xuICAgICAgICAgICAgUy5wb3MgPSBpO1xuICAgICAgICB9XG4gICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2godG9rZW4odHlwZSwgcmV0LCB0cnVlKSk7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIHJldHVybiBuZXh0X3Rva2VuKCk7XG4gICAgfTtcblxuICAgIHZhciBza2lwX211bHRpbGluZV9jb21tZW50ID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgbXVsdGlsaW5lIGNvbW1lbnRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJlZ2V4X2FsbG93ZWQgPSBTLnJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIHZhciBpID0gZmluZChcIiovXCIsIHRydWUpO1xuICAgICAgICB2YXIgdGV4dCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpO1xuICAgICAgICB2YXIgYSA9IHRleHQuc3BsaXQoXCJcXG5cIiksIG4gPSBhLmxlbmd0aDtcbiAgICAgICAgLy8gdXBkYXRlIHN0cmVhbSBwb3NpdGlvblxuICAgICAgICBTLnBvcyA9IGkgKyAyO1xuICAgICAgICBTLmxpbmUgKz0gbiAtIDE7XG4gICAgICAgIGlmIChuID4gMSkgUy5jb2wgPSBhW24gLSAxXS5sZW5ndGg7XG4gICAgICAgIGVsc2UgUy5jb2wgKz0gYVtuIC0gMV0ubGVuZ3RoO1xuICAgICAgICBTLmNvbCArPSAyO1xuICAgICAgICB2YXIgbmxiID0gUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpID49IDA7XG4gICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2godG9rZW4oXCJjb21tZW50MlwiLCB0ZXh0LCB0cnVlKSk7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBubGI7XG4gICAgICAgIHJldHVybiBuZXh0X3Rva2VuKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWFkX25hbWUoKSB7XG4gICAgICAgIHZhciBiYWNrc2xhc2ggPSBmYWxzZSwgbmFtZSA9IFwiXCIsIGNoLCBlc2NhcGVkID0gZmFsc2UsIGhleDtcbiAgICAgICAgd2hpbGUgKChjaCA9IHBlZWsoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFiYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIGVzY2FwZWQgPSBiYWNrc2xhc2ggPSB0cnVlLCBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNfaWRlbnRpZmllcl9jaGFyKGNoKSkgbmFtZSArPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCAhPSBcInVcIikgcGFyc2VfZXJyb3IoXCJFeHBlY3RpbmcgVW5pY29kZUVzY2FwZVNlcXVlbmNlIC0tIHVYWFhYXCIpO1xuICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihjaCkpIHBhcnNlX2Vycm9yKFwiVW5pY29kZSBjaGFyOiBcIiArIGNoLmNoYXJDb2RlQXQoMCkgKyBcIiBpcyBub3QgdmFsaWQgaW4gaWRlbnRpZmllclwiKTtcbiAgICAgICAgICAgICAgICBuYW1lICs9IGNoO1xuICAgICAgICAgICAgICAgIGJhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChLRVlXT1JEUyhuYW1lKSAmJiBlc2NhcGVkKSB7XG4gICAgICAgICAgICBoZXggPSBuYW1lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYW1lID0gXCJcXFxcdVwiICsgXCIwMDAwXCIuc3Vic3RyKGhleC5sZW5ndGgpICsgaGV4ICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWRfcmVnZXhwID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIsIGZ1bmN0aW9uKHJlZ2V4cCl7XG4gICAgICAgIHZhciBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlLCBjaCwgaW5fY2xhc3MgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKChjaCA9IG5leHQodHJ1ZSkpKSBpZiAocHJldl9iYWNrc2xhc2gpIHtcbiAgICAgICAgICAgIHJlZ2V4cCArPSBcIlxcXFxcIiArIGNoO1xuICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIltcIikge1xuICAgICAgICAgICAgaW5fY2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiXVwiICYmIGluX2NsYXNzKSB7XG4gICAgICAgICAgICBpbl9jbGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVnZXhwICs9IGNoO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiICYmICFpbl9jbGFzcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHByZXZfYmFja3NsYXNoID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2V4cCArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kcyA9IHJlYWRfbmFtZSgpO1xuICAgICAgICByZXR1cm4gdG9rZW4oXCJyZWdleHBcIiwgbmV3IFJlZ0V4cChyZWdleHAsIG1vZHMpKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfb3BlcmF0b3IocHJlZml4KSB7XG4gICAgICAgIGZ1bmN0aW9uIGdyb3cob3ApIHtcbiAgICAgICAgICAgIGlmICghcGVlaygpKSByZXR1cm4gb3A7XG4gICAgICAgICAgICB2YXIgYmlnZ2VyID0gb3AgKyBwZWVrKCk7XG4gICAgICAgICAgICBpZiAoT1BFUkFUT1JTKGJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3coYmlnZ2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdG9rZW4oXCJvcGVyYXRvclwiLCBncm93KHByZWZpeCB8fCBuZXh0KCkpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3NsYXNoKCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAocGVlaygpKSB7XG4gICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQxXCIpO1xuICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc2tpcF9tdWx0aWxpbmVfY29tbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTLnJlZ2V4X2FsbG93ZWQgPyByZWFkX3JlZ2V4cChcIlwiKSA6IHJlYWRfb3BlcmF0b3IoXCIvXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZG90KCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBpc19kaWdpdChwZWVrKCkuY2hhckNvZGVBdCgwKSlcbiAgICAgICAgICAgID8gcmVhZF9udW0oXCIuXCIpXG4gICAgICAgICAgICA6IHRva2VuKFwicHVuY1wiLCBcIi5cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlYWRfd29yZCgpIHtcbiAgICAgICAgdmFyIHdvcmQgPSByZWFkX25hbWUoKTtcbiAgICAgICAgaWYgKHByZXZfd2FzX2RvdCkgcmV0dXJuIHRva2VuKFwibmFtZVwiLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIEtFWVdPUkRTX0FUT00od29yZCkgPyB0b2tlbihcImF0b21cIiwgd29yZClcbiAgICAgICAgICAgIDogIUtFWVdPUkRTKHdvcmQpID8gdG9rZW4oXCJuYW1lXCIsIHdvcmQpXG4gICAgICAgICAgICA6IE9QRVJBVE9SUyh3b3JkKSA/IHRva2VuKFwib3BlcmF0b3JcIiwgd29yZClcbiAgICAgICAgICAgIDogdG9rZW4oXCJrZXl3b3JkXCIsIHdvcmQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX2VvZl9lcnJvcihlb2ZfZXJyb3IsIGNvbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnQoeCk7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4ID09PSBFWF9FT0YpIHBhcnNlX2Vycm9yKGVvZl9lcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dF90b2tlbihmb3JjZV9yZWdleHApIHtcbiAgICAgICAgaWYgKGZvcmNlX3JlZ2V4cCAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJlYWRfcmVnZXhwKGZvcmNlX3JlZ2V4cCk7XG4gICAgICAgIHNraXBfd2hpdGVzcGFjZSgpO1xuICAgICAgICBzdGFydF90b2tlbigpO1xuICAgICAgICBpZiAoaHRtbDVfY29tbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChsb29raW5nX2F0KFwiPCEtLVwiKSkge1xuICAgICAgICAgICAgICAgIGZvcndhcmQoNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXBfbGluZV9jb21tZW50KFwiY29tbWVudDNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9va2luZ19hdChcIi0tPlwiKSAmJiBTLm5ld2xpbmVfYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZCgzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tpcF9saW5lX2NvbW1lbnQoXCJjb21tZW50NFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2ggPSBwZWVrKCk7XG4gICAgICAgIGlmICghY2gpIHJldHVybiB0b2tlbihcImVvZlwiKTtcbiAgICAgICAgdmFyIGNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDM0OiBjYXNlIDM5OiByZXR1cm4gcmVhZF9zdHJpbmcoKTtcbiAgICAgICAgICBjYXNlIDQ2OiByZXR1cm4gaGFuZGxlX2RvdCgpO1xuICAgICAgICAgIGNhc2UgNDc6IHJldHVybiBoYW5kbGVfc2xhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfZGlnaXQoY29kZSkpIHJldHVybiByZWFkX251bSgpO1xuICAgICAgICBpZiAoUFVOQ19DSEFSUyhjaCkpIHJldHVybiB0b2tlbihcInB1bmNcIiwgbmV4dCgpKTtcbiAgICAgICAgaWYgKE9QRVJBVE9SX0NIQVJTKGNoKSkgcmV0dXJuIHJlYWRfb3BlcmF0b3IoKTtcbiAgICAgICAgaWYgKGNvZGUgPT0gOTIgfHwgaXNfaWRlbnRpZmllcl9zdGFydChjb2RlKSkgcmV0dXJuIHJlYWRfd29yZCgpO1xuICAgICAgICBwYXJzZV9lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuICAgIH07XG5cbiAgICBuZXh0X3Rva2VuLmNvbnRleHQgPSBmdW5jdGlvbihuYykge1xuICAgICAgICBpZiAobmMpIFMgPSBuYztcbiAgICAgICAgcmV0dXJuIFM7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXh0X3Rva2VuO1xuXG59O1xuXG4vKiAtLS0tLVsgUGFyc2VyIChjb25zdGFudHMpIF0tLS0tLSAqL1xuXG52YXIgVU5BUllfUFJFRklYID0gbWFrZVByZWRpY2F0ZShbXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZvaWRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiLS1cIixcbiAgICBcIisrXCIsXG4gICAgXCIhXCIsXG4gICAgXCJ+XCIsXG4gICAgXCItXCIsXG4gICAgXCIrXCJcbl0pO1xuXG52YXIgVU5BUllfUE9TVEZJWCA9IG1ha2VQcmVkaWNhdGUoWyBcIi0tXCIsIFwiKytcIiBdKTtcblxudmFyIEFTU0lHTk1FTlQgPSBtYWtlUHJlZGljYXRlKFsgXCI9XCIsIFwiKz1cIiwgXCItPVwiLCBcIi89XCIsIFwiKj1cIiwgXCIlPVwiLCBcIj4+PVwiLCBcIjw8PVwiLCBcIj4+Pj1cIiwgXCJ8PVwiLCBcIl49XCIsIFwiJj1cIiBdKTtcblxudmFyIFBSRUNFREVOQ0UgPSAoZnVuY3Rpb24oYSwgcmV0KXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGIgPSBhW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHJldFtiW2pdXSA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59KShcbiAgICBbXG4gICAgICAgIFtcInx8XCJdLFxuICAgICAgICBbXCImJlwiXSxcbiAgICAgICAgW1wifFwiXSxcbiAgICAgICAgW1wiXlwiXSxcbiAgICAgICAgW1wiJlwiXSxcbiAgICAgICAgW1wiPT1cIiwgXCI9PT1cIiwgXCIhPVwiLCBcIiE9PVwiXSxcbiAgICAgICAgW1wiPFwiLCBcIj5cIiwgXCI8PVwiLCBcIj49XCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCJdLFxuICAgICAgICBbXCI+PlwiLCBcIjw8XCIsIFwiPj4+XCJdLFxuICAgICAgICBbXCIrXCIsIFwiLVwiXSxcbiAgICAgICAgW1wiKlwiLCBcIi9cIiwgXCIlXCJdXG4gICAgXSxcbiAgICB7fVxuKTtcblxudmFyIFNUQVRFTUVOVFNfV0lUSF9MQUJFTFMgPSBhcnJheV90b19oYXNoKFsgXCJmb1wiICsgXCJyXCIsIFwiZG9cIiwgXCJ3aGlsZVwiLCBcInN3aXRjaFwiIF0pO1xuXG52YXIgQVRPTUlDX1NUQVJUX1RPS0VOID0gYXJyYXlfdG9faGFzaChbIFwiYXRvbVwiLCBcIm51bVwiLCBcInN0cmluZ1wiLCBcInJlZ2V4cFwiLCBcIm5hbWVcIiBdKTtcblxuLyogLS0tLS1bIFBhcnNlciBdLS0tLS0gKi9cblxuZnVuY3Rpb24gcGFyc2UoJFRFWFQsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHN0cmljdCAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGZpbGVuYW1lICAgICAgIDogbnVsbCxcbiAgICAgICAgdG9wbGV2ZWwgICAgICAgOiBudWxsLFxuICAgICAgICBleHByZXNzaW9uICAgICA6IGZhbHNlLFxuICAgICAgICBodG1sNV9jb21tZW50cyA6IHRydWUsXG4gICAgfSk7XG5cbiAgICB2YXIgUyA9IHtcbiAgICAgICAgaW5wdXQgICAgICAgICA6ICh0eXBlb2YgJFRFWFQgPT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgID8gdG9rZW5pemVyKCRURVhULCBvcHRpb25zLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaHRtbDVfY29tbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiAkVEVYVCksXG4gICAgICAgIHRva2VuICAgICAgICAgOiBudWxsLFxuICAgICAgICBwcmV2ICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcGVla2VkICAgICAgICA6IG51bGwsXG4gICAgICAgIGluX2Z1bmN0aW9uICAgOiAwLFxuICAgICAgICBpbl9kaXJlY3RpdmVzIDogdHJ1ZSxcbiAgICAgICAgaW5fbG9vcCAgICAgICA6IDAsXG4gICAgICAgIGxhYmVscyAgICAgICAgOiBbXVxuICAgIH07XG5cbiAgICBTLnRva2VuID0gbmV4dCgpO1xuXG4gICAgZnVuY3Rpb24gaXModHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzX3Rva2VuKFMudG9rZW4sIHR5cGUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGVlaygpIHsgcmV0dXJuIFMucGVla2VkIHx8IChTLnBlZWtlZCA9IFMuaW5wdXQoKSk7IH07XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBTLnByZXYgPSBTLnRva2VuO1xuICAgICAgICBpZiAoUy5wZWVrZWQpIHtcbiAgICAgICAgICAgIFMudG9rZW4gPSBTLnBlZWtlZDtcbiAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KCk7XG4gICAgICAgIH1cbiAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gUy5pbl9kaXJlY3RpdmVzICYmIChcbiAgICAgICAgICAgIFMudG9rZW4udHlwZSA9PSBcInN0cmluZ1wiIHx8IGlzKFwicHVuY1wiLCBcIjtcIilcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIFMudG9rZW47XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIHJldHVybiBTLnByZXY7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyb2FrKG1zZywgbGluZSwgY29sLCBwb3MpIHtcbiAgICAgICAgdmFyIGN0eCA9IFMuaW5wdXQuY29udGV4dCgpO1xuICAgICAgICBqc19lcnJvcihtc2csXG4gICAgICAgICAgICAgICAgIGN0eC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgbGluZSAhPSBudWxsID8gbGluZSA6IGN0eC50b2tsaW5lLFxuICAgICAgICAgICAgICAgICBjb2wgIT0gbnVsbCA/IGNvbCA6IGN0eC50b2tjb2wsXG4gICAgICAgICAgICAgICAgIHBvcyAhPSBudWxsID8gcG9zIDogY3R4LnRva3Bvcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRva2VuX2Vycm9yKHRva2VuLCBtc2cpIHtcbiAgICAgICAgY3JvYWsobXNnLCB0b2tlbi5saW5lLCB0b2tlbi5jb2wpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgdG9rZW4gPSBTLnRva2VuO1xuICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXCJVbmV4cGVjdGVkIHRva2VuOiBcIiArIHRva2VuLnR5cGUgKyBcIiAoXCIgKyB0b2tlbi52YWx1ZSArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXhwZWN0X3Rva2VuKHR5cGUsIHZhbCkge1xuICAgICAgICBpZiAoaXModHlwZSwgdmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbl9lcnJvcihTLnRva2VuLCBcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBTLnRva2VuLnR5cGUgKyBcIiDCq1wiICsgUy50b2tlbi52YWx1ZSArIFwiwrtcIiArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUgKyBcIiDCq1wiICsgdmFsICsgXCLCu1wiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHB1bmMpIHsgcmV0dXJuIGV4cGVjdF90b2tlbihcInB1bmNcIiwgcHVuYyk7IH07XG5cbiAgICBmdW5jdGlvbiBjYW5faW5zZXJ0X3NlbWljb2xvbigpIHtcbiAgICAgICAgcmV0dXJuICFvcHRpb25zLnN0cmljdCAmJiAoXG4gICAgICAgICAgICBTLnRva2VuLm5sYiB8fCBpcyhcImVvZlwiKSB8fCBpcyhcInB1bmNcIiwgXCJ9XCIpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNlbWljb2xvbigpIHtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIjtcIikpIG5leHQoKTtcbiAgICAgICAgZWxzZSBpZiAoIWNhbl9pbnNlcnRfc2VtaWNvbG9uKCkpIHVuZXhwZWN0ZWQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXNlZCgpIHtcbiAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgdmFyIGV4cCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVtYmVkX3Rva2VucyhwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIHZhciBleHByID0gcGFyc2VyKCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gcHJldigpO1xuICAgICAgICAgICAgZXhwci5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgZXhwci5lbmQgPSBlbmQ7XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlX3JlZ2V4cCgpIHtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCIvXCIpIHx8IGlzKFwib3BlcmF0b3JcIiwgXCIvPVwiKSkge1xuICAgICAgICAgICAgUy5wZWVrZWQgPSBudWxsO1xuICAgICAgICAgICAgUy50b2tlbiA9IFMuaW5wdXQoUy50b2tlbi52YWx1ZS5zdWJzdHIoMSkpOyAvLyBmb3JjZSByZWdleHBcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVtZW50ID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG1wO1xuICAgICAgICBoYW5kbGVfcmVnZXhwKCk7XG4gICAgICAgIHN3aXRjaCAoUy50b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdmFyIGRpciA9IFMuaW5fZGlyZWN0aXZlcywgc3RhdCA9IHNpbXBsZV9zdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIFhYWHYyOiBkZWNpZGUgaG93IHRvIGZpeCBkaXJlY3RpdmVzXG4gICAgICAgICAgICBpZiAoZGlyICYmIHN0YXQuYm9keSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgJiYgIWlzKFwicHVuY1wiLCBcIixcIikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGlyZWN0aXZlKHsgdmFsdWU6IHN0YXQuYm9keS52YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0O1xuICAgICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG5cbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzX3Rva2VuKHBlZWsoKSwgXCJwdW5jXCIsIFwiOlwiKVxuICAgICAgICAgICAgICAgID8gbGFiZWxlZF9zdGF0ZW1lbnQoKVxuICAgICAgICAgICAgICAgIDogc2ltcGxlX3N0YXRlbWVudCgpO1xuXG4gICAgICAgICAgY2FzZSBcInB1bmNcIjpcbiAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Jsb2NrU3RhdGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0VtcHR5U3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgIHN3aXRjaCAodG1wID0gUy50b2tlbi52YWx1ZSwgbmV4dCgpLCB0bXApIHtcbiAgICAgICAgICAgICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoQVNUX0JyZWFrKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtfY29udChBU1RfQ29udGludWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z2dlclwiOlxuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RlYnVnZ2VyKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImRvXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRG8oe1xuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgOiBpbl9sb29wKHN0YXRlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA6IChleHBlY3RfdG9rZW4oXCJrZXl3b3JkXCIsIFwid2hpbGVcIiksIHRtcCA9IHBhcmVudGhlc2lzZWQoKSwgc2VtaWNvbG9uKCksIHRtcClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwid2hpbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9XaGlsZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA6IHBhcmVudGhlc2lzZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgIDogaW5fbG9vcChzdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImZvXCIgKyBcInJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9yXygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl8oQVNUX0RlZnVuKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgICAgICAgIGlmIChTLmluX2Z1bmN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9SZXR1cm4oe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKCBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKG5leHQoKSwgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYW5faW5zZXJ0X3NlbWljb2xvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICh0bXAgPSBleHByZXNzaW9uKHRydWUpLCBzZW1pY29sb24oKSwgdG1wKSApXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInN3aXRjaFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1N3aXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBwYXJlbnRoZXNpc2VkKCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBpbl9sb29wKHN3aXRjaF9ib2R5XylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgICAgICAgICBpZiAoUy50b2tlbi5ubGIpXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyICd0aHJvdydcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGhyb3coe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKHRtcCA9IGV4cHJlc3Npb24odHJ1ZSksIHNlbWljb2xvbigpLCB0bXApXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInRyeVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnlfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInZhclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0bXAgPSB2YXJfKCksIHNlbWljb2xvbigpLCB0bXA7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImNvbnN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcCA9IGNvbnN0XygpLCBzZW1pY29sb24oKSwgdG1wO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ3aXRoXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfV2l0aCh7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBwYXJlbnRoZXNpc2VkKCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBzdGF0ZW1lbnQoKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsYWJlbGVkX3N0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gYXNfc3ltYm9sKEFTVF9MYWJlbCk7XG4gICAgICAgIGlmIChmaW5kX2lmKGZ1bmN0aW9uKGwpeyByZXR1cm4gbC5uYW1lID09IGxhYmVsLm5hbWUgfSwgUy5sYWJlbHMpKSB7XG4gICAgICAgICAgICAvLyBFQ01BLTI2MiwgMTIuMTI6IEFuIEVDTUFTY3JpcHQgcHJvZ3JhbSBpcyBjb25zaWRlcmVkXG4gICAgICAgICAgICAvLyBzeW50YWN0aWNhbGx5IGluY29ycmVjdCBpZiBpdCBjb250YWlucyBhXG4gICAgICAgICAgICAvLyBMYWJlbGxlZFN0YXRlbWVudCB0aGF0IGlzIGVuY2xvc2VkIGJ5IGFcbiAgICAgICAgICAgIC8vIExhYmVsbGVkU3RhdGVtZW50IHdpdGggdGhlIHNhbWUgSWRlbnRpZmllciBhcyBsYWJlbC5cbiAgICAgICAgICAgIGNyb2FrKFwiTGFiZWwgXCIgKyBsYWJlbC5uYW1lICsgXCIgZGVmaW5lZCB0d2ljZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICBTLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnQoKTtcbiAgICAgICAgUy5sYWJlbHMucG9wKCk7XG4gICAgICAgIGlmICghKHN0YXQgaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGBjb250aW51ZWAgdGhhdCByZWZlcnMgdG8gdGhpcyBsYWJlbC5cbiAgICAgICAgICAgIC8vIHRob3NlIHNob3VsZCBiZSByZXBvcnRlZCBhcyBzeW50YXggZXJyb3JzLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzI4N1xuICAgICAgICAgICAgbGFiZWwucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlZil7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIEFTVF9Db250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWYgPSByZWYubGFiZWwuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiQ29udGludWUgbGFiZWwgYFwiICsgbGFiZWwubmFtZSArIFwiYCByZWZlcnMgdG8gbm9uLUl0ZXJhdGlvblN0YXRlbWVudC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmxpbmUsIHJlZi5jb2wsIHJlZi5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0xhYmVsZWRTdGF0ZW1lbnQoeyBib2R5OiBzdGF0LCBsYWJlbDogbGFiZWwgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNpbXBsZV9zdGF0ZW1lbnQodG1wKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1NpbXBsZVN0YXRlbWVudCh7IGJvZHk6ICh0bXAgPSBleHByZXNzaW9uKHRydWUpLCBzZW1pY29sb24oKSwgdG1wKSB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnJlYWtfY29udCh0eXBlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG51bGwsIGxkZWY7XG4gICAgICAgIGlmICghY2FuX2luc2VydF9zZW1pY29sb24oKSkge1xuICAgICAgICAgICAgbGFiZWwgPSBhc19zeW1ib2woQVNUX0xhYmVsUmVmLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGRlZiA9IGZpbmRfaWYoZnVuY3Rpb24obCl7IHJldHVybiBsLm5hbWUgPT0gbGFiZWwubmFtZSB9LCBTLmxhYmVscyk7XG4gICAgICAgICAgICBpZiAoIWxkZWYpXG4gICAgICAgICAgICAgICAgY3JvYWsoXCJVbmRlZmluZWQgbGFiZWwgXCIgKyBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIGxhYmVsLnRoZWRlZiA9IGxkZWY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUy5pbl9sb29wID09IDApXG4gICAgICAgICAgICBjcm9hayh0eXBlLlRZUEUgKyBcIiBub3QgaW5zaWRlIGEgbG9vcCBvciBzd2l0Y2hcIik7XG4gICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICB2YXIgc3RhdCA9IG5ldyB0eXBlKHsgbGFiZWw6IGxhYmVsIH0pO1xuICAgICAgICBpZiAobGRlZikgbGRlZi5yZWZlcmVuY2VzLnB1c2goc3RhdCk7XG4gICAgICAgIHJldHVybiBzdGF0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JfKCkge1xuICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICB2YXIgaW5pdCA9IG51bGw7XG4gICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiO1wiKSkge1xuICAgICAgICAgICAgaW5pdCA9IGlzKFwia2V5d29yZFwiLCBcInZhclwiKVxuICAgICAgICAgICAgICAgID8gKG5leHQoKSwgdmFyXyh0cnVlKSlcbiAgICAgICAgICAgICAgICA6IGV4cHJlc3Npb24odHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcImluXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQgaW5zdGFuY2VvZiBBU1RfVmFyICYmIGluaXQuZGVmaW5pdGlvbnMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJPbmx5IG9uZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBhbGxvd2VkIGluIGZvci4uaW4gbG9vcFwiKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcl9pbihpbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVndWxhcl9mb3IoaW5pdCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlZ3VsYXJfZm9yKGluaXQpIHtcbiAgICAgICAgZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgdmFyIHRlc3QgPSBpcyhcInB1bmNcIiwgXCI7XCIpID8gbnVsbCA6IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIjtcIik7XG4gICAgICAgIHZhciBzdGVwID0gaXMoXCJwdW5jXCIsIFwiKVwiKSA/IG51bGwgOiBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3Ioe1xuICAgICAgICAgICAgaW5pdCAgICAgIDogaW5pdCxcbiAgICAgICAgICAgIGNvbmRpdGlvbiA6IHRlc3QsXG4gICAgICAgICAgICBzdGVwICAgICAgOiBzdGVwLFxuICAgICAgICAgICAgYm9keSAgICAgIDogaW5fbG9vcChzdGF0ZW1lbnQpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JfaW4oaW5pdCkge1xuICAgICAgICB2YXIgbGhzID0gaW5pdCBpbnN0YW5jZW9mIEFTVF9WYXIgPyBpbml0LmRlZmluaXRpb25zWzBdLm5hbWUgOiBudWxsO1xuICAgICAgICB2YXIgb2JqID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfRm9ySW4oe1xuICAgICAgICAgICAgaW5pdCAgIDogaW5pdCxcbiAgICAgICAgICAgIG5hbWUgICA6IGxocyxcbiAgICAgICAgICAgIG9iamVjdCA6IG9iaixcbiAgICAgICAgICAgIGJvZHkgICA6IGluX2xvb3Aoc3RhdGVtZW50KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGZ1bmN0aW9uXyA9IGZ1bmN0aW9uKGN0b3IpIHtcbiAgICAgICAgdmFyIGluX3N0YXRlbWVudCA9IGN0b3IgPT09IEFTVF9EZWZ1bjtcbiAgICAgICAgdmFyIG5hbWUgPSBpcyhcIm5hbWVcIikgPyBhc19zeW1ib2woaW5fc3RhdGVtZW50ID8gQVNUX1N5bWJvbERlZnVuIDogQVNUX1N5bWJvbExhbWJkYSkgOiBudWxsO1xuICAgICAgICBpZiAoaW5fc3RhdGVtZW50ICYmICFuYW1lKVxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3Ioe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ25hbWVzOiAoZnVuY3Rpb24oZmlyc3QsIGEpe1xuICAgICAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGFzX3N5bWJvbChBU1RfU3ltYm9sRnVuYXJnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0pKHRydWUsIFtdKSxcbiAgICAgICAgICAgIGJvZHk6IChmdW5jdGlvbihsb29wLCBsYWJlbHMpe1xuICAgICAgICAgICAgICAgICsrUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFMuaW5fbG9vcCA9IDA7XG4gICAgICAgICAgICAgICAgUy5sYWJlbHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGJsb2NrXygpO1xuICAgICAgICAgICAgICAgIC0tUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICBTLmluX2xvb3AgPSBsb29wO1xuICAgICAgICAgICAgICAgIFMubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSkoUy5pbl9sb29wLCBTLmxhYmVscylcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlmXygpIHtcbiAgICAgICAgdmFyIGNvbmQgPSBwYXJlbnRoZXNpc2VkKCksIGJvZHkgPSBzdGF0ZW1lbnQoKSwgYmVsc2UgPSBudWxsO1xuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZWxzZVwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYmVsc2UgPSBzdGF0ZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVF9JZih7XG4gICAgICAgICAgICBjb25kaXRpb24gICA6IGNvbmQsXG4gICAgICAgICAgICBib2R5ICAgICAgICA6IGJvZHksXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IGJlbHNlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBibG9ja18oKSB7XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgaWYgKGlzKFwiZW9mXCIpKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICBhLnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHN3aXRjaF9ib2R5XygpIHtcbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgdmFyIGEgPSBbXSwgY3VyID0gbnVsbCwgYnJhbmNoID0gbnVsbCwgdG1wO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgIGlmIChpcyhcImVvZlwiKSkgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImNhc2VcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhbmNoKSBicmFuY2guZW5kID0gcHJldigpO1xuICAgICAgICAgICAgICAgIGN1ciA9IFtdO1xuICAgICAgICAgICAgICAgIGJyYW5jaCA9IG5ldyBBU1RfQ2FzZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiAodG1wID0gUy50b2tlbiwgbmV4dCgpLCB0bXApLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcmVzc2lvbih0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IGN1clxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGEucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpcyhcImtleXdvcmRcIiwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICBicmFuY2ggPSBuZXcgQVNUX0RlZmF1bHQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA6ICh0bXAgPSBTLnRva2VuLCBuZXh0KCksIGV4cGVjdChcIjpcIiksIHRtcCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgIDogY3VyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGJyYW5jaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cikgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgIGN1ci5wdXNoKHN0YXRlbWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoKSBicmFuY2guZW5kID0gcHJldigpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cnlfKCkge1xuICAgICAgICB2YXIgYm9keSA9IGJsb2NrXygpLCBiY2F0Y2ggPSBudWxsLCBiZmluYWxseSA9IG51bGw7XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXRjaFwiKSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFzX3N5bWJvbChBU1RfU3ltYm9sQ2F0Y2gpO1xuICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgIGJjYXRjaCA9IG5ldyBBU1RfQ2F0Y2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBhcmduYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICBib2R5ICAgIDogYmxvY2tfKCksXG4gICAgICAgICAgICAgICAgZW5kICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImZpbmFsbHlcIikpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBiZmluYWxseSA9IG5ldyBBU1RfRmluYWxseSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBib2R5ICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJjYXRjaCAmJiAhYmZpbmFsbHkpXG4gICAgICAgICAgICBjcm9hayhcIk1pc3NpbmcgY2F0Y2gvZmluYWxseSBibG9ja3NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1RyeSh7XG4gICAgICAgICAgICBib2R5ICAgICA6IGJvZHksXG4gICAgICAgICAgICBiY2F0Y2ggICA6IGJjYXRjaCxcbiAgICAgICAgICAgIGJmaW5hbGx5IDogYmZpbmFsbHlcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHZhcmRlZnMobm9faW4sIGluX2NvbnN0KSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX1ZhckRlZih7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgICAgIG5hbWUgIDogYXNfc3ltYm9sKGluX2NvbnN0ID8gQVNUX1N5bWJvbENvbnN0IDogQVNUX1N5bWJvbFZhciksXG4gICAgICAgICAgICAgICAgdmFsdWUgOiBpcyhcIm9wZXJhdG9yXCIsIFwiPVwiKSA/IChuZXh0KCksIGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSkgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIixcIikpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIHZhciB2YXJfID0gZnVuY3Rpb24obm9faW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVmFyKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogcHJldigpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBmYWxzZSksXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnN0XyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Db25zdCh7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHByZXYoKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25zIDogdmFyZGVmcyhmYWxzZSwgdHJ1ZSksXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG5ld18gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgZXhwZWN0X3Rva2VuKFwib3BlcmF0b3JcIiwgXCJuZXdcIik7XG4gICAgICAgIHZhciBuZXdleHAgPSBleHByX2F0b20oZmFsc2UpLCBhcmdzO1xuICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiKFwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYXJncyA9IGV4cHJfbGlzdChcIilcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9OZXcoe1xuICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IG5ld2V4cCxcbiAgICAgICAgICAgIGFyZ3MgICAgICAgOiBhcmdzLFxuICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX2F0b21fbm9kZSgpIHtcbiAgICAgICAgdmFyIHRvayA9IFMudG9rZW4sIHJldDtcbiAgICAgICAgc3dpdGNoICh0b2sudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgIHJldCA9IF9tYWtlX3N5bWJvbChBU1RfU3ltYm9sUmVmKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJudW1cIjpcbiAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfTnVtYmVyKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2ssIHZhbHVlOiB0b2sudmFsdWUgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX1N0cmluZyh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rLCB2YWx1ZTogdG9rLnZhbHVlIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlZ2V4cFwiOlxuICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9SZWdFeHAoeyBzdGFydDogdG9rLCBlbmQ6IHRvaywgdmFsdWU6IHRvay52YWx1ZSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhdG9tXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKHRvay52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgQVNUX0ZhbHNlKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2sgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9UcnVlKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2sgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9OdWxsKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2sgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHZhciBleHByX2F0b20gPSBmdW5jdGlvbihhbGxvd19jYWxscykge1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIm5ld1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld18oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICBpZiAoaXMoXCJwdW5jXCIpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXJ0LnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBleCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXguc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBleC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZXgsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcnJheV8oKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG9iamVjdF8oKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbl8oQVNUX0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIGZ1bmMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGZ1bmMuZW5kID0gcHJldigpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZnVuYywgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBVE9NSUNfU1RBUlRfVE9LRU5bUy50b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXNfYXRvbV9ub2RlKCksIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cHJfbGlzdChjbG9zaW5nLCBhbGxvd190cmFpbGluZ19jb21tYSwgYWxsb3dfZW1wdHkpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBjbG9zaW5nKSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICBpZiAoYWxsb3dfdHJhaWxpbmdfY29tbWEgJiYgaXMoXCJwdW5jXCIsIGNsb3NpbmcpKSBicmVhaztcbiAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIsXCIpICYmIGFsbG93X2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfSG9sZSh7IHN0YXJ0OiBTLnRva2VuLCBlbmQ6IFMudG9rZW4gfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIHZhciBhcnJheV8gPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChcIltcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0FycmF5KHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBleHByX2xpc3QoXCJdXCIsICFvcHRpb25zLnN0cmljdCwgdHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb2JqZWN0XyA9IGVtYmVkX3Rva2VucyhmdW5jdGlvbigpIHtcbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIn1cIikpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpcyhcInB1bmNcIiwgXCJ9XCIpKVxuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRyYWlsaW5nIGNvbW1hXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBzdGFydC50eXBlO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hbWVcIiAmJiAhaXMoXCJwdW5jXCIsIFwiOlwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiZ2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfT2JqZWN0R2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgICA6IGFzX2F0b21fbm9kZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBmdW5jdGlvbl8oQVNUX0FjY2Vzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfT2JqZWN0U2V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgICA6IGFzX2F0b21fbm9kZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBmdW5jdGlvbl8oQVNUX0FjY2Vzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX09iamVjdEtleVZhbCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBrZXkgICA6IG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgOiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0KHsgcHJvcGVydGllczogYSB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFzX3Byb3BlcnR5X25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG1wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRtcC52YWx1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHN3aXRjaCAodG1wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgIGNhc2UgXCJvcGVyYXRvclwiOlxuICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHJldHVybiB0bXAudmFsdWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfbWFrZV9zeW1ib2wodHlwZSkge1xuICAgICAgICB2YXIgbmFtZSA9IFMudG9rZW4udmFsdWU7XG4gICAgICAgIHJldHVybiBuZXcgKG5hbWUgPT0gXCJ0aGlzXCIgPyBBU1RfVGhpcyA6IHR5cGUpKHtcbiAgICAgICAgICAgIG5hbWUgIDogU3RyaW5nKG5hbWUpLFxuICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgZW5kICAgOiBTLnRva2VuXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19zeW1ib2wodHlwZSwgbm9lcnJvcikge1xuICAgICAgICBpZiAoIWlzKFwibmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCFub2Vycm9yKSBjcm9hayhcIk5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltID0gX21ha2Vfc3ltYm9sKHR5cGUpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBzeW07XG4gICAgfTtcblxuICAgIHZhciBzdWJzY3JpcHRzID0gZnVuY3Rpb24oZXhwciwgYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXhwci5zdGFydDtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIi5cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfRG90KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IGFzX25hbWUoKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9TdWIoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogcHJvcCxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd19jYWxscyAmJiBpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhuZXcgQVNUX0NhbGwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBhcmdzICAgICAgIDogZXhwcl9saXN0KFwiKVwiKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIHZhciBtYXliZV91bmFyeSA9IGZ1bmN0aW9uKGFsbG93X2NhbGxzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIpICYmIFVOQVJZX1BSRUZJWChzdGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGhhbmRsZV9yZWdleHAoKTtcbiAgICAgICAgICAgIHZhciBleCA9IG1ha2VfdW5hcnkoQVNUX1VuYXJ5UHJlZml4LCBzdGFydC52YWx1ZSwgbWF5YmVfdW5hcnkoYWxsb3dfY2FsbHMpKTtcbiAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBleC5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICByZXR1cm4gZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbCA9IGV4cHJfYXRvbShhbGxvd19jYWxscyk7XG4gICAgICAgIHdoaWxlIChpcyhcIm9wZXJhdG9yXCIpICYmIFVOQVJZX1BPU1RGSVgoUy50b2tlbi52YWx1ZSkgJiYgIVMudG9rZW4ubmxiKSB7XG4gICAgICAgICAgICB2YWwgPSBtYWtlX3VuYXJ5KEFTVF9VbmFyeVBvc3RmaXgsIFMudG9rZW4udmFsdWUsIHZhbCk7XG4gICAgICAgICAgICB2YWwuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhbC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfdW5hcnkoY3Rvciwgb3AsIGV4cHIpIHtcbiAgICAgICAgaWYgKChvcCA9PSBcIisrXCIgfHwgb3AgPT0gXCItLVwiKSAmJiAhaXNfYXNzaWduYWJsZShleHByKSlcbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCB1c2Ugb2YgXCIgKyBvcCArIFwiIG9wZXJhdG9yXCIpO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IoeyBvcGVyYXRvcjogb3AsIGV4cHJlc3Npb246IGV4cHIgfSk7XG4gICAgfTtcblxuICAgIHZhciBleHByX29wID0gZnVuY3Rpb24obGVmdCwgbWluX3ByZWMsIG5vX2luKSB7XG4gICAgICAgIHZhciBvcCA9IGlzKFwib3BlcmF0b3JcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcbiAgICAgICAgaWYgKG9wID09IFwiaW5cIiAmJiBub19pbikgb3AgPSBudWxsO1xuICAgICAgICB2YXIgcHJlYyA9IG9wICE9IG51bGwgPyBQUkVDRURFTkNFW29wXSA6IG51bGw7XG4gICAgICAgIGlmIChwcmVjICE9IG51bGwgJiYgcHJlYyA+IG1pbl9wcmVjKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBleHByX29wKG1heWJlX3VuYXJ5KHRydWUpLCBwcmVjLCBub19pbik7XG4gICAgICAgICAgICByZXR1cm4gZXhwcl9vcChuZXcgQVNUX0JpbmFyeSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgOiBsZWZ0LnN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbGVmdCxcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA6IG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogcmlnaHQsXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiByaWdodC5lbmRcbiAgICAgICAgICAgIH0pLCBtaW5fcHJlYywgbm9faW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHByX29wcyhub19pbikge1xuICAgICAgICByZXR1cm4gZXhwcl9vcChtYXliZV91bmFyeSh0cnVlKSwgMCwgbm9faW4pO1xuICAgIH07XG5cbiAgICB2YXIgbWF5YmVfY29uZGl0aW9uYWwgPSBmdW5jdGlvbihub19pbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZXhwciA9IGV4cHJfb3BzKG5vX2luKTtcbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI/XCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgeWVzID0gZXhwcmVzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uZGl0aW9uYWwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBleHByLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogeWVzLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlIDogZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfYXNzaWduYWJsZShleHByKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9UaGlzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIHx8IGV4cHIgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKTtcbiAgICB9O1xuXG4gICAgdmFyIG1heWJlX2Fzc2lnbiA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBsZWZ0ID0gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pLCB2YWwgPSBTLnRva2VuLnZhbHVlO1xuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBBU1NJR05NRU5UKHZhbCkpIHtcbiAgICAgICAgICAgIGlmIChpc19hc3NpZ25hYmxlKGxlZnQpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogbWF5YmVfYXNzaWduKG5vX2luKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBhc3NpZ25tZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbW1hcywgbm9faW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGV4cHIgPSBtYXliZV9hc3NpZ24obm9faW4pO1xuICAgICAgICBpZiAoY29tbWFzICYmIGlzKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1NlcSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgY2FyICAgIDogZXhwcixcbiAgICAgICAgICAgICAgICBjZHIgICAgOiBleHByZXNzaW9uKHRydWUsIG5vX2luKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgOiBwZWVrKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbl9sb29wKGNvbnQpIHtcbiAgICAgICAgKytTLmluX2xvb3A7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIC0tUy5pbl9sb29wO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcImVvZlwiKSlcbiAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XG4gICAgICAgIHZhciB0b3BsZXZlbCA9IG9wdGlvbnMudG9wbGV2ZWw7XG4gICAgICAgIGlmICh0b3BsZXZlbCkge1xuICAgICAgICAgICAgdG9wbGV2ZWwuYm9keSA9IHRvcGxldmVsLmJvZHkuY29uY2F0KGJvZHkpO1xuICAgICAgICAgICAgdG9wbGV2ZWwuZW5kID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSBuZXcgQVNUX1RvcGxldmVsKHsgc3RhcnQ6IHN0YXJ0LCBib2R5OiBib2R5LCBlbmQ6IGVuZCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wbGV2ZWw7XG4gICAgfSkoKTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gVHJlZSB0cmFuc2Zvcm1lciBoZWxwZXJzLlxuXG5mdW5jdGlvbiBUcmVlVHJhbnNmb3JtZXIoYmVmb3JlLCBhZnRlcikge1xuICAgIFRyZWVXYWxrZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmJlZm9yZSA9IGJlZm9yZTtcbiAgICB0aGlzLmFmdGVyID0gYWZ0ZXI7XG59XG5UcmVlVHJhbnNmb3JtZXIucHJvdG90eXBlID0gbmV3IFRyZWVXYWxrZXI7XG5cbihmdW5jdGlvbih1bmRlZmluZWQpe1xuXG4gICAgZnVuY3Rpb24gXyhub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKHR3LCBpbl9saXN0KXtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgdHcucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0dy5iZWZvcmUpIHggPSB0dy5iZWZvcmUodGhpcywgZGVzY2VuZCwgaW5fbGlzdCk7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0dy5hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZCh4LCB0dyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHcuc3RhY2tbdHcuc3RhY2subGVuZ3RoIC0gMV0gPSB4ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKHgsIHR3KTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHR3LmFmdGVyKHgsIGluX2xpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB4ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9fbGlzdChsaXN0LCB0dykge1xuICAgICAgICByZXR1cm4gTUFQKGxpc3QsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHJhbnNmb3JtKHR3LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIF8oQVNUX05vZGUsIG5vb3ApO1xuXG4gICAgXyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmxhYmVsID0gc2VsZi5sYWJlbC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0Jsb2NrLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9EV0xvb3AsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBpZiAoc2VsZi5pbml0KSBzZWxmLmluaXQgPSBzZWxmLmluaXQudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLnN0ZXApIHNlbGYuc3RlcCA9IHNlbGYuc3RlcC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0ZvckluLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuaW5pdCA9IHNlbGYuaW5pdC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLm9iamVjdCA9IHNlbGYub2JqZWN0LnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9FeGl0LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfTG9vcENvbnRyb2wsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgaWYgKHNlbGYubGFiZWwpIHNlbGYubGFiZWwgPSBzZWxmLmxhYmVsLnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5ib2R5ID0gZG9fbGlzdChzZWxmLmJvZHksIHR3KTtcbiAgICB9KTtcblxuICAgIF8oQVNUX0Nhc2UsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9UcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5ib2R5ID0gZG9fbGlzdChzZWxmLmJvZHksIHR3KTtcbiAgICAgICAgaWYgKHNlbGYuYmNhdGNoKSBzZWxmLmJjYXRjaCA9IHNlbGYuYmNhdGNoLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLmJmaW5hbGx5KSBzZWxmLmJmaW5hbGx5ID0gc2VsZi5iZmluYWxseS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQ2F0Y2gsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5hcmduYW1lID0gc2VsZi5hcmduYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9EZWZpbml0aW9ucywgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmRlZmluaXRpb25zID0gZG9fbGlzdChzZWxmLmRlZmluaXRpb25zLCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5uYW1lID0gc2VsZi5uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfTGFtYmRhLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIGlmIChzZWxmLm5hbWUpIHNlbGYubmFtZSA9IHNlbGYubmFtZS50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFyZ25hbWVzID0gZG9fbGlzdChzZWxmLmFyZ25hbWVzLCB0dyk7XG4gICAgICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFyZ3MgPSBkb19saXN0KHNlbGYuYXJncywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfU2VxLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuY2FyID0gc2VsZi5jYXIudHJhbnNmb3JtKHR3KTtcbiAgICAgICAgc2VsZi5jZHIgPSBzZWxmLmNkci50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfRG90LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLnByb3BlcnR5ID0gc2VsZi5wcm9wZXJ0eS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfVW5hcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5sZWZ0ID0gc2VsZi5sZWZ0LnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnRyYW5zZm9ybSh0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgICAgIHNlbGYuY29uc2VxdWVudCA9IHNlbGYuY29uc2VxdWVudC50cmFuc2Zvcm0odHcpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gc2VsZi5hbHRlcm5hdGl2ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfQXJyYXksIGZ1bmN0aW9uKHNlbGYsIHR3KXtcbiAgICAgICAgc2VsZi5lbGVtZW50cyA9IGRvX2xpc3Qoc2VsZi5lbGVtZW50cywgdHcpO1xuICAgIH0pO1xuXG4gICAgXyhBU1RfT2JqZWN0LCBmdW5jdGlvbihzZWxmLCB0dyl7XG4gICAgICAgIHNlbGYucHJvcGVydGllcyA9IGRvX2xpc3Qoc2VsZi5wcm9wZXJ0aWVzLCB0dyk7XG4gICAgfSk7XG5cbiAgICBfKEFTVF9PYmplY3RQcm9wZXJ0eSwgZnVuY3Rpb24oc2VsZiwgdHcpe1xuICAgICAgICBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIH0pO1xuXG59KSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBTeW1ib2xEZWYoc2NvcGUsIGluZGV4LCBvcmlnKSB7XG4gICAgdGhpcy5uYW1lID0gb3JpZy5uYW1lO1xuICAgIHRoaXMub3JpZyA9IFsgb3JpZyBdO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICB0aGlzLmdsb2JhbCA9IGZhbHNlO1xuICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gbnVsbDtcbiAgICB0aGlzLnVuZGVjbGFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxuU3ltYm9sRGVmLnByb3RvdHlwZSA9IHtcbiAgICB1bm1hbmdsZWFibGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdsb2JhbCAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy50b3BsZXZlbCkpXG4gICAgICAgICAgICB8fCB0aGlzLnVuZGVjbGFyZWRcbiAgICAgICAgICAgIHx8ICghKG9wdGlvbnMgJiYgb3B0aW9ucy5ldmFsKSAmJiAodGhpcy5zY29wZS51c2VzX2V2YWwgfHwgdGhpcy5zY29wZS51c2VzX3dpdGgpKTtcbiAgICB9LFxuICAgIG1hbmdsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMubWFuZ2xlZF9uYW1lICYmICF0aGlzLnVubWFuZ2xlYWJsZShvcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNjb3BlO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNjcmV3X2llOCAmJiB0aGlzLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKVxuICAgICAgICAgICAgICAgIHMgPSBzLnBhcmVudF9zY29wZTtcbiAgICAgICAgICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gcy5uZXh0X21hbmdsZWQob3B0aW9ucywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiZmlndXJlX291dF9zY29wZVwiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBzY3Jld19pZTg6IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvLyBwYXNzIDE6IHNldHVwIHNjb3BlIGNoYWluaW5nIGFuZCBoYW5kbGUgZGVmaW5pdGlvbnNcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjb3BlID0gc2VsZi5wYXJlbnRfc2NvcGUgPSBudWxsO1xuICAgIHZhciBkZWZ1biA9IG51bGw7XG4gICAgdmFyIG5lc3RpbmcgPSAwO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpe1xuICAgICAgICBpZiAob3B0aW9ucy5zY3Jld19pZTggJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9DYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNhdmVfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIHNjb3BlID0gbmV3IEFTVF9TY29wZShub2RlKTtcbiAgICAgICAgICAgIHNjb3BlLmluaXRfc2NvcGVfdmFycyhuZXN0aW5nKTtcbiAgICAgICAgICAgIHNjb3BlLnBhcmVudF9zY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgbm9kZS5pbml0X3Njb3BlX3ZhcnMobmVzdGluZyk7XG4gICAgICAgICAgICB2YXIgc2F2ZV9zY29wZSA9IG5vZGUucGFyZW50X3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICB2YXIgc2F2ZV9kZWZ1biA9IGRlZnVuO1xuICAgICAgICAgICAgZGVmdW4gPSBzY29wZSA9IG5vZGU7XG4gICAgICAgICAgICArK25lc3Rpbmc7IGRlc2NlbmQoKTsgLS1uZXN0aW5nO1xuICAgICAgICAgICAgc2NvcGUgPSBzYXZlX3Njb3BlO1xuICAgICAgICAgICAgZGVmdW4gPSBzYXZlX2RlZnVuO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAvLyBkb24ndCBkZXNjZW5kIGFnYWluIGluIFRyZWVXYWxrZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIG5vZGUuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIHB1c2hfdW5pcShzY29wZS5kaXJlY3RpdmVzLCBub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1dpdGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSBzY29wZTsgczsgcyA9IHMucGFyZW50X3Njb3BlKVxuICAgICAgICAgICAgICAgIHMudXNlc193aXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2wpIHtcbiAgICAgICAgICAgIG5vZGUuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMYW1iZGEpIHtcbiAgICAgICAgICAgIGRlZnVuLmRlZl9mdW5jdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlZnVuKSB7XG4gICAgICAgICAgICAvLyBDYXJlZnVsIGhlcmUsIHRoZSBzY29wZSB3aGVyZSB0aGlzIHNob3VsZCBiZSBkZWZpbmVkIGlzXG4gICAgICAgICAgICAvLyB0aGUgcGFyZW50IHNjb3BlLiAgVGhlIHJlYXNvbiBpcyB0aGF0IHdlIGVudGVyIGEgbmV3XG4gICAgICAgICAgICAvLyBzY29wZSB3aGVuIHdlIGVuY291bnRlciB0aGUgQVNUX0RlZnVuIG5vZGUgKHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBpbnN0YW5jZW9mIEFTVF9TY29wZSkgYnV0IHdlIGdldCB0byB0aGUgc3ltYm9sIGEgYml0XG4gICAgICAgICAgICAvLyBsYXRlci5cbiAgICAgICAgICAgIChub2RlLnNjb3BlID0gZGVmdW4ucGFyZW50X3Njb3BlKS5kZWZfZnVuY3Rpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xWYXJcbiAgICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xDb25zdCkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGRlZnVuLmRlZl92YXJpYWJsZShub2RlKTtcbiAgICAgICAgICAgIGRlZi5jb25zdGFudCA9IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3Q7XG4gICAgICAgICAgICBkZWYuaW5pdCA9IHR3LnBhcmVudCgpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2gpIHtcbiAgICAgICAgICAgIChvcHRpb25zLnNjcmV3X2llOCA/IHNjb3BlIDogZGVmdW4pXG4gICAgICAgICAgICAgICAgLmRlZl92YXJpYWJsZShub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYud2Fsayh0dyk7XG5cbiAgICAvLyBwYXNzIDI6IGZpbmQgYmFjayByZWZlcmVuY2VzIGFuZCBldmFsXG4gICAgdmFyIGZ1bmMgPSBudWxsO1xuICAgIHZhciBnbG9iYWxzID0gc2VsZi5nbG9iYWxzID0gbmV3IERpY3Rpb25hcnkoKTtcbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKXtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhKSB7XG4gICAgICAgICAgICB2YXIgcHJldl9mdW5jID0gZnVuYztcbiAgICAgICAgICAgIGZ1bmMgPSBub2RlO1xuICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgZnVuYyA9IHByZXZfZnVuYztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgICB2YXIgc3ltID0gbm9kZS5zY29wZS5maW5kX3ZhcmlhYmxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFzeW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZztcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFscy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZyA9IGdsb2JhbHMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGcgPSBuZXcgU3ltYm9sRGVmKHNlbGYsIGdsb2JhbHMuc2l6ZSgpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZy51bmRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZy5nbG9iYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLnNldChuYW1lLCBnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50aGVkZWYgPSBnO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiZXZhbFwiICYmIHR3LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IG5vZGUuc2NvcGU7IHMgJiYgIXMudXNlc19ldmFsOyBzID0gcy5wYXJlbnRfc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzLnVzZXNfZXZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmdW5jICYmIG5hbWUgPT0gXCJhcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLnVzZXNfYXJndW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUudGhlZGVmID0gc3ltO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2VsZi53YWxrKHR3KTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiaW5pdF9zY29wZV92YXJzXCIsIGZ1bmN0aW9uKG5lc3Rpbmcpe1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdOyAgICAgLy8gY29udGFpbnMgdGhlIGRpcmVjdGl2ZXMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlLCBpLmUuIFwidXNlIHN0cmljdFwiXG4gICAgdGhpcy52YXJpYWJsZXMgPSBuZXcgRGljdGlvbmFyeSgpOyAvLyBtYXAgbmFtZSB0byBBU1RfU3ltYm9sVmFyICh2YXJpYWJsZXMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlOyBpbmNsdWRlcyBmdW5jdGlvbnMpXG4gICAgdGhpcy5mdW5jdGlvbnMgPSBuZXcgRGljdGlvbmFyeSgpOyAvLyBtYXAgbmFtZSB0byBBU1RfU3ltYm9sRGVmdW4gKGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgc2NvcGUpXG4gICAgdGhpcy51c2VzX3dpdGggPSBmYWxzZTsgICAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoaXMgb3Igc29tZSBuZXN0ZWQgc2NvcGUgdXNlcyB0aGUgYHdpdGhgIHN0YXRlbWVudFxuICAgIHRoaXMudXNlc19ldmFsID0gZmFsc2U7ICAgLy8gd2lsbCBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGlzIG9yIG5lc3RlZCBzY29wZSB1c2VzIHRoZSBnbG9iYWwgYGV2YWxgXG4gICAgdGhpcy5wYXJlbnRfc2NvcGUgPSBudWxsOyAvLyB0aGUgcGFyZW50IHNjb3BlXG4gICAgdGhpcy5lbmNsb3NlZCA9IFtdOyAgICAgICAvLyBhIGxpc3Qgb2YgdmFyaWFibGVzIGZyb20gdGhpcyBvciBvdXRlciBzY29wZShzKSB0aGF0IGFyZSByZWZlcmVuY2VkIGZyb20gdGhpcyBvciBpbm5lciBzY29wZXNcbiAgICB0aGlzLmNuYW1lID0gLTE7ICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGluZGV4IGZvciBtYW5nbGluZyBmdW5jdGlvbnMvdmFyaWFibGVzXG4gICAgdGhpcy5uZXN0aW5nID0gbmVzdGluZzsgICAvLyB0aGUgbmVzdGluZyBsZXZlbCBvZiB0aGlzIHNjb3BlICgwIG1lYW5zIHRvcGxldmVsKVxufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJzdHJpY3RcIiwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKTtcbn0pO1xuXG5BU1RfTGFtYmRhLkRFRk1FVEhPRChcImluaXRfc2NvcGVfdmFyc1wiLCBmdW5jdGlvbigpe1xuICAgIEFTVF9TY29wZS5wcm90b3R5cGUuaW5pdF9zY29wZV92YXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy51c2VzX2FyZ3VtZW50cyA9IGZhbHNlO1xufSk7XG5cbkFTVF9TeW1ib2xSZWYuREVGTUVUSE9EKFwicmVmZXJlbmNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWYgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICBkZWYucmVmZXJlbmNlcy5wdXNoKHRoaXMpO1xuICAgIHZhciBzID0gdGhpcy5zY29wZTtcbiAgICB3aGlsZSAocykge1xuICAgICAgICBwdXNoX3VuaXEocy5lbmNsb3NlZCwgZGVmKTtcbiAgICAgICAgaWYgKHMgPT09IGRlZi5zY29wZSkgYnJlYWs7XG4gICAgICAgIHMgPSBzLnBhcmVudF9zY29wZTtcbiAgICB9XG4gICAgdGhpcy5mcmFtZSA9IHRoaXMuc2NvcGUubmVzdGluZyAtIGRlZi5zY29wZS5uZXN0aW5nO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJmaW5kX3ZhcmlhYmxlXCIsIGZ1bmN0aW9uKG5hbWUpe1xuICAgIGlmIChuYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbCkgbmFtZSA9IG5hbWUubmFtZTtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZXMuZ2V0KG5hbWUpXG4gICAgICAgIHx8ICh0aGlzLnBhcmVudF9zY29wZSAmJiB0aGlzLnBhcmVudF9zY29wZS5maW5kX3ZhcmlhYmxlKG5hbWUpKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiaGFzX2RpcmVjdGl2ZVwiLCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmhhc19kaXJlY3RpdmUodmFsdWUpXG4gICAgICAgIHx8ICh0aGlzLmRpcmVjdGl2ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCA/IHRoaXMgOiBudWxsKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZGVmX2Z1bmN0aW9uXCIsIGZ1bmN0aW9uKHN5bWJvbCl7XG4gICAgdGhpcy5mdW5jdGlvbnMuc2V0KHN5bWJvbC5uYW1lLCB0aGlzLmRlZl92YXJpYWJsZShzeW1ib2wpKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZGVmX3ZhcmlhYmxlXCIsIGZ1bmN0aW9uKHN5bWJvbCl7XG4gICAgdmFyIGRlZjtcbiAgICBpZiAoIXRoaXMudmFyaWFibGVzLmhhcyhzeW1ib2wubmFtZSkpIHtcbiAgICAgICAgZGVmID0gbmV3IFN5bWJvbERlZih0aGlzLCB0aGlzLnZhcmlhYmxlcy5zaXplKCksIHN5bWJvbCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldChzeW1ib2wubmFtZSwgZGVmKTtcbiAgICAgICAgZGVmLmdsb2JhbCA9ICF0aGlzLnBhcmVudF9zY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWYgPSB0aGlzLnZhcmlhYmxlcy5nZXQoc3ltYm9sLm5hbWUpO1xuICAgICAgICBkZWYub3JpZy5wdXNoKHN5bWJvbCk7XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2wudGhlZGVmID0gZGVmO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJuZXh0X21hbmdsZWRcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgdmFyIGV4dCA9IHRoaXMuZW5jbG9zZWQ7XG4gICAgb3V0OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbSA9IGJhc2U1NCgrK3RoaXMuY25hbWUpO1xuICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXIobSkpIGNvbnRpbnVlOyAvLyBza2lwIG92ZXIgXCJkb1wiXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzI0MiAtLSBkbyBub3RcbiAgICAgICAgLy8gc2hhZG93IGEgbmFtZSBleGNlcHRlZCBmcm9tIG1hbmdsaW5nLlxuICAgICAgICBpZiAob3B0aW9ucy5leGNlcHQuaW5kZXhPZihtKSA+PSAwKSBjb250aW51ZTtcblxuICAgICAgICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHRoZSBtYW5nbGVkIG5hbWUgZG9lcyBub3Qgc2hhZG93IGEgbmFtZVxuICAgICAgICAvLyBmcm9tIHNvbWUgcGFyZW50IHNjb3BlIHRoYXQgaXMgcmVmZXJlbmNlZCBpbiB0aGlzIG9yIGluXG4gICAgICAgIC8vIGlubmVyIHNjb3Blcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IGV4dC5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHN5bSA9IGV4dFtpXTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gc3ltLm1hbmdsZWRfbmFtZSB8fCAoc3ltLnVubWFuZ2xlYWJsZShvcHRpb25zKSAmJiBzeW0ubmFtZSk7XG4gICAgICAgICAgICBpZiAobSA9PSBuYW1lKSBjb250aW51ZSBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxufSk7XG5cbkFTVF9GdW5jdGlvbi5ERUZNRVRIT0QoXCJuZXh0X21hbmdsZWRcIiwgZnVuY3Rpb24ob3B0aW9ucywgZGVmKXtcbiAgICAvLyAjMTc5LCAjMzI2XG4gICAgLy8gaW4gU2FmYXJpIHN0cmljdCBtb2RlLCBzb21ldGhpbmcgbGlrZSAoZnVuY3Rpb24geCh4KXsuLi59KSBpcyBhIHN5bnRheCBlcnJvcjtcbiAgICAvLyBhIGZ1bmN0aW9uIGV4cHJlc3Npb24ncyBhcmd1bWVudCBjYW5ub3Qgc2hhZG93IHRoZSBmdW5jdGlvbiBleHByZXNzaW9uJ3MgbmFtZVxuXG4gICAgdmFyIHRyaWNreV9kZWYgPSBkZWYub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xGdW5hcmcgJiYgdGhpcy5uYW1lICYmIHRoaXMubmFtZS5kZWZpbml0aW9uKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBBU1RfTGFtYmRhLnByb3RvdHlwZS5uZXh0X21hbmdsZWQuY2FsbCh0aGlzLCBvcHRpb25zLCBkZWYpO1xuICAgICAgICBpZiAoISh0cmlja3lfZGVmICYmIHRyaWNreV9kZWYubWFuZ2xlZF9uYW1lID09IG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJyZWZlcmVuY2VzXCIsIGZ1bmN0aW9uKHN5bSl7XG4gICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2wpIHN5bSA9IHN5bS5kZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZW5jbG9zZWQuaW5kZXhPZihzeW0pIDwgMCA/IG51bGwgOiBzeW07XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJ1bm1hbmdsZWFibGVcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbigpLnVubWFuZ2xlYWJsZShvcHRpb25zKTtcbn0pO1xuXG4vLyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBtYW5nbGVhYmxlXG5BU1RfU3ltYm9sQWNjZXNzb3IuREVGTUVUSE9EKFwidW5tYW5nbGVhYmxlXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuLy8gbGFiZWxzIGFyZSBhbHdheXMgbWFuZ2xlYWJsZVxuQVNUX0xhYmVsLkRFRk1FVEhPRChcInVubWFuZ2xlYWJsZVwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmYWxzZTtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcInVucmVmZXJlbmNlZFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24oKS5yZWZlcmVuY2VzLmxlbmd0aCA9PSAwXG4gICAgICAgICYmICEodGhpcy5zY29wZS51c2VzX2V2YWwgfHwgdGhpcy5zY29wZS51c2VzX3dpdGgpO1xufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwidW5kZWNsYXJlZFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24oKS51bmRlY2xhcmVkO1xufSk7XG5cbkFTVF9MYWJlbFJlZi5ERUZNRVRIT0QoXCJ1bmRlY2xhcmVkXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZhbHNlO1xufSk7XG5cbkFTVF9MYWJlbC5ERUZNRVRIT0QoXCJ1bmRlY2xhcmVkXCIsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZhbHNlO1xufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwiZGVmaW5pdGlvblwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnRoZWRlZjtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcImdsb2JhbFwiLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24oKS5nbG9iYWw7XG59KTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcIl9kZWZhdWx0X21hbmdsZXJfb3B0aW9uc1wiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICByZXR1cm4gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBleGNlcHQgICA6IFtdLFxuICAgICAgICBldmFsICAgICA6IGZhbHNlLFxuICAgICAgICBzb3J0ICAgICA6IGZhbHNlLFxuICAgICAgICB0b3BsZXZlbCA6IGZhbHNlLFxuICAgICAgICBzY3Jld19pZTggOiBmYWxzZVxuICAgIH0pO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJtYW5nbGVfbmFtZXNcIiwgZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IHRoaXMuX2RlZmF1bHRfbWFuZ2xlcl9vcHRpb25zKG9wdGlvbnMpO1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBtYW5nbGUgZGVjbGFyYXRpb24gbm9kZXMuICBTcGVjaWFsIGxvZ2ljIHdpcmVkXG4gICAgLy8gaW50byB0aGUgY29kZSBnZW5lcmF0b3Igd2lsbCBkaXNwbGF5IHRoZSBtYW5nbGVkIG5hbWUgaWYgaXQnc1xuICAgIC8vIHByZXNlbnQgKGFuZCBmb3IgQVNUX1N5bWJvbFJlZi1zIGl0J2xsIHVzZSB0aGUgbWFuZ2xlZCBuYW1lIG9mXG4gICAgLy8gdGhlIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiB0aGF0IGl0IHBvaW50cyB0bykuXG4gICAgdmFyIGxuYW1lID0gLTE7XG4gICAgdmFyIHRvX21hbmdsZSA9IFtdO1xuICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpe1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbGVkU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAvLyBsbmFtZSBpcyBpbmNyZW1lbnRlZCB3aGVuIHdlIGdldCB0byB0aGUgQVNUX0xhYmVsXG4gICAgICAgICAgICB2YXIgc2F2ZV9uZXN0aW5nID0gbG5hbWU7XG4gICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICBsbmFtZSA9IHNhdmVfbmVzdGluZztcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgLy8gZG9uJ3QgZGVzY2VuZCBhZ2FpbiBpbiBUcmVlV2Fsa2VyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBwID0gdHcucGFyZW50KCksIGEgPSBbXTtcbiAgICAgICAgICAgIG5vZGUudmFyaWFibGVzLmVhY2goZnVuY3Rpb24oc3ltYm9sKXtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5leGNlcHQuaW5kZXhPZihzeW1ib2wubmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc29ydCkgYS5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBiLnJlZmVyZW5jZXMubGVuZ3RoIC0gYS5yZWZlcmVuY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9fbWFuZ2xlLnB1c2guYXBwbHkodG9fbWFuZ2xlLCBhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbCkge1xuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBkbyBuYW1lID0gYmFzZTU0KCsrbG5hbWUpOyB3aGlsZSAoIWlzX2lkZW50aWZpZXIobmFtZSkpO1xuICAgICAgICAgICAgbm9kZS5tYW5nbGVkX25hbWUgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyZXdfaWU4ICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2gpIHtcbiAgICAgICAgICAgIHRvX21hbmdsZS5wdXNoKG5vZGUuZGVmaW5pdGlvbigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsayh0dyk7XG4gICAgdG9fbWFuZ2xlLmZvckVhY2goZnVuY3Rpb24oZGVmKXsgZGVmLm1hbmdsZShvcHRpb25zKSB9KTtcbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiY29tcHV0ZV9jaGFyX2ZyZXF1ZW5jeVwiLCBmdW5jdGlvbihvcHRpb25zKXtcbiAgICBvcHRpb25zID0gdGhpcy5fZGVmYXVsdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUucHJpbnRfdG9fc3RyaW5nKCkpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1JldHVybilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInJldHVyblwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UaHJvdylcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInRocm93XCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbnRpbnVlKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiY29udGludWVcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQnJlYWspXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJicmVha1wiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWJ1Z2dlcilcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImRlYnVnZ2VyXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihub2RlLnZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9XaGlsZSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcIndoaWxlXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZG8gd2hpbGVcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcImlmXCIpO1xuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRpdmUpIGJhc2U1NC5jb25zaWRlcihcImVsc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9WYXIpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJ2YXJcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uc3QpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJjb25zdFwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJmdW5jdGlvblwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3IpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJmb1wiICsgXCJyXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0ZvckluKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZm9yIGluXCIpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N3aXRjaClcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcInN3aXRjaFwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYXNlKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiY2FzZVwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZGVmYXVsdFwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9XaXRoKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwid2l0aFwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RTZXR0ZXIpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJzZXRcIiArIG5vZGUua2V5KTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RHZXR0ZXIpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJnZXRcIiArIG5vZGUua2V5KTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIobm9kZS5rZXkpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX05ldylcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihcIm5ld1wiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UaGlzKVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwidGhpc1wiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UcnkpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJ0cnlcIik7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2F0Y2gpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIoXCJjYXRjaFwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9GaW5hbGx5KVxuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiZmluYWxseVwiKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2wgJiYgbm9kZS51bm1hbmdsZWFibGUob3B0aW9ucykpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIobm9kZS5uYW1lKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9VbmFyeSB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0JpbmFyeSlcbiAgICAgICAgICAgIGJhc2U1NC5jb25zaWRlcihub2RlLm9wZXJhdG9yKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3QpXG4gICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIobm9kZS5wcm9wZXJ0eSk7XG4gICAgfSk7XG4gICAgdGhpcy53YWxrKHR3KTtcbiAgICBiYXNlNTQuc29ydCgpO1xufSk7XG5cbnZhciBiYXNlNTQgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfMDEyMzQ1Njc4OVwiO1xuICAgIHZhciBjaGFycywgZnJlcXVlbmN5O1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBmcmVxdWVuY3kgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjaGFycyA9IHN0cmluZy5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oY2gpeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSB9KTtcbiAgICAgICAgY2hhcnMuZm9yRWFjaChmdW5jdGlvbihjaCl7IGZyZXF1ZW5jeVtjaF0gPSAwIH0pO1xuICAgIH1cbiAgICBiYXNlNTQuY29uc2lkZXIgPSBmdW5jdGlvbihzdHIpe1xuICAgICAgICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNvZGUgaW4gZnJlcXVlbmN5KSArK2ZyZXF1ZW5jeVtjb2RlXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYmFzZTU0LnNvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2hhcnMgPSBtZXJnZVNvcnQoY2hhcnMsIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICAgICAgaWYgKGlzX2RpZ2l0KGEpICYmICFpc19kaWdpdChiKSkgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoaXNfZGlnaXQoYikgJiYgIWlzX2RpZ2l0KGEpKSByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gZnJlcXVlbmN5W2JdIC0gZnJlcXVlbmN5W2FdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGJhc2U1NC5yZXNldCA9IHJlc2V0O1xuICAgIHJlc2V0KCk7XG4gICAgYmFzZTU0LmdldCA9IGZ1bmN0aW9uKCl7IHJldHVybiBjaGFycyB9O1xuICAgIGJhc2U1NC5mcmVxID0gZnVuY3Rpb24oKXsgcmV0dXJuIGZyZXF1ZW5jeSB9O1xuICAgIGZ1bmN0aW9uIGJhc2U1NChudW0pIHtcbiAgICAgICAgdmFyIHJldCA9IFwiXCIsIGJhc2UgPSA1NDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcnNbbnVtICUgYmFzZV0pO1xuICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBiYXNlKTtcbiAgICAgICAgICAgIGJhc2UgPSA2NDtcbiAgICAgICAgfSB3aGlsZSAobnVtID4gMCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gYmFzZTU0O1xufSkoKTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcInNjb3BlX3dhcm5pbmdzXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHVuZGVjbGFyZWQgICAgICAgOiBmYWxzZSwgLy8gdGhpcyBtYWtlcyBhIGxvdCBvZiBub2lzZVxuICAgICAgICB1bnJlZmVyZW5jZWQgICAgIDogdHJ1ZSxcbiAgICAgICAgYXNzaWduX3RvX2dsb2JhbCA6IHRydWUsXG4gICAgICAgIGZ1bmNfYXJndW1lbnRzICAgOiB0cnVlLFxuICAgICAgICBuZXN0ZWRfZGVmdW5zICAgIDogdHJ1ZSxcbiAgICAgICAgZXZhbCAgICAgICAgICAgICA6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgaWYgKG9wdGlvbnMudW5kZWNsYXJlZFxuICAgICAgICAgICAgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIG5vZGUudW5kZWNsYXJlZCgpKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBYWFg6IHRoaXMgYWxzbyB3YXJucyBhYm91dCBKUyBzdGFuZGFyZCBuYW1lcyxcbiAgICAgICAgICAgIC8vIGkuZS4gT2JqZWN0LCBBcnJheSwgcGFyc2VJbnQgZXRjLiAgU2hvdWxkIGFkZCBhIGxpc3Qgb2ZcbiAgICAgICAgICAgIC8vIGV4Y2VwdGlvbnMuXG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwiVW5kZWNsYXJlZCBzeW1ib2w6IHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICBmaWxlOiBub2RlLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgbGluZTogbm9kZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogbm9kZS5zdGFydC5jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbl90b19nbG9iYWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzeW0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduICYmIG5vZGUubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpXG4gICAgICAgICAgICAgICAgc3ltID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3JJbiAmJiBub2RlLmluaXQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKVxuICAgICAgICAgICAgICAgIHN5bSA9IG5vZGUuaW5pdDtcbiAgICAgICAgICAgIGlmIChzeW1cbiAgICAgICAgICAgICAgICAmJiAoc3ltLnVuZGVjbGFyZWQoKVxuICAgICAgICAgICAgICAgICAgICB8fCAoc3ltLmdsb2JhbCgpICYmIHN5bS5zY29wZSAhPT0gc3ltLmRlZmluaXRpb24oKS5zY29wZSkpKSB7XG4gICAgICAgICAgICAgICAgQVNUX05vZGUud2FybihcInttc2d9OiB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnOiBzeW0udW5kZWNsYXJlZCgpID8gXCJBY2NpZGVudGFsIGdsb2JhbD9cIiA6IFwiQXNzaWdubWVudCB0byBnbG9iYWxcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IHN5bS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBzeW0uc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiBzeW0uc3RhcnQuY29sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZXZhbFxuICAgICAgICAgICAgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIG5vZGUudW5kZWNsYXJlZCgpXG4gICAgICAgICAgICAmJiBub2RlLm5hbWUgPT0gXCJldmFsXCIpIHtcbiAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJFdmFsIGlzIHVzZWQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIG5vZGUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnVucmVmZXJlbmNlZFxuICAgICAgICAgICAgJiYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24gfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbClcbiAgICAgICAgICAgICYmIG5vZGUudW5yZWZlcmVuY2VkKCkpIHtcbiAgICAgICAgICAgIEFTVF9Ob2RlLndhcm4oXCJ7dHlwZX0ge25hbWV9IGlzIGRlY2xhcmVkIGJ1dCBub3QgcmVmZXJlbmNlZCBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWwgPyBcIkxhYmVsXCIgOiBcIlN5bWJvbFwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICBmaWxlOiBub2RlLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgbGluZTogbm9kZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogbm9kZS5zdGFydC5jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZ1bmNfYXJndW1lbnRzXG4gICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgJiYgbm9kZS51c2VzX2FyZ3VtZW50cykge1xuICAgICAgICAgICAgQVNUX05vZGUud2FybihcImFyZ3VtZW50cyB1c2VkIGluIGZ1bmN0aW9uIHtuYW1lfSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSA/IG5vZGUubmFtZS5uYW1lIDogXCJhbm9ueW1vdXNcIixcbiAgICAgICAgICAgICAgICBmaWxlOiBub2RlLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgbGluZTogbm9kZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogbm9kZS5zdGFydC5jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5lc3RlZF9kZWZ1bnNcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW5cbiAgICAgICAgICAgICYmICEodHcucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfU2NvcGUpKSB7XG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuKFwiRnVuY3Rpb24ge25hbWV9IGRlY2xhcmVkIGluIG5lc3RlZCBzdGF0ZW1lbnQgXFxcInt0eXBlfVxcXCIgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0dy5wYXJlbnQoKS5UWVBFLFxuICAgICAgICAgICAgICAgIGZpbGU6IG5vZGUuc3RhcnQuZmlsZSxcbiAgICAgICAgICAgICAgICBsaW5lOiBub2RlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgY29sOiBub2RlLnN0YXJ0LmNvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndhbGsodHcpO1xufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIE91dHB1dFN0cmVhbShvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBpbmRlbnRfc3RhcnQgICAgIDogMCxcbiAgICAgICAgaW5kZW50X2xldmVsICAgICA6IDQsXG4gICAgICAgIHF1b3RlX2tleXMgICAgICAgOiBmYWxzZSxcbiAgICAgICAgc3BhY2VfY29sb24gICAgICA6IHRydWUsXG4gICAgICAgIGFzY2lpX29ubHkgICAgICAgOiBmYWxzZSxcbiAgICAgICAgdW5lc2NhcGVfcmVnZXhwcyA6IGZhbHNlLFxuICAgICAgICBpbmxpbmVfc2NyaXB0ICAgIDogZmFsc2UsXG4gICAgICAgIHdpZHRoICAgICAgICAgICAgOiA4MCxcbiAgICAgICAgbWF4X2xpbmVfbGVuICAgICA6IDMyMDAwLFxuICAgICAgICBiZWF1dGlmeSAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHNvdXJjZV9tYXAgICAgICAgOiBudWxsLFxuICAgICAgICBicmFja2V0aXplICAgICAgIDogZmFsc2UsXG4gICAgICAgIHNlbWljb2xvbnMgICAgICAgOiB0cnVlLFxuICAgICAgICBjb21tZW50cyAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlX2xpbmUgICAgOiBmYWxzZSxcbiAgICAgICAgc2NyZXdfaWU4ICAgICAgICA6IGZhbHNlLFxuICAgICAgICBwcmVhbWJsZSAgICAgICAgIDogbnVsbCxcbiAgICB9LCB0cnVlKTtcblxuICAgIHZhciBpbmRlbnRhdGlvbiA9IDA7XG4gICAgdmFyIGN1cnJlbnRfY29sID0gMDtcbiAgICB2YXIgY3VycmVudF9saW5lID0gMTtcbiAgICB2YXIgY3VycmVudF9wb3MgPSAwO1xuICAgIHZhciBPVVRQVVQgPSBcIlwiO1xuXG4gICAgZnVuY3Rpb24gdG9fYXNjaWkoc3RyLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTAwODAtXFx1ZmZmZl0vZywgZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAoY29kZS5sZW5ndGggPD0gMiAmJiAhaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8IDIpIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHhcIiArIGNvZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8IDQpIGNvZGUgPSBcIjBcIiArIGNvZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArIGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX3N0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIGRxID0gMCwgc3EgPSAwO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvW1xcXFxcXGJcXGZcXG5cXHJcXHRcXHgyMlxceDI3XFx1MjAyOFxcdTIwMjlcXDBdL2csIGZ1bmN0aW9uKHMpe1xuICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXGJcIjogcmV0dXJuIFwiXFxcXGJcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcZlwiOiByZXR1cm4gXCJcXFxcZlwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6IHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjogcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjogcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6IHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgICBjYXNlICdcIic6ICsrZHE7IHJldHVybiAnXCInO1xuICAgICAgICAgICAgICBjYXNlIFwiJ1wiOiArK3NxOyByZXR1cm4gXCInXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXDBcIjogcmV0dXJuIFwiXFxcXHgwMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5hc2NpaV9vbmx5KSBzdHIgPSB0b19hc2NpaShzdHIpO1xuICAgICAgICBpZiAoZHEgPiBzcSkgcmV0dXJuIFwiJ1wiICsgc3RyLnJlcGxhY2UoL1xceDI3L2csIFwiXFxcXCdcIikgKyBcIidcIjtcbiAgICAgICAgZWxzZSByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC9cXHgyMi9nLCAnXFxcXFwiJykgKyAnXCInO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbmNvZGVfc3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgcmV0ID0gbWFrZV9zdHJpbmcoc3RyKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5saW5lX3NjcmlwdClcbiAgICAgICAgICAgIHJldCA9IHJldC5yZXBsYWNlKC88XFx4MmZzY3JpcHQoWz5cXC9cXHRcXG5cXGZcXHIgXSkvZ2ksIFwiPFxcXFwvc2NyaXB0JDFcIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfbmFtZShuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmFzY2lpX29ubHkpXG4gICAgICAgICAgICBuYW1lID0gdG9fYXNjaWkobmFtZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX2luZGVudChiYWNrKSB7XG4gICAgICAgIHJldHVybiByZXBlYXRfc3RyaW5nKFwiIFwiLCBvcHRpb25zLmluZGVudF9zdGFydCArIGluZGVudGF0aW9uIC0gYmFjayAqIG9wdGlvbnMuaW5kZW50X2xldmVsKTtcbiAgICB9O1xuXG4gICAgLyogLS0tLS1bIGJlYXV0aWZpY2F0aW9uL21pbmlmaWNhdGlvbiBdLS0tLS0gKi9cblxuICAgIHZhciBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgdmFyIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgdmFyIGxhc3QgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gbGFzdF9jaGFyKCkge1xuICAgICAgICByZXR1cm4gbGFzdC5jaGFyQXQobGFzdC5sZW5ndGggLSAxKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVfbmV3bGluZSgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4X2xpbmVfbGVuICYmIGN1cnJlbnRfY29sID4gb3B0aW9ucy5tYXhfbGluZV9sZW4pXG4gICAgICAgICAgICBwcmludChcIlxcblwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcXVpcmVTZW1pY29sb25DaGFycyA9IG1ha2VQcmVkaWNhdGUoXCIoIFsgKyAqIC8gLSAsIC5cIik7XG5cbiAgICBmdW5jdGlvbiBwcmludChzdHIpIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgIGlmIChtaWdodF9uZWVkX3NlbWljb2xvbikge1xuICAgICAgICAgICAgaWYgKCghY2ggfHwgXCI7fVwiLmluZGV4T2YoY2gpIDwgMCkgJiYgIS9bO10kLy50ZXN0KGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VtaWNvbG9ucyB8fCByZXF1aXJlU2VtaWNvbG9uQ2hhcnMoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9VVFBVVCArPSBcIjtcIjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jb2wrKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPVVRQVVQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmJlYXV0aWZ5KVxuICAgICAgICAgICAgICAgICAgICBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICAgICAgbWF5YmVfbmV3bGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmJlYXV0aWZ5ICYmIG9wdGlvbnMucHJlc2VydmVfbGluZSAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldF9saW5lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uc3RhcnQubGluZTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50X2xpbmUgPCB0YXJnZXRfbGluZSkge1xuICAgICAgICAgICAgICAgIE9VVFBVVCArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9saW5lKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9jb2wgPSAwO1xuICAgICAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaWdodF9uZWVkX3NwYWNlKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IGxhc3RfY2hhcigpO1xuICAgICAgICAgICAgaWYgKChpc19pZGVudGlmaWVyX2NoYXIocHJldilcbiAgICAgICAgICAgICAgICAgJiYgKGlzX2lkZW50aWZpZXJfY2hhcihjaCkgfHwgY2ggPT0gXCJcXFxcXCIpKVxuICAgICAgICAgICAgICAgIHx8ICgvXltcXCtcXC1cXC9dJC8udGVzdChjaCkgJiYgY2ggPT0gcHJldikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgT1VUUFVUICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pLCBuID0gYS5sZW5ndGggLSAxO1xuICAgICAgICBjdXJyZW50X2xpbmUgKz0gbjtcbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgY3VycmVudF9jb2wgKz0gYVtuXS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50X2NvbCA9IGFbbl0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRfcG9zICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIGxhc3QgPSBzdHI7XG4gICAgICAgIE9VVFBVVCArPSBzdHI7XG4gICAgfTtcblxuICAgIHZhciBzcGFjZSA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJpbnQoXCIgXCIpO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBpbmRlbnQgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oaGFsZikge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWF1dGlmeSkge1xuICAgICAgICAgICAgcHJpbnQobWFrZV9pbmRlbnQoaGFsZiA/IDAuNSA6IDApKTtcbiAgICAgICAgfVxuICAgIH0gOiBub29wO1xuXG4gICAgdmFyIHdpdGhfaW5kZW50ID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKGNvbCwgY29udCkge1xuICAgICAgICBpZiAoY29sID09PSB0cnVlKSBjb2wgPSBuZXh0X2luZGVudCgpO1xuICAgICAgICB2YXIgc2F2ZV9pbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICBpbmRlbnRhdGlvbiA9IGNvbDtcbiAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgaW5kZW50YXRpb24gPSBzYXZlX2luZGVudGF0aW9uO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0gOiBmdW5jdGlvbihjb2wsIGNvbnQpIHsgcmV0dXJuIGNvbnQoKSB9O1xuXG4gICAgdmFyIG5ld2xpbmUgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgIH0gOiBub29wO1xuXG4gICAgdmFyIHNlbWljb2xvbiA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJpbnQoXCI7XCIpO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbWlnaHRfbmVlZF9zZW1pY29sb24gPSB0cnVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JjZV9zZW1pY29sb24oKSB7XG4gICAgICAgIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgICAgIHByaW50KFwiO1wiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbmV4dF9pbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiBpbmRlbnRhdGlvbiArIG9wdGlvbnMuaW5kZW50X2xldmVsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX2Jsb2NrKGNvbnQpIHtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgcHJpbnQoXCJ7XCIpO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIHdpdGhfaW5kZW50KG5leHRfaW5kZW50KCksIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgcHJpbnQoXCJ9XCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3aXRoX3BhcmVucyhjb250KSB7XG4gICAgICAgIHByaW50KFwiKFwiKTtcbiAgICAgICAgLy9YWFg6IHN0aWxsIG5pY2UgdG8gaGF2ZSB0aGF0IGZvciBhcmd1bWVudCBsaXN0c1xuICAgICAgICAvL3ZhciByZXQgPSB3aXRoX2luZGVudChjdXJyZW50X2NvbCwgY29udCk7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIHByaW50KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd2l0aF9zcXVhcmUoY29udCkge1xuICAgICAgICBwcmludChcIltcIik7XG4gICAgICAgIC8vdmFyIHJldCA9IHdpdGhfaW5kZW50KGN1cnJlbnRfY29sLCBjb250KTtcbiAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgcHJpbnQoXCJdXCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb21tYSgpIHtcbiAgICAgICAgcHJpbnQoXCIsXCIpO1xuICAgICAgICBzcGFjZSgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb2xvbigpIHtcbiAgICAgICAgcHJpbnQoXCI6XCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5zcGFjZV9jb2xvbikgc3BhY2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZF9tYXBwaW5nID0gb3B0aW9ucy5zb3VyY2VfbWFwID8gZnVuY3Rpb24odG9rZW4sIG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0b2tlbikgb3B0aW9ucy5zb3VyY2VfbWFwLmFkZChcbiAgICAgICAgICAgICAgICB0b2tlbi5maWxlIHx8IFwiP1wiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbGluZSwgY3VycmVudF9jb2wsXG4gICAgICAgICAgICAgICAgdG9rZW4ubGluZSwgdG9rZW4uY29sLFxuICAgICAgICAgICAgICAgICghbmFtZSAmJiB0b2tlbi50eXBlID09IFwibmFtZVwiKSA/IHRva2VuLnZhbHVlIDogbmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgQVNUX05vZGUud2FybihcIkNvdWxkbid0IGZpZ3VyZSBvdXQgbWFwcGluZyBmb3Ige2ZpbGV9OntsaW5lfSx7Y29sfSDihpIge2NsaW5lfSx7Y2NvbH0gW3tuYW1lfV1cIiwge1xuICAgICAgICAgICAgICAgIGZpbGU6IHRva2VuLmZpbGUsXG4gICAgICAgICAgICAgICAgbGluZTogdG9rZW4ubGluZSxcbiAgICAgICAgICAgICAgICBjb2w6IHRva2VuLmNvbCxcbiAgICAgICAgICAgICAgICBjbGluZTogY3VycmVudF9saW5lLFxuICAgICAgICAgICAgICAgIGNjb2w6IGN1cnJlbnRfY29sLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwgXCJcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0gOiBub29wO1xuXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gT1VUUFVUO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5wcmVhbWJsZSkge1xuICAgICAgICBwcmludChvcHRpb25zLnByZWFtYmxlLnJlcGxhY2UoL1xcclxcbj98W1xcblxcdTIwMjhcXHUyMDI5XXxcXHMqJC9nLCBcIlxcblwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0ICAgICAgICAgICAgIDogZ2V0LFxuICAgICAgICB0b1N0cmluZyAgICAgICAgOiBnZXQsXG4gICAgICAgIGluZGVudCAgICAgICAgICA6IGluZGVudCxcbiAgICAgICAgaW5kZW50YXRpb24gICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBpbmRlbnRhdGlvbiB9LFxuICAgICAgICBjdXJyZW50X3dpZHRoICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRfY29sIC0gaW5kZW50YXRpb24gfSxcbiAgICAgICAgc2hvdWxkX2JyZWFrICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBvcHRpb25zLndpZHRoICYmIHRoaXMuY3VycmVudF93aWR0aCgpID49IG9wdGlvbnMud2lkdGggfSxcbiAgICAgICAgbmV3bGluZSAgICAgICAgIDogbmV3bGluZSxcbiAgICAgICAgcHJpbnQgICAgICAgICAgIDogcHJpbnQsXG4gICAgICAgIHNwYWNlICAgICAgICAgICA6IHNwYWNlLFxuICAgICAgICBjb21tYSAgICAgICAgICAgOiBjb21tYSxcbiAgICAgICAgY29sb24gICAgICAgICAgIDogY29sb24sXG4gICAgICAgIGxhc3QgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGFzdCB9LFxuICAgICAgICBzZW1pY29sb24gICAgICAgOiBzZW1pY29sb24sXG4gICAgICAgIGZvcmNlX3NlbWljb2xvbiA6IGZvcmNlX3NlbWljb2xvbixcbiAgICAgICAgdG9fYXNjaWkgICAgICAgIDogdG9fYXNjaWksXG4gICAgICAgIHByaW50X25hbWUgICAgICA6IGZ1bmN0aW9uKG5hbWUpIHsgcHJpbnQobWFrZV9uYW1lKG5hbWUpKSB9LFxuICAgICAgICBwcmludF9zdHJpbmcgICAgOiBmdW5jdGlvbihzdHIpIHsgcHJpbnQoZW5jb2RlX3N0cmluZyhzdHIpKSB9LFxuICAgICAgICBuZXh0X2luZGVudCAgICAgOiBuZXh0X2luZGVudCxcbiAgICAgICAgd2l0aF9pbmRlbnQgICAgIDogd2l0aF9pbmRlbnQsXG4gICAgICAgIHdpdGhfYmxvY2sgICAgICA6IHdpdGhfYmxvY2ssXG4gICAgICAgIHdpdGhfcGFyZW5zICAgICA6IHdpdGhfcGFyZW5zLFxuICAgICAgICB3aXRoX3NxdWFyZSAgICAgOiB3aXRoX3NxdWFyZSxcbiAgICAgICAgYWRkX21hcHBpbmcgICAgIDogYWRkX21hcHBpbmcsXG4gICAgICAgIG9wdGlvbiAgICAgICAgICA6IGZ1bmN0aW9uKG9wdCkgeyByZXR1cm4gb3B0aW9uc1tvcHRdIH0sXG4gICAgICAgIGxpbmUgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9saW5lIH0sXG4gICAgICAgIGNvbCAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VycmVudF9jb2wgfSxcbiAgICAgICAgcG9zICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X3BvcyB9LFxuICAgICAgICBwdXNoX25vZGUgICAgICAgOiBmdW5jdGlvbihub2RlKSB7IHN0YWNrLnB1c2gobm9kZSkgfSxcbiAgICAgICAgcG9wX25vZGUgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzdGFjay5wb3AoKSB9LFxuICAgICAgICBzdGFjayAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWNrIH0sXG4gICAgICAgIHBhcmVudCAgICAgICAgICA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAyIC0gKG4gfHwgMCldO1xuICAgICAgICB9XG4gICAgfTtcblxufTtcblxuLyogLS0tLS1bIGNvZGUgZ2VuZXJhdG9ycyBdLS0tLS0gKi9cblxuKGZ1bmN0aW9uKCl7XG5cbiAgICAvKiAtLS0tLVsgdXRpbHMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZQUklOVChub2RldHlwZSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIG5vZGV0eXBlLkRFRk1FVEhPRChcIl9jb2RlZ2VuXCIsIGdlbmVyYXRvcik7XG4gICAgfTtcblxuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcInByaW50XCIsIGZ1bmN0aW9uKHN0cmVhbSwgZm9yY2VfcGFyZW5zKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBnZW5lcmF0b3IgPSBzZWxmLl9jb2RlZ2VuO1xuICAgICAgICBmdW5jdGlvbiBkb2l0KCkge1xuICAgICAgICAgICAgc2VsZi5hZGRfY29tbWVudHMoc3RyZWFtKTtcbiAgICAgICAgICAgIHNlbGYuYWRkX3NvdXJjZV9tYXAoc3RyZWFtKTtcbiAgICAgICAgICAgIGdlbmVyYXRvcihzZWxmLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wdXNoX25vZGUoc2VsZik7XG4gICAgICAgIGlmIChmb3JjZV9wYXJlbnMgfHwgc2VsZi5uZWVkc19wYXJlbnMoc3RyZWFtKSkge1xuICAgICAgICAgICAgc3RyZWFtLndpdGhfcGFyZW5zKGRvaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb3Bfbm9kZSgpO1xuICAgIH0pO1xuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwicHJpbnRfdG9fc3RyaW5nXCIsIGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgICB2YXIgcyA9IE91dHB1dFN0cmVhbShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wcmludChzKTtcbiAgICAgICAgcmV0dXJuIHMuZ2V0KCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgY29tbWVudHMgXS0tLS0tICovXG5cbiAgICBBU1RfTm9kZS5ERUZNRVRIT0QoXCJhZGRfY29tbWVudHNcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIGMgPSBvdXRwdXQub3B0aW9uKFwiY29tbWVudHNcIiksIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2VsZi5zdGFydDtcbiAgICAgICAgICAgIGlmIChzdGFydCAmJiAhc3RhcnQuX2NvbW1lbnRzX2R1bXBlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Ll9jb21tZW50c19kdW1wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIFhYWDogdWdseSBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy8xMTJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIGFuZCBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMzcyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfRXhpdCAmJiBzZWxmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudmFsdWUud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXJ0ICYmIG5vZGUuc3RhcnQuY29tbWVudHNfYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQobm9kZS5zdGFydC5jb21tZW50c19iZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQuY29tbWVudHNfYmVmb3JlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZG9uJ3QgZ28gaW5zaWRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmZpbHRlcihmdW5jdGlvbihjb21tZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnRlc3QoY29tbWVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGNvbW1lbnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMoc2VsZiwgY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGMpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoL2NvbW1lbnRbMTM0XS8udGVzdChjLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIvL1wiICsgYy52YWx1ZSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMudHlwZSA9PSBcImNvbW1lbnQyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi8qXCIgKyBjLnZhbHVlICsgXCIqL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5ubGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgUEFSRU5USEVTRVMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBQQVJFTlMobm9kZXR5cGUsIGZ1bmMpIHtcbiAgICAgICAgbm9kZXR5cGUuREVGTUVUSE9EKFwibmVlZHNfcGFyZW5zXCIsIGZ1bmMpO1xuICAgIH07XG5cbiAgICBQQVJFTlMoQVNUX05vZGUsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8vIGEgZnVuY3Rpb24gZXhwcmVzc2lvbiBuZWVkcyBwYXJlbnMgYXJvdW5kIGl0IHdoZW4gaXQncyBwcm92YWJseVxuICAgIC8vIHRoZSBmaXJzdCB0b2tlbiB0byBhcHBlYXIgaW4gYSBzdGF0ZW1lbnQuXG4gICAgUEFSRU5TKEFTVF9GdW5jdGlvbiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgcmV0dXJuIGZpcnN0X2luX3N0YXRlbWVudChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gc2FtZSBnb2VzIGZvciBhbiBvYmplY3QgbGl0ZXJhbCwgYmVjYXVzZSBvdGhlcndpc2UgaXQgd291bGQgYmVcbiAgICAvLyBpbnRlcnByZXRlZCBhcyBhIGJsb2NrIG9mIGNvZGUuXG4gICAgUEFSRU5TKEFTVF9PYmplY3QsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHJldHVybiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfVW5hcnksIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcztcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfU2VxLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAgICAgICAgICAgICAvLyAoZm9vLCBiYXIpKCkgb3IgZm9vKDEsICgyLCAzKSwgNClcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfVW5hcnkgICAgICAgICAgICAvLyAhKGZvbywgYmFyLCBiYXopXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAgICAgICAgICAgLy8gMSArICgyLCAzKSArIDQgPT0+IDhcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfVmFyRGVmICAgICAgICAgICAvLyB2YXIgYSA9ICgxLCAyKSwgYiA9IGEgKyBhOyA9PT4gYiA9PSA0XG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgICAgICAgLy8gKDEsIHtmb286Mn0pLmZvbyBvciAoMSwge2ZvbzoyfSlbXCJmb29cIl0gPT0+IDJcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQXJyYXkgICAgICAgICAgICAvLyBbIDEsICgyLCAzKSwgNCBdID09PiBbIDEsIDMsIDQgXVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSAgIC8vIHsgZm9vOiAoMSwgMikgfS5mb28gPT0+IDJcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgICAgICAvKiAoZmFsc2UsIHRydWUpID8gKGEgPSAxMCwgYiA9IDIwKSA6IChjID0gMzApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogPT0+IDIwIChzaWRlIGVmZmVjdCwgc2V0IGEgOj0gMTAgYW5kIGIgOj0gMjApICovXG4gICAgICAgIDtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfQmluYXJ5LCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgLy8gKGZvbyAmJiBiYXIpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gdHlwZW9mIChmb28gJiYgYmFyKVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoZm9vICYmIGJhcilbXCJwcm9wXCJdLCAoZm9vICYmIGJhcikucHJvcFxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyB0aGlzIGRlYWxzIHdpdGggcHJlY2VkZW5jZTogMyAqICgyICsgMSlcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KSB7XG4gICAgICAgICAgICB2YXIgcG8gPSBwLm9wZXJhdG9yLCBwcCA9IFBSRUNFREVOQ0VbcG9dO1xuICAgICAgICAgICAgdmFyIHNvID0gdGhpcy5vcGVyYXRvciwgc3AgPSBQUkVDRURFTkNFW3NvXTtcbiAgICAgICAgICAgIGlmIChwcCA+IHNwXG4gICAgICAgICAgICAgICAgfHwgKHBwID09IHNwXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMgPT09IHAucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfUHJvcEFjY2VzcywgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX05ldyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIC8vIGkuZS4gbmV3IChmb28uYmFyKCkuYmF6KVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgb25lIGNhbGwgaW50byB0aGlzIHN1YnRyZWUsIHRoZW4gd2UgbmVlZFxuICAgICAgICAgICAgLy8gcGFyZW5zIGFyb3VuZCBpdCB0b28sIG90aGVyd2lzZSB0aGUgY2FsbCB3aWxsIGJlXG4gICAgICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBwYXNzaW5nIHRoZSBhcmd1bWVudHMgdG8gdGhlIHVwcGVyIE5ld1xuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsKSB0aHJvdyBwO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggIT09IHApIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0NhbGwsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpLCBwMTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIFNhZmFyaSBidWcuXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM1MDZcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvblxuICAgICAgICAgICAgJiYgcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXNcbiAgICAgICAgICAgICYmIChwMSA9IG91dHB1dC5wYXJlbnQoMSkpIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgJiYgcDEubGVmdCA9PT0gcDtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTmV3LCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKG5vX2NvbnN0cnVjdG9yX3BhcmVucyh0aGlzLCBvdXRwdXQpXG4gICAgICAgICAgICAmJiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIC8vIChuZXcgRGF0ZSkuZ2V0VGltZSgpLCAobmV3IERhdGUpW1wiZ2V0VGltZVwiXSgpXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykpIC8vIChuZXcgZm9vKShiYXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfTnVtYmVyLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA8IDAgJiYgcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9OYU4sIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYXNzaWduX2FuZF9jb25kaXRpb25hbF9wYXJlbl9ydWxlcyhvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vICEoYSA9IGZhbHNlKSDihpIgdHJ1ZVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAxICsgKGEgPSAyKSArIDMg4oaSIDYsIHNpZGUgZWZmZWN0IHNldHRpbmcgYSA9IDJcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmICEocCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZnVuYykoKSDigJRvcuKAlCBuZXcgKGEgPSBPYmplY3QpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGEgPSBmb28pID8gYmFyIDogYmF6XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICYmIHAuY29uZGl0aW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZm9vKVtcInByb3BcIl0g4oCUb3LigJQgKGEgPSBmb28pLnByb3BcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgUEFSRU5TKEFTVF9Bc3NpZ24sIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMpO1xuICAgIFBBUkVOUyhBU1RfQ29uZGl0aW9uYWwsIGFzc2lnbl9hbmRfY29uZGl0aW9uYWxfcGFyZW5fcnVsZXMpO1xuXG4gICAgLyogLS0tLS1bIFBSSU5URVJTIF0tLS0tLSAqL1xuXG4gICAgREVGUFJJTlQoQVNUX0RpcmVjdGl2ZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhzZWxmLnZhbHVlKTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZGVidWdnZXJcIik7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBzdGF0ZW1lbnRzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gZGlzcGxheV9ib2R5KGJvZHksIGlzX3RvcGxldmVsLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGJvZHkuZm9yRWFjaChmdW5jdGlvbihzdG10LCBpKXtcbiAgICAgICAgICAgIGlmICghKHN0bXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoIShpID09IGxhc3QgJiYgaXNfdG9wbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc190b3BsZXZlbCkgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBBU1RfU3RhdGVtZW50V2l0aEJvZHkuREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHRoaXMuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIERFRlBSSU5UKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1RvcGxldmVsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBkaXNwbGF5X2JvZHkoc2VsZi5ib2R5LCB0cnVlLCBvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubGFiZWwucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcHJpbnRfYnJhY2tldGVkKGJvZHksIG91dHB1dCkge1xuICAgICAgICBpZiAoYm9keS5sZW5ndGggPiAwKSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgZGlzcGxheV9ib2R5KGJvZHksIGZhbHNlLCBvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICB9O1xuICAgIERFRlBSSU5UKEFTVF9CbG9ja1N0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRW1wdHlTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRG8sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImRvXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwid2hpbGVcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1doaWxlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ3aGlsZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0ZvciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZm9cIiArIFwiclwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCAmJiAhKHNlbGYuaW5pdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbml0IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5pdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2l6ZV9mb3Jfbm9pbihzZWxmLmluaXQsIG91dHB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIjtcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIjtcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5zdGVwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdGVwLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Gb3JJbiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZm9cIiArIFwiclwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5pbml0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImluXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLm9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwid2l0aFwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGZ1bmN0aW9ucyBdLS0tLS0gKi9cbiAgICBBU1RfTGFtYmRhLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIG5va2V5d29yZCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFub2tleXdvcmQpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm5hbWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmFyZ25hbWVzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgYXJnLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9MYW1iZGEsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZXhpdHMgXS0tLS0tICovXG4gICAgQVNUX0V4aXQuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCl7XG4gICAgICAgIG91dHB1dC5wcmludChraW5kKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfUmV0dXJuLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQsIFwicmV0dXJuXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9UaHJvdywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInRocm93XCIpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGxvb3AgY29udHJvbCBdLS0tLS0gKi9cbiAgICBBU1RfTG9vcENvbnRyb2wuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCl7XG4gICAgICAgIG91dHB1dC5wcmludChraW5kKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQnJlYWssIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJicmVha1wiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29udGludWUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb250aW51ZVwiKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBpZiBdLS0tLS0gKi9cbiAgICBmdW5jdGlvbiBtYWtlX3RoZW4oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwiYnJhY2tldGl6ZVwiKSkge1xuICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHNxdWVlemVyIHJlcGxhY2VzIFwiYmxvY2tcIi1zIHRoYXQgY29udGFpbiBvbmx5IGEgc2luZ2xlXG4gICAgICAgIC8vIHN0YXRlbWVudCB3aXRoIHRoZSBzdGF0ZW1lbnQgaXRzZWxmOyB0ZWNobmljYWxseSwgdGhlIEFTVFxuICAgICAgICAvLyBpcyBjb3JyZWN0LCBidXQgdGhpcyBjYW4gY3JlYXRlIHByb2JsZW1zIHdoZW4gd2Ugb3V0cHV0IGFuXG4gICAgICAgIC8vIElGIGhhdmluZyBhbiBFTFNFIGNsYXVzZSB3aGVyZSB0aGUgVEhFTiBjbGF1c2UgZW5kcyBpbiBhblxuICAgICAgICAvLyBJRiAqd2l0aG91dCogYW4gRUxTRSBibG9jayAodGhlbiB0aGUgb3V0ZXIgRUxTRSB3b3VsZCByZWZlclxuICAgICAgICAvLyB0byB0aGUgaW5uZXIgSUYpLiAgVGhpcyBmdW5jdGlvbiBjaGVja3MgZm9yIHRoaXMgY2FzZSBhbmRcbiAgICAgICAgLy8gYWRkcyB0aGUgYmxvY2sgYnJhY2tldHMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIXNlbGYuYm9keSlcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQuZm9yY2Vfc2VtaWNvbG9uKCk7XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRG9cbiAgICAgICAgICAgICYmICFvdXRwdXQub3B0aW9uKFwic2NyZXdfaWU4XCIpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTL2lzc3Vlcy8jaXNzdWUvNTcgSUVcbiAgICAgICAgICAgIC8vIGNyb2FrcyB3aXRoIFwic3ludGF4IGVycm9yXCIgb24gY29kZSBsaWtlIHRoaXM6IGlmIChmb28pXG4gICAgICAgICAgICAvLyBkbyAuLi4gd2hpbGUoY29uZCk7IGVsc2UgLi4uICB3ZSBuZWVkIGJsb2NrIGJyYWNrZXRzXG4gICAgICAgICAgICAvLyBhcm91bmQgZG8vd2hpbGVcbiAgICAgICAgICAgIG1ha2VfYmxvY2soc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gc2VsZi5ib2R5O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWIuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IGIuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFdpdGhCb2R5KSB7XG4gICAgICAgICAgICAgICAgYiA9IGIuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIERFRlBSSU5UKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiaWZcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIG1ha2VfdGhlbihzZWxmLCBvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJlbHNlXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBmb3JjZV9zdGF0ZW1lbnQoc2VsZi5hbHRlcm5hdGl2ZSwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIHN3aXRjaCBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfU3dpdGNoLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJzd2l0Y2hcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIGlmIChzZWxmLmJvZHkubGVuZ3RoID4gMCkgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHN0bXQsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgIH0pO1xuICAgIEFTVF9Td2l0Y2hCcmFuY2guREVGTUVUSE9EKFwiX2RvX3ByaW50X2JvZHlcIiwgZnVuY3Rpb24ob3V0cHV0KXtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCl7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRGVmYXVsdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZGVmYXVsdDpcIik7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2FzZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiY2FzZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCI6XCIpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZXhjZXB0aW9ucyBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfVHJ5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ0cnlcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi5iY2F0Y2gpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi5iY2F0Y2gucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5iZmluYWxseSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmJmaW5hbGx5LnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2F0Y2gsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImNhdGNoXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmFyZ25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFja2V0ZWQoc2VsZi5ib2R5LCBvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9GaW5hbGx5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmaW5hbGx5XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2tldGVkKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyB2YXIvY29uc3QgXS0tLS0tICovXG4gICAgQVNUX0RlZmluaXRpb25zLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmLCBpKXtcbiAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgIGRlZi5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHZhciBpbl9mb3IgPSBwIGluc3RhbmNlb2YgQVNUX0ZvciB8fCBwIGluc3RhbmNlb2YgQVNUX0ZvckluO1xuICAgICAgICB2YXIgYXZvaWRfc2VtaWNvbG9uID0gaW5fZm9yICYmIHAuaW5pdCA9PT0gdGhpcztcbiAgICAgICAgaWYgKCFhdm9pZF9zZW1pY29sb24pXG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1ZhciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInZhclwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29uc3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb25zdFwiKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2l6ZV9mb3Jfbm9pbihub2RlLCBvdXRwdXQsIG5vaW4pIHtcbiAgICAgICAgaWYgKCFub2luKSBub2RlLnByaW50KG91dHB1dCk7XG4gICAgICAgIGVsc2UgdHJ5IHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdGFrZSBzb21lIHByZWNhdXRpb25zIGhlcmU6XG4gICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvNjBcbiAgICAgICAgICAgIG5vZGUud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgbm9kZS5vcGVyYXRvciA9PSBcImluXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG91dHB1dDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG5vZGUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgaWYgKGV4ICE9PSBvdXRwdXQpIHRocm93IGV4O1xuICAgICAgICAgICAgbm9kZS5wcmludChvdXRwdXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIERFRlBSSU5UKEFTVF9WYXJEZWYsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI9XCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoMSk7XG4gICAgICAgICAgICB2YXIgbm9pbiA9IHAgaW5zdGFuY2VvZiBBU1RfRm9yIHx8IHAgaW5zdGFuY2VvZiBBU1RfRm9ySW47XG4gICAgICAgICAgICBwYXJlbnRoZXNpemVfZm9yX25vaW4oc2VsZi52YWx1ZSwgb3V0cHV0LCBub2luKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIG90aGVyIGV4cHJlc3Npb25zIF0tLS0tLSAqL1xuICAgIERFRlBSSU5UKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIG5vX2NvbnN0cnVjdG9yX3BhcmVucyhzZWxmLCBvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGV4cHIsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICBleHByLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX05ldywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwibmV3XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgQVNUX0NhbGwucHJvdG90eXBlLl9jb2RlZ2VuKHNlbGYsIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBBU1RfU2VxLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQpe1xuICAgICAgICB0aGlzLmNhci5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAodGhpcy5jZHIpIHtcbiAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgaWYgKG91dHB1dC5zaG91bGRfYnJlYWsoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TZXEsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgICAgIC8vIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAvLyBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgLy8gICAgIG91dHB1dC53aXRoX2luZGVudChvdXRwdXQubmV4dF9pbmRlbnQoKSwgZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyB9XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RvdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfTnVtYmVyICYmIGV4cHIuZ2V0VmFsdWUoKSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoIS9beGEtZi5dL2kudGVzdChvdXRwdXQubGFzdCgpKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnByaW50KFwiLlwiKTtcbiAgICAgICAgLy8gdGhlIG5hbWUgYWZ0ZXIgZG90IHdvdWxkIGJlIG1hcHBlZCBhYm91dCBoZXJlLlxuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5lbmQpO1xuICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShzZWxmLnByb3BlcnR5KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiW1wiKTtcbiAgICAgICAgc2VsZi5wcm9wZXJ0eS5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJdXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9VbmFyeVByZWZpeCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5vcGVyYXRvcjtcbiAgICAgICAgb3V0cHV0LnByaW50KG9wKTtcbiAgICAgICAgaWYgKC9eW2Etel0vaS50ZXN0KG9wKVxuICAgICAgICAgICAgfHwgKC9bKy1dJC8udGVzdChvcClcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiAvXlsrLV0vLnRlc3Qoc2VsZi5leHByZXNzaW9uLm9wZXJhdG9yKSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9VbmFyeVBvc3RmaXgsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5vcGVyYXRvcik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0JpbmFyeSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5sZWZ0LnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5vcGVyYXRvcik7XG4gICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiPFwiXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IFwiIVwiXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQuZXhwcmVzc2lvbi5vcGVyYXRvciA9PSBcIi0tXCIpIHtcbiAgICAgICAgICAgIC8vIHNwYWNlIGlzIG1hbmRhdG9yeSB0byBhdm9pZCBvdXRwdXR0aW5nIDwhLS1cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9qYXZhc2NyaXB0LnNwZWMud2hhdHdnLm9yZy8jY29tbWVudC1zeW50YXhcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIiBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgc3BhY2UgaXMgb3B0aW9uYWwgZGVwZW5kaW5nIG9uIFwiYmVhdXRpZnlcIlxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yaWdodC5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIj9cIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmNvbnNlcXVlbnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5jb2xvbigpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgbGl0ZXJhbHMgXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX0FycmF5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQud2l0aF9zcXVhcmUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBhID0gc2VsZi5lbGVtZW50cywgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuID4gMCkgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24oZXhwLCBpKXtcbiAgICAgICAgICAgICAgICBpZiAoaSkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICAgICAgZXhwLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbmFsIGVsZW1lbnQgaXMgYSBob2xlLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbG9vayBsaWtlIGEgdHJhaWxpbmcgY29tbWEsIGJ5IGluc2VydGluZyBhbiBhY3R1YWxcbiAgICAgICAgICAgICAgICAvLyB0cmFpbGluZyBjb21tYS5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuIC0gMSAmJiBleHAgaW5zdGFuY2VvZiBBU1RfSG9sZSlcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobGVuID4gMCkgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9PYmplY3QsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMubGVuZ3RoID4gMCkgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3AsIGkpe1xuICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBwcm9wLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbHNlIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9PYmplY3RLZXlWYWwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIHZhciBrZXkgPSBzZWxmLmtleTtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJxdW90ZV9rZXlzXCIpKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKGtleSArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2Yga2V5ID09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgfHwgIW91dHB1dC5vcHRpb24oXCJiZWF1dGlmeVwiKVxuICAgICAgICAgICAgICAgICAgICAmJiAra2V5ICsgXCJcIiA9PSBrZXkpXG4gICAgICAgICAgICAgICAgICAgJiYgcGFyc2VGbG9hdChrZXkpID49IDApIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChtYWtlX251bShrZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChSRVNFUlZFRF9XT1JEUyhrZXkpID8gb3V0cHV0Lm9wdGlvbihcInNjcmV3X2llOFwiKSA6IGlzX2lkZW50aWZpZXJfc3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludF9uYW1lKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgIHNlbGYudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0U2V0dGVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJzZXRcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICBzZWxmLnZhbHVlLl9kb19wcmludChvdXRwdXQsIHRydWUpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9PYmplY3RHZXR0ZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcImdldFwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYua2V5LnByaW50KG91dHB1dCk7XG4gICAgICAgIHNlbGYudmFsdWUuX2RvX3ByaW50KG91dHB1dCwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N5bWJvbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIGRlZiA9IHNlbGYuZGVmaW5pdGlvbigpO1xuICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShkZWYgPyBkZWYubWFuZ2xlZF9uYW1lIHx8IGRlZi5uYW1lIDogc2VsZi5uYW1lKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVW5kZWZpbmVkLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ2b2lkIDBcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0hvbGUsIG5vb3ApO1xuICAgIERFRlBSSU5UKEFTVF9JbmZpbml0eSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiMS8wXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9OYU4sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChcIjAvMFwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVGhpcywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgb3V0cHV0LnByaW50KFwidGhpc1wiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29uc3RhbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludChzZWxmLmdldFZhbHVlKCkpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi5nZXRWYWx1ZSgpKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTnVtYmVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpe1xuICAgICAgICBvdXRwdXQucHJpbnQobWFrZV9udW0oc2VsZi5nZXRWYWx1ZSgpKSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWdleHBfc2FmZV9saXRlcmFsKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDB4NWMgICAsIC8vIFxcXG4gICAgICAgICAgICAweDJmICAgLCAvLyAvXG4gICAgICAgICAgICAweDJlICAgLCAvLyAuXG4gICAgICAgICAgICAweDJiICAgLCAvLyArXG4gICAgICAgICAgICAweDJhICAgLCAvLyAqXG4gICAgICAgICAgICAweDNmICAgLCAvLyA/XG4gICAgICAgICAgICAweDI4ICAgLCAvLyAoXG4gICAgICAgICAgICAweDI5ICAgLCAvLyApXG4gICAgICAgICAgICAweDViICAgLCAvLyBbXG4gICAgICAgICAgICAweDVkICAgLCAvLyBdXG4gICAgICAgICAgICAweDdiICAgLCAvLyB7XG4gICAgICAgICAgICAweDdkICAgLCAvLyB9XG4gICAgICAgICAgICAweDI0ICAgLCAvLyAkXG4gICAgICAgICAgICAweDVlICAgLCAvLyBeXG4gICAgICAgICAgICAweDNhICAgLCAvLyA6XG4gICAgICAgICAgICAweDdjICAgLCAvLyB8XG4gICAgICAgICAgICAweDIxICAgLCAvLyAhXG4gICAgICAgICAgICAweDBhICAgLCAvLyBcXG5cbiAgICAgICAgICAgIDB4MGQgICAsIC8vIFxcclxuICAgICAgICAgICAgMHgwMCAgICwgLy8gXFwwXG4gICAgICAgICAgICAweGZlZmYgLCAvLyBVbmljb2RlIEJPTVxuICAgICAgICAgICAgMHgyMDI4ICwgLy8gdW5pY29kZSBcImxpbmUgc2VwYXJhdG9yXCJcbiAgICAgICAgICAgIDB4MjAyOSAsIC8vIHVuaWNvZGUgXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCJcbiAgICAgICAgXS5pbmRleE9mKGNvZGUpIDwgMDtcbiAgICB9O1xuXG4gICAgREVGUFJJTlQoQVNUX1JlZ0V4cCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KXtcbiAgICAgICAgdmFyIHN0ciA9IHNlbGYuZ2V0VmFsdWUoKS50b1N0cmluZygpO1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImFzY2lpX29ubHlcIikpIHtcbiAgICAgICAgICAgIHN0ciA9IG91dHB1dC50b19hc2NpaShzdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKG91dHB1dC5vcHRpb24oXCJ1bmVzY2FwZV9yZWdleHBzXCIpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoXCJcXFxcXFxcXFwiKS5tYXAoZnVuY3Rpb24oc3RyKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFx1WzAtOWEtZkEtRl17NH18XFxcXHhbMC05YS1mQS1GXXsyfS9nLCBmdW5jdGlvbihzKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChzLnN1YnN0cigyKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhwX3NhZmVfbGl0ZXJhbChjb2RlKSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuam9pbihcIlxcXFxcXFxcXCIpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wcmludChzdHIpO1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIC9eaW4vLnRlc3QocC5vcGVyYXRvcikgJiYgcC5sZWZ0ID09PSBzZWxmKVxuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiIFwiKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZvcmNlX3N0YXRlbWVudChzdGF0LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJicmFja2V0aXplXCIpKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXQgfHwgc3RhdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudClcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7fVwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgc3RhdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgZWxzZSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICBzdGF0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdGF0IHx8IHN0YXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgb3V0cHV0LmZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHN0YXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjayAodGhhdCBtZWFucyB0aGVcbiAgICAvLyBpbm5lcm1vc3Qgbm9kZSBpbiB0aGUgY3VycmVudCBvdXRwdXQpIGlzIGxleGljYWxseSB0aGUgZmlyc3QgaW5cbiAgICAvLyBhIHN0YXRlbWVudC5cbiAgICBmdW5jdGlvbiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KSB7XG4gICAgICAgIHZhciBhID0gb3V0cHV0LnN0YWNrKCksIGkgPSBhLmxlbmd0aCwgbm9kZSA9IGFbLS1pXSwgcCA9IGFbLS1pXTtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQgJiYgcC5ib2R5ID09PSBub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKChwIGluc3RhbmNlb2YgQVNUX1NlcSAgICAgICAgICAgJiYgcC5jYXIgPT09IG5vZGUgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICAgICAgICAgICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSAmJiAhKHAgaW5zdGFuY2VvZiBBU1RfTmV3KSApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfRG90ICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1N1YiAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkgfHxcbiAgICAgICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAgICYmIHAuY29uZGl0aW9uID09PSBub2RlICApIHx8XG4gICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICAgICAgICAmJiBwLmxlZnQgPT09IG5vZGUgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5UG9zdGZpeCAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHA7XG4gICAgICAgICAgICAgICAgcCA9IGFbLS1pXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNlbGYgc2hvdWxkIGJlIEFTVF9OZXcuICBkZWNpZGUgaWYgd2Ugd2FudCB0byBzaG93IHBhcmVucyBvciBub3QuXG4gICAgZnVuY3Rpb24gbm9fY29uc3RydWN0b3JfcGFyZW5zKHNlbGYsIG91dHB1dCkge1xuICAgICAgICByZXR1cm4gc2VsZi5hcmdzLmxlbmd0aCA9PSAwICYmICFvdXRwdXQub3B0aW9uKFwiYmVhdXRpZnlcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJlc3Rfb2YoYSkge1xuICAgICAgICB2YXIgYmVzdCA9IGFbMF0sIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChhW2ldLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBhW2ldO1xuICAgICAgICAgICAgICAgIGxlbiA9IGJlc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlX251bShudW0pIHtcbiAgICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxMCksIGEgPSBbIHN0ci5yZXBsYWNlKC9eMFxcLi8sIFwiLlwiKS5yZXBsYWNlKCdlKycsICdlJykgXSwgbTtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IobnVtKSA9PT0gbnVtKSB7XG4gICAgICAgICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goXCIweFwiICsgbnVtLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpLCAvLyBwcm9iYWJseSBwb2ludGxlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgXCIwXCIgKyBudW0udG9TdHJpbmcoOCkpOyAvLyBzYW1lLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goXCItMHhcIiArICgtbnVtKS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKSwgLy8gcHJvYmFibHkgcG9pbnRsZXNzXG4gICAgICAgICAgICAgICAgICAgICAgIFwiLTBcIiArICgtbnVtKS50b1N0cmluZyg4KSk7IC8vIHNhbWUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG0gPSAvXiguKj8pKDArKSQvLmV4ZWMobnVtKSkpIHtcbiAgICAgICAgICAgICAgICBhLnB1c2gobVsxXSArIFwiZVwiICsgbVsyXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtID0gL14wP1xcLigwKykoLiopJC8uZXhlYyhudW0pKSkge1xuICAgICAgICAgICAgYS5wdXNoKG1bMl0gKyBcImUtXCIgKyAobVsxXS5sZW5ndGggKyBtWzJdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgc3RyLnN1YnN0cihzdHIuaW5kZXhPZihcIi5cIikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdF9vZihhKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9ibG9jayhzdG10LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qIC0tLS0tWyBzb3VyY2UgbWFwIGdlbmVyYXRvcnMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBERUZNQVAobm9kZXR5cGUsIGdlbmVyYXRvcikge1xuICAgICAgICBub2RldHlwZS5ERUZNRVRIT0QoXCJhZGRfc291cmNlX21hcFwiLCBmdW5jdGlvbihzdHJlYW0pe1xuICAgICAgICAgICAgZ2VuZXJhdG9yKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBXZSBjb3VsZCBlYXNpbHkgYWRkIGluZm8gZm9yIEFMTCBub2RlcywgYnV0IGl0IHNlZW1zIHRvIG1lIHRoYXRcbiAgICAvLyB3b3VsZCBiZSBxdWl0ZSB3YXN0ZWZ1bCwgaGVuY2UgdGhpcyBub29wIGluIHRoZSBiYXNlIGNsYXNzLlxuICAgIERFRk1BUChBU1RfTm9kZSwgbm9vcCk7XG5cbiAgICBmdW5jdGlvbiBiYXNpY19zb3VyY2VtYXBfZ2VuKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5zdGFydCk7XG4gICAgfTtcblxuICAgIC8vIFhYWDogSSdtIG5vdCBleGFjdGx5IHN1cmUgaWYgd2UgbmVlZCBpdCBmb3IgYWxsIG9mIHRoZXNlIG5vZGVzLFxuICAgIC8vIG9yIGlmIHdlIHNob3VsZCBhZGQgZXZlbiBtb3JlLlxuXG4gICAgREVGTUFQKEFTVF9EaXJlY3RpdmUsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfRGVidWdnZXIsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3ltYm9sLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0p1bXAsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3RhdGVtZW50V2l0aEJvZHksIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfTGFiZWxlZFN0YXRlbWVudCwgbm9vcCk7IC8vIHNpbmNlIHRoZSBsYWJlbCBzeW1ib2wgd2lsbCBtYXJrIGl0XG4gICAgREVGTUFQKEFTVF9MYW1iZGEsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfU3dpdGNoLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX1N3aXRjaEJyYW5jaCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9CbG9ja1N0YXRlbWVudCwgYmFzaWNfc291cmNlbWFwX2dlbik7XG4gICAgREVGTUFQKEFTVF9Ub3BsZXZlbCwgbm9vcCk7XG4gICAgREVGTUFQKEFTVF9OZXcsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfVHJ5LCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0NhdGNoLCBiYXNpY19zb3VyY2VtYXBfZ2VuKTtcbiAgICBERUZNQVAoQVNUX0ZpbmFsbHksIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfRGVmaW5pdGlvbnMsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfQ29uc3RhbnQsIGJhc2ljX3NvdXJjZW1hcF9nZW4pO1xuICAgIERFRk1BUChBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCl7XG4gICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLnN0YXJ0LCBzZWxmLmtleSk7XG4gICAgfSk7XG5cbn0pKCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIENvbXByZXNzb3Iob3B0aW9ucywgZmFsc2VfYnlfZGVmYXVsdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wcmVzc29yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc29yKG9wdGlvbnMsIGZhbHNlX2J5X2RlZmF1bHQpO1xuICAgIFRyZWVUcmFuc2Zvcm1lci5jYWxsKHRoaXMsIHRoaXMuYmVmb3JlLCB0aGlzLmFmdGVyKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHNlcXVlbmNlcyAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllcyAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBkZWFkX2NvZGUgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGRyb3BfZGVidWdnZXIgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgdW5zYWZlICAgICAgICA6IGZhbHNlLFxuICAgICAgICB1bnNhZmVfY29tcHMgIDogZmFsc2UsXG4gICAgICAgIGNvbmRpdGlvbmFscyAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgY29tcGFyaXNvbnMgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBldmFsdWF0ZSAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGJvb2xlYW5zICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgbG9vcHMgICAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICB1bnVzZWQgICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIGhvaXN0X2Z1bnMgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAga2VlcF9mYXJncyAgICA6IGZhbHNlLFxuICAgICAgICBob2lzdF92YXJzICAgIDogZmFsc2UsXG4gICAgICAgIGlmX3JldHVybiAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgam9pbl92YXJzICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBjYXNjYWRlICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgIHNpZGVfZWZmZWN0cyAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgcHVyZV9nZXR0ZXJzICA6IGZhbHNlLFxuICAgICAgICBwdXJlX2Z1bmNzICAgIDogbnVsbCxcbiAgICAgICAgbmVnYXRlX2lpZmUgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICBzY3Jld19pZTggICAgIDogZmFsc2UsXG4gICAgICAgIGRyb3BfY29uc29sZSAgOiBmYWxzZSxcbiAgICAgICAgYW5ndWxhciAgICAgICA6IGZhbHNlLFxuXG4gICAgICAgIHdhcm5pbmdzICAgICAgOiB0cnVlLFxuICAgICAgICBnbG9iYWxfZGVmcyAgIDoge31cbiAgICB9LCB0cnVlKTtcbn07XG5cbkNvbXByZXNzb3IucHJvdG90eXBlID0gbmV3IFRyZWVUcmFuc2Zvcm1lcjtcbm1lcmdlKENvbXByZXNzb3IucHJvdG90eXBlLCB7XG4gICAgb3B0aW9uOiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldIH0sXG4gICAgd2FybjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMud2FybmluZ3MpXG4gICAgICAgICAgICBBU1RfTm9kZS53YXJuLmFwcGx5KEFTVF9Ob2RlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgYmVmb3JlOiBmdW5jdGlvbihub2RlLCBkZXNjZW5kLCBpbl9saXN0KSB7XG4gICAgICAgIGlmIChub2RlLl9zcXVlZXplZCkgcmV0dXJuIG5vZGU7XG4gICAgICAgIHZhciB3YXNfc2NvcGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmhvaXN0X2RlY2xhcmF0aW9ucyh0aGlzKTtcbiAgICAgICAgICAgIHdhc19zY29wZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgbm9kZSA9IG5vZGUub3B0aW1pemUodGhpcyk7XG4gICAgICAgIGlmICh3YXNfc2NvcGUgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgbm9kZS5kcm9wX3VudXNlZCh0aGlzKTtcbiAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5fc3F1ZWV6ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59KTtcblxuKGZ1bmN0aW9uKCl7XG5cbiAgICBmdW5jdGlvbiBPUFQobm9kZSwgb3B0aW1pemVyKSB7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwib3B0aW1pemVcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VsZi5fb3B0aW1pemVkKSByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIHZhciBvcHQgPSBvcHRpbWl6ZXIoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBvcHQuX29wdGltaXplZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAob3B0ID09PSBzZWxmKSByZXR1cm4gb3B0O1xuICAgICAgICAgICAgcmV0dXJuIG9wdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBPUFQoQVNUX05vZGUsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcImVxdWl2YWxlbnRfdG9cIiwgZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIC8vIFhYWDogdGhpcyBpcyBhIHJhdGhlciBleHBlbnNpdmUgd2F5IHRvIHRlc3QgdHdvIG5vZGUncyBlcXVpdmFsZW5jZTpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbnRfdG9fc3RyaW5nKCkgPT0gbm9kZS5wcmludF90b19zdHJpbmcoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1ha2Vfbm9kZShjdG9yLCBvcmlnLCBwcm9wcykge1xuICAgICAgICBpZiAoIXByb3BzKSBwcm9wcyA9IHt9O1xuICAgICAgICBpZiAob3JpZykge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5zdGFydCkgcHJvcHMuc3RhcnQgPSBvcmlnLnN0YXJ0O1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5lbmQpIHByb3BzLmVuZCA9IG9yaWcuZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY3Rvcihwcm9wcyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbXByZXNzb3IsIHZhbCwgb3JpZykge1xuICAgICAgICAvLyBYWFg6IFdJUC5cbiAgICAgICAgLy8gaWYgKHZhbCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSByZXR1cm4gdmFsLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKG51bGwsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAvLyAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIHNjb3BlID0gY29tcHJlc3Nvci5maW5kX3BhcmVudChBU1RfU2NvcGUpO1xuICAgICAgICAvLyAgICAgICAgIHZhciBkZWYgPSBzY29wZS5maW5kX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICAvLyAgICAgICAgIG5vZGUudGhlZGVmID0gZGVmO1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9KSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuXG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcmV0dXJuIHZhbC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1N0cmluZywgb3JpZywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoaXNOYU4odmFsKSA/IEFTVF9OYU4gOiBBU1RfTnVtYmVyLCBvcmlnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUodmFsID8gQVNUX1RydWUgOiBBU1RfRmFsc2UsIG9yaWcpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgb3JpZykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdWxsLCBvcmlnKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9SZWdFeHAsIG9yaWcpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ190ZW1wbGF0ZShcIkNhbid0IGhhbmRsZSBjb25zdGFudCBvZiB0eXBlOiB7dHlwZX1cIiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVvZiB2YWxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc19zdGF0ZW1lbnRfYXJyYXkodGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nID09PSBudWxsKSByZXR1cm4gW107XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkgcmV0dXJuIHRoaW5nLmJvZHk7XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KSByZXR1cm4gWyB0aGluZyBdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRoaW5nIHRvIHN0YXRlbWVudCBhcnJheVwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNfZW1wdHkodGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSByZXR1cm4gdGhpbmcuYm9keS5sZW5ndGggPT0gMDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb29wX2JvZHkoeCkge1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHJldHVybiB4O1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9Gb3IgfHwgeCBpbnN0YW5jZW9mIEFTVF9Gb3JJbiB8fCB4IGluc3RhbmNlb2YgQVNUX0RXTG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuICh4LmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQgPyB4LmJvZHkgOiB4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdGlnaHRlbl9ib2R5KHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIENIQU5HRUQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIENIQU5HRUQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImFuZ3VsYXJcIikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gcHJvY2Vzc19mb3JfYW5ndWxhcihzdGF0ZW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlbWVudHMgPSBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXRlbWVudHMpO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IGVsaW1pbmF0ZV9kZWFkX2NvZGUoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJpZl9yZXR1cm5cIikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gaGFuZGxlX2lmX3JldHVybihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBzZXF1ZW5jZXNpemUoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJqb2luX3ZhcnNcIikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzID0gam9pbl9jb25zZWN1dGl2ZV92YXJzKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChDSEFOR0VEKTtcblxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJuZWdhdGVfaWlmZVwiKSkge1xuICAgICAgICAgICAgbmVnYXRlX2lpZmVzKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc19mb3JfYW5ndWxhcihzdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBtYWtlX2luamVjdG9yKGZ1bmMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmMsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9Bc3NpZ24sIGZ1bmMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfRG90LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIG5hbWUsIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcIiRpbmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9BcnJheSwgZnVuYywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBmdW5jLmFyZ25hbWVzLm1hcChmdW5jdGlvbihzeW0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHN5bSwgeyB2YWx1ZTogc3ltLm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYSwgc3RhdCl7XG4gICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gdG9rZW4uY29tbWVudHNfYmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50cyAmJiBjb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gY29tbWVudHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvQG5nSW5qZWN0Ly50ZXN0KGxhc3QudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDE6IGRlZnVuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EZWZ1bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX2luamVjdG9yKHN0YXQsIHN0YXQubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlICYmIGRlZi52YWx1ZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX2luamVjdG9yKGRlZi52YWx1ZSwgZGVmLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiVW5rbm93biBzdGF0ZW1lbnQgbWFya2VkIHdpdGggQG5nSW5qZWN0IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBzZWVuX2RpcnMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdC5ib2R5KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5fZGlycy5pbmRleE9mKHN0YXQudmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbl9kaXJzLnB1c2goc3RhdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlX2lmX3JldHVybihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IGNvbXByZXNzb3Iuc2VsZigpO1xuICAgICAgICAgICAgdmFyIGluX2xhbWJkYSA9IHNlbGYgaW5zdGFuY2VvZiBBU1RfTGFtYmRhO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgbG9vcDogZm9yICh2YXIgaSA9IHN0YXRlbWVudHMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIChpbl9sYW1iZGEgJiYgc3RhdCBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgIXN0YXQudmFsdWUgJiYgcmV0Lmxlbmd0aCA9PSAwKTpcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGUsIHJldC5sZW5ndGggaXMgcHJvYmFibHkgYWx3YXlzIHplcm9cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkcm9wIHVucmVhY2hhYmxlIGNvZGUgYmVmb3JlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RlcC4gIG5ldmVydGhlbGVzcywgaXQncyBnb29kIHRvIGNoZWNrLlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgY2FzZSBzdGF0IGluc3RhbmNlb2YgQVNUX0lmOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5ib2R5IGluc3RhbmNlb2YgQVNUX1JldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXR0eSBzaWxseSBjYXNlLCBidXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybjsgcmV0dXJuOyA9PT4gZm9vKCk7IHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKGluX2xhbWJkYSAmJiByZXQubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChyZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmICFyZXRbMF0udmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFzdGF0LmJvZHkudmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZCA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzdGF0LmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzdGF0LmNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KGNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGZvbygpKSByZXR1cm4geDsgcmV0dXJuIHk7ID09PiByZXR1cm4gZm9vKCkgPyB4IDogeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmIHN0YXQuYm9keS52YWx1ZSAmJiByZXRbMF0udmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSByZXRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0WzBdID0gc3RhdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybiB4OyBbIHJldHVybiA7IF0gPT0+IHJldHVybiBmb28oKSA/IHggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJldC5sZW5ndGggPT0gMCB8fCByZXRbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuKSAmJiBzdGF0LmJvZHkudmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmUgJiYgaW5fbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gcmV0WzBdIHx8IG1ha2Vfbm9kZShBU1RfUmV0dXJuLCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc3RhdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRbMF0gPSBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChmb28oKSkgcmV0dXJuOyBbIGVsc2UgeC4uLiBdOyB5Li4uID09PiBpZiAoIWZvbygpKSB7IHguLi47IHkuLi4gfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0LmJvZHkudmFsdWUgJiYgaW5fbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmNvbmRpdGlvbiA9IHN0YXQuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5jb25jYXQocmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IFsgc3RhdC50cmFuc2Zvcm0oY29tcHJlc3NvcikgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoID09IDEgJiYgaW5fbGFtYmRhICYmIHJldFswXSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoIXN0YXQuYWx0ZXJuYXRpdmUgfHwgc3RhdC5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2gobWFrZV9ub2RlKEFTVF9SZXR1cm4sIHJldFswXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHJldFswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3NvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5jb25jYXQocmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQudW5zaGlmdChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFiID0gYWJvcnRzKHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsY3QgPSBhYiBpbnN0YW5jZW9mIEFTVF9Mb29wQ29udHJvbCA/IGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KGFiLmxhYmVsKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYiAmJiAoKGFiIGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiAhYWIudmFsdWUgJiYgaW5fbGFtYmRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChhYiBpbnN0YW5jZW9mIEFTVF9Db250aW51ZSAmJiBzZWxmID09PSBsb29wX2JvZHkobGN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYWIgaW5zdGFuY2VvZiBBU1RfQnJlYWsgJiYgbGN0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50ICYmIHNlbGYgPT09IGxjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWIubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoYWIubGFiZWwudGhlZGVmLnJlZmVyZW5jZXMsIGFiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5ib2R5KS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5jb25kaXRpb24gPSBzdGF0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYXNfc3RhdGVtZW50X2FycmF5KHN0YXQuYWx0ZXJuYXRpdmUpLmNvbmNhdChyZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuYWx0ZXJuYXRpdmUgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBbIHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFiID0gYWJvcnRzKHN0YXQuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGN0ID0gYWIgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wgPyBjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChhYi5sYWJlbCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWIgJiYgKChhYiBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgIWFiLnZhbHVlICYmIGluX2xhbWJkYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoYWIgaW5zdGFuY2VvZiBBU1RfQ29udGludWUgJiYgc2VsZiA9PT0gbG9vcF9ib2R5KGxjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGFiIGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIGxjdCBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCAmJiBzZWxmID09PSBsY3QpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGFiLmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBhYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQgPSBzdGF0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5ib2R5KS5jb25jYXQocmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdC5hbHRlcm5hdGl2ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmFsdGVybmF0aXZlKS5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gWyBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGVsaW1pbmF0ZV9kZWFkX2NvZGUoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgdmFyIGhhc19xdWl0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgb3JpZyA9IHN0YXRlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBjb21wcmVzc29yLnNlbGYoKTtcbiAgICAgICAgICAgIHN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoaGFzX3F1aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHN0YXQsIGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGN0ID0gY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc3RhdC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHN0YXQgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGN0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGxvb3BfYm9keShsY3QpID09PSBzZWxmKSB8fCAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Db250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGxvb3BfYm9keShsY3QpID09PSBzZWxmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShzdGF0LmxhYmVsLnRoZWRlZi5yZWZlcmVuY2VzLCBzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRzKHN0YXQpKSBoYXNfcXVpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgQ0hBTkdFRCA9IHN0YXRlbWVudHMubGVuZ3RoICE9IG9yaWc7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZXF1ZW5jZXNpemUoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgICAgICB2YXIgc2VxID0gW10sIHJldCA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHVzaF9zZXEoKSB7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHNlcSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcSkgcmV0LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlcSwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBzZXFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgc2VxID0gW107XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpe1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkgc2VxLnB1c2goc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHB1c2hfc2VxKCksIHJldC5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwdXNoX3NlcSgpO1xuICAgICAgICAgICAgcmV0ID0gc2VxdWVuY2VzaXplXzIocmV0LCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIENIQU5HRUQgPSByZXQubGVuZ3RoICE9IHN0YXRlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzZXF1ZW5jZXNpemVfMihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjb25zX3NlcShyaWdodCkge1xuICAgICAgICAgICAgICAgIHJldC5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHByZXYuYm9keTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5hZGQocmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBBU1RfU2VxLmNvbnMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmJvZHkud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIG5vZGUub3BlcmF0b3IgPT0gXCJpblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3BlcmE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmluaXQgJiYgIShzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IGNvbnNfc2VxKHN0YXQuaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzdGF0LmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gcHJldi5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCAhPT0gb3BlcmEpIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gY29uc19zZXEoc3RhdC5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfV2l0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5leHByZXNzaW9uID0gY29uc19zZXEoc3RhdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQgJiYgc3RhdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKHN0YXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRXhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzdGF0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuZXhwcmVzc2lvbiA9IGNvbnNfc2VxKHN0YXQuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgcHJldiA9IHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50ID8gc3RhdCA6IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gam9pbl9jb25zZWN1dGl2ZV92YXJzKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBzdGF0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiBwcmV2ICYmIHByZXYuVFlQRSA9PSBzdGF0LlRZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5kZWZpbml0aW9ucyA9IHByZXYuZGVmaW5pdGlvbnMuY29uY2F0KHN0YXQuZGVmaW5pdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAmJiBwcmV2IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCFzdGF0LmluaXQgfHwgc3RhdC5pbml0LlRZUEUgPT0gcHJldi5UWVBFKSkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0LmRlZmluaXRpb25zID0gcHJldi5kZWZpbml0aW9ucy5jb25jYXQoc3RhdC5pbml0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBzdGF0O1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIG5lZ2F0ZV9paWZlcyhzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oc3RhdCl7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuYm9keSA9IChmdW5jdGlvbiB0cmFuc2Zvcm0odGhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGluZy50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRyYW5zZm9ybShub2RlLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNhciA9IHRyYW5zZm9ybShub2RlLmNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0cmFuc2Zvcm0obm9kZS5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwciAhPT0gbm9kZS5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGhhcyBiZWVuIG5lZ2F0ZWQsIHJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29uZGl0aW9uID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBub2RlLmNvbnNlcXVlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnNlcXVlbnQgPSBub2RlLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGl2ZSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoc3RhdC5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc3RhdCwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHVucmVhY2hhYmxlIGNvZGUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHN0YXQuc3RhcnQpO1xuICAgICAgICBzdGF0LndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRlY2xhcmF0aW9ucyBpbiB1bnJlYWNoYWJsZSBjb2RlISBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVfaW5pdGlhbGl6ZXJzKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1bikge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH07XG5cbiAgICAvKiAtLS0tLVsgYm9vbGVhbi9uZWdhdGlvbiBoZWxwZXJzIF0tLS0tLSAqL1xuXG4gICAgLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBleHByZXNzaW9uIGhhcyBhIGJvb2xlYW4gcmVzdWx0IHR5cGVcbiAgICAoZnVuY3Rpb24gKGRlZil7XG4gICAgICAgIHZhciB1bmFyeV9ib29sID0gWyBcIiFcIiwgXCJkZWxldGVcIiBdO1xuICAgICAgICB2YXIgYmluYXJ5X2Jvb2wgPSBbIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwiPT1cIiwgXCIhPVwiLCBcIj09PVwiLCBcIiE9PVwiLCBcIjxcIiwgXCI8PVwiLCBcIj49XCIsIFwiPlwiIF07XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcih0aGlzLm9wZXJhdG9yLCB1bmFyeV9ib29sKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQmluYXJ5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcih0aGlzLm9wZXJhdG9yLCBiaW5hcnlfYm9vbCkgfHxcbiAgICAgICAgICAgICAgICAoICh0aGlzLm9wZXJhdG9yID09IFwiJiZcIiB8fCB0aGlzLm9wZXJhdG9yID09IFwifHxcIikgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5pc19ib29sZWFuKCkgJiYgdGhpcy5yaWdodC5pc19ib29sZWFuKCkgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX2Jvb2xlYW4oKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX2Jvb2xlYW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQXNzaWduLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgJiYgdGhpcy5yaWdodC5pc19ib29sZWFuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1NlcSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNkci5pc19ib29sZWFuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1RydWUsIGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlIH0pO1xuICAgICAgICBkZWYoQVNUX0ZhbHNlLCBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJpc19ib29sZWFuXCIsIGZ1bmMpO1xuICAgIH0pO1xuXG4gICAgLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgaWYgYW4gZXhwcmVzc2lvbiBoYXMgYSBzdHJpbmcgcmVzdWx0IHR5cGVcbiAgICAoZnVuY3Rpb24gKGRlZil7XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1N0cmluZywgZnVuY3Rpb24oKXsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgIGRlZihBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcInR5cGVvZlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IgPT0gXCIrXCIgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKSB8fCB0aGlzLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIis9XCIpICYmIHRoaXMucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TZXEsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2RyLmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc2VxdWVudC5pc19zdHJpbmcoY29tcHJlc3NvcikgJiYgdGhpcy5hbHRlcm5hdGl2ZS5pc19zdHJpbmcoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NhbGwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICYmIHRoaXMuZXhwcmVzc2lvbi5uYW1lID09IFwiU3RyaW5nXCJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmV4cHJlc3Npb24udW5kZWNsYXJlZCgpO1xuICAgICAgICB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJpc19zdHJpbmdcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBiZXN0X29mKGFzdDEsIGFzdDIpIHtcbiAgICAgICAgcmV0dXJuIGFzdDEucHJpbnRfdG9fc3RyaW5nKCkubGVuZ3RoID5cbiAgICAgICAgICAgIGFzdDIucHJpbnRfdG9fc3RyaW5nKCkubGVuZ3RoXG4gICAgICAgICAgICA/IGFzdDIgOiBhc3QxO1xuICAgIH07XG5cbiAgICAvLyBtZXRob2RzIHRvIGV2YWx1YXRlIGEgY29uc3RhbnQgZXhwcmVzc2lvblxuICAgIChmdW5jdGlvbiAoZGVmKXtcbiAgICAgICAgLy8gVGhlIGV2YWx1YXRlIG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IHdpdGggb25lIG9yIHR3b1xuICAgICAgICAvLyBlbGVtZW50cy4gIElmIHRoZSBub2RlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSByZWR1Y2VkIHRvIGFcbiAgICAgICAgLy8gY29uc3RhbnQsIHRoZW4gdGhlIHNlY29uZCBlbGVtZW50IHRlbGxzIHVzIHRoZSB2YWx1ZTtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBtaXNzaW5nLiAgVGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgLy8gb2YgdGhlIGFycmF5IGlzIGFsd2F5cyBhbiBBU1RfTm9kZSBkZXNjZW5kYW50OyBpZlxuICAgICAgICAvLyBldmFsdWF0aW9uIHdhcyBzdWNjZXNzZnVsIGl0J3MgYSBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgICAgICAgLy8gY29uc3RhbnQ7IG90aGVyd2lzZSBpdCdzIHRoZSBvcmlnaW5hbCBvciBhIHJlcGxhY2VtZW50IG5vZGUuXG4gICAgICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcImV2YWx1YXRlXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImV2YWx1YXRlXCIpKSByZXR1cm4gWyB0aGlzIF07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLl9ldmFsKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbIGJlc3Rfb2YobWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29tcHJlc3NvciwgdmFsLCB0aGlzKSwgdGhpcyksIHZhbCBdO1xuICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgIGlmIChleCAhPT0gZGVmKSB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyB0aGlzIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1N0YXRlbWVudCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdfdGVtcGxhdGUoXCJDYW5ub3QgZXZhbHVhdGUgYSBzdGF0ZW1lbnQgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHRoaXMuc3RhcnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBYWFg6IEFTVF9GdW5jdGlvbiBpbmhlcml0cyBmcm9tIEFTVF9TY29wZSwgd2hpY2ggaXRzZWxmXG4gICAgICAgICAgICAvLyBpbmhlcml0cyBmcm9tIEFTVF9TdGF0ZW1lbnQ7IGhvd2V2ZXIsIGFuIEFTVF9GdW5jdGlvblxuICAgICAgICAgICAgLy8gaXNuJ3QgcmVhbGx5IGEgc3RhdGVtZW50LiAgVGhpcyBjb3VsZCBieXRlIGluIG90aGVyXG4gICAgICAgICAgICAvLyBwbGFjZXMgdG9vLiA6LSggV2lzaCBKUyBoYWQgbXVsdGlwbGUgaW5oZXJpdGFuY2UuXG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBldihub2RlLCBjb21wcmVzc29yKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXByZXNzb3IpIHRocm93IG5ldyBFcnJvcihcIkNvbXByZXNzb3IgbXVzdCBiZSBwYXNzZWRcIik7XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlLl9ldmFsKGNvbXByZXNzb3IpO1xuICAgICAgICB9O1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aHJvdyBkZWY7ICAgICAgICAgIC8vIG5vdCBjb25zdGFudFxuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25zdGFudCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIhXCI6IHJldHVybiAhZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiB3b3VsZCBiZSBldmFsdWF0ZWQgdG8gYW4gYXJyYXkgYW5kIHNvIHR5cGVvZiB3b3VsZFxuICAgICAgICAgICAgICAgIC8vIGluY29ycmVjdGx5IHJldHVybiAnb2JqZWN0Jy4gSGVuY2UgbWFraW5nIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX0Z1bmN0aW9uKSByZXR1cm4gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcblxuICAgICAgICAgICAgICAgIGUgPSBldihlLCBjb21wcmVzc29yKTtcblxuICAgICAgICAgICAgICAgIC8vIHR5cGVvZiA8UmVnRXhwPiByZXR1cm5zIFwib2JqZWN0XCIgb3IgXCJmdW5jdGlvblwiIG9uIGRpZmZlcmVudCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvLyBzbyBjYW5ub3QgZXZhbHVhdGUgcmVsaWFibHlcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlZ0V4cCkgdGhyb3cgZGVmO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICBjYXNlIFwidm9pZFwiOiByZXR1cm4gdm9pZCBldihlLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIH5ldihlLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICBlID0gZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IDApIHRocm93IGRlZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gLWU7XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCI6IHJldHVybiArZXYoZSwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0JpbmFyeSwgZnVuY3Rpb24oYyl7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdCwgcmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCImJlwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgJiYgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ8fFwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgfHwgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ8XCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgfCAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCImXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgJiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJeXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgXiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgKyAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIqXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgKiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIvXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgLyAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIlXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgJSAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCItXCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgLSAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PFwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPDwgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+PlwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPj4gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+Pj5cIiAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPj4+ICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI9PVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPT0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI9PT1cIiAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPT09ICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgIT0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPT1cIiAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgIT09ICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI8XCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPCAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPD0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+XCIgICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPiAgICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCI+PVwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgPj0gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJpblwiICAgICAgICAgOiByZXR1cm4gZXYobGVmdCwgYykgaW4gICAgICAgICBldihyaWdodCwgYyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJpbnN0YW5jZW9mXCIgOiByZXR1cm4gZXYobGVmdCwgYykgaW5zdGFuY2VvZiBldihyaWdodCwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBkZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiBldih0aGlzLmNvbmRpdGlvbiwgY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICA/IGV2KHRoaXMuY29uc2VxdWVudCwgY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICA6IGV2KHRoaXMuYWx0ZXJuYXRpdmUsIGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChkICYmIGQuY29uc3RhbnQgJiYgZC5pbml0KSByZXR1cm4gZXYoZC5pbml0LCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHRocm93IGRlZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRG90LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSAmJiB0aGlzLnByb3BlcnR5ID09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gZXYodGhpcy5leHByZXNzaW9uLCBjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ciA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGRlZjtcbiAgICAgICAgfSk7XG4gICAgfSkoZnVuY3Rpb24obm9kZSwgZnVuYyl7XG4gICAgICAgIG5vZGUuREVGTUVUSE9EKFwiX2V2YWxcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvLyBtZXRob2QgdG8gbmVnYXRlIGFuIGV4cHJlc3Npb25cbiAgICAoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgZnVuY3Rpb24gYmFzaWNfbmVnYXRpb24oZXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgZXhwLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZihBU1RfTm9kZSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3RhdGVtZW50LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG5lZ2F0ZSBhIHN0YXRlbWVudFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT0gXCIhXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU2VxLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgc2VsZi5jZHIgPSBzZWxmLmNkci5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICBzZWxmLmNvbnNlcXVlbnQgPSBzZWxmLmNvbnNlcXVlbnQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmUubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoYmFzaWNfbmVnYXRpb24odGhpcyksIHNlbGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCksIG9wID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9jb21wc1wiKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI8PVwiIDogc2VsZi5vcGVyYXRvciA9IFwiPlwiICA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIjxcIiAgOiBzZWxmLm9wZXJhdG9yID0gXCI+PVwiIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiPj1cIiA6IHNlbGYub3BlcmF0b3IgPSBcIjxcIiAgOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCI+XCIgIDogc2VsZi5vcGVyYXRvciA9IFwiPD1cIiA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgY2FzZSBcIj09XCIgOiBzZWxmLm9wZXJhdG9yID0gXCIhPVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI9PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIj09PVwiOiBzZWxmLm9wZXJhdG9yID0gXCIhPT1cIjsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIGNhc2UgXCIhPT1cIjogc2VsZi5vcGVyYXRvciA9IFwiPT09XCI7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICBjYXNlIFwiJiZcIjpcbiAgICAgICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gXCJ8fFwiO1xuICAgICAgICAgICAgICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKGJhc2ljX25lZ2F0aW9uKHRoaXMpLCBzZWxmKTtcbiAgICAgICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IFwiJiZcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLmxlZnQubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihiYXNpY19uZWdhdGlvbih0aGlzKSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpe1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcIm5lZ2F0ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpcywgY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gaGFzIHNpZGUgZWZmZWN0c1xuICAgIChmdW5jdGlvbihkZWYpe1xuICAgICAgICBkZWYoQVNUX05vZGUsIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gdHJ1ZSB9KTtcblxuICAgICAgICBkZWYoQVNUX0VtcHR5U3RhdGVtZW50LCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX0NvbnN0YW50LCBmdW5jdGlvbihjb21wcmVzc29yKXsgcmV0dXJuIGZhbHNlIH0pO1xuICAgICAgICBkZWYoQVNUX1RoaXMsIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gZmFsc2UgfSk7XG5cbiAgICAgICAgZGVmKEFTVF9DYWxsLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHZhciBwdXJlID0gY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2Z1bmNzXCIpO1xuICAgICAgICAgICAgaWYgKCFwdXJlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBwdXJlLmluZGV4T2YodGhpcy5leHByZXNzaW9uLnByaW50X3RvX3N0cmluZygpKSA8IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlZihBU1RfQmxvY2ssIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYm9keS5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHlbaV0uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlZihBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfRGVmdW4sIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgZGVmKEFTVF9GdW5jdGlvbiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7IHJldHVybiBmYWxzZSB9KTtcbiAgICAgICAgZGVmKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgZGVmKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY29uc2VxdWVudC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5hbHRlcm5hdGl2ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9VbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5vcGVyYXRvciA9PSBcIisrXCJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLm9wZXJhdG9yID09IFwiLS1cIlxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKGNvbXByZXNzb3IpeyByZXR1cm4gZmFsc2UgfSk7XG4gICAgICAgIGRlZihBU1RfT2JqZWN0LCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tpXS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfQXJyYXksIGZ1bmN0aW9uKGNvbXByZXNzb3Ipe1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX0RvdCwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9nZXR0ZXJzXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZihBU1RfU3ViLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIikpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5wcm9wZXJ0eS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmKEFTVF9Qcm9wQWNjZXNzLCBmdW5jdGlvbihjb21wcmVzc29yKXtcbiAgICAgICAgICAgIHJldHVybiAhY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYoQVNUX1NlcSwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXIuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuY2RyLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgICAgIH0pO1xuICAgIH0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpe1xuICAgICAgICBub2RlLkRFRk1FVEhPRChcImhhc19zaWRlX2VmZmVjdHNcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvLyB0ZWxsIG1lIGlmIGEgc3RhdGVtZW50IGFib3J0c1xuICAgIGZ1bmN0aW9uIGFib3J0cyh0aGluZykge1xuICAgICAgICByZXR1cm4gdGhpbmcgJiYgdGhpbmcuYWJvcnRzKCk7XG4gICAgfTtcbiAgICAoZnVuY3Rpb24oZGVmKXtcbiAgICAgICAgZGVmKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKCl7IHJldHVybiBudWxsIH0pO1xuICAgICAgICBkZWYoQVNUX0p1bXAsIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzIH0pO1xuICAgICAgICBmdW5jdGlvbiBibG9ja19hYm9ydHMoKXtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5ib2R5Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBuID4gMCAmJiBhYm9ydHModGhpcy5ib2R5W24gLSAxXSk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZihBU1RfQmxvY2tTdGF0ZW1lbnQsIGJsb2NrX2Fib3J0cyk7XG4gICAgICAgIGRlZihBU1RfU3dpdGNoQnJhbmNoLCBibG9ja19hYm9ydHMpO1xuICAgICAgICBkZWYoQVNUX0lmLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmUgJiYgYWJvcnRzKHRoaXMuYm9keSkgJiYgYWJvcnRzKHRoaXMuYWx0ZXJuYXRpdmUpO1xuICAgICAgICB9KTtcbiAgICB9KShmdW5jdGlvbihub2RlLCBmdW5jKXtcbiAgICAgICAgbm9kZS5ERUZNRVRIT0QoXCJhYm9ydHNcIiwgZnVuYyk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgb3B0aW1pemVycyBdLS0tLS0gKi9cblxuICAgIE9QVChBU1RfRGlyZWN0aXZlLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKHNlbGYuc2NvcGUuaGFzX2RpcmVjdGl2ZShzZWxmLnZhbHVlKSAhPT0gc2VsZi5zY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRyb3BfZGVidWdnZXJcIikpXG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9MYWJlbGVkU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9CcmVha1xuICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc2VsZi5ib2R5LmxhYmVsKSA9PT0gc2VsZi5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYubGFiZWwucmVmZXJlbmNlcy5sZW5ndGggPT0gMCA/IHNlbGYuYm9keSA6IHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0Jsb2NrLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZi5ib2R5ID0gdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9CbG9ja1N0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYuYm9keSA9IHRpZ2h0ZW5fYm9keShzZWxmLmJvZHksIGNvbXByZXNzb3IpO1xuICAgICAgICBzd2l0Y2ggKHNlbGYuYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBzZWxmLmJvZHlbMF07XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBBU1RfU2NvcGUuREVGTUVUSE9EKFwiZHJvcF91bnVzZWRcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpXG4gICAgICAgICAgICAmJiAhKHNlbGYgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpXG4gICAgICAgICAgICAmJiAhc2VsZi51c2VzX2V2YWxcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgaW5fdXNlID0gW107XG4gICAgICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25zID0gbmV3IERpY3Rpb25hcnkoKTtcbiAgICAgICAgICAgIC8vIHBhc3MgMTogZmluZCBvdXQgd2hpY2ggc3ltYm9scyBhcmUgZGlyZWN0bHkgdXNlZCBpblxuICAgICAgICAgICAgLy8gdGhpcyBzY29wZSAobm90IGluIG5lc3RlZCBzY29wZXMpLlxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0dyA9IG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpe1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvbnMuYWRkKG5vZGUubmFtZS5uYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBkb24ndCBnbyBpbiBuZXN0ZWQgc2NvcGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgc2NvcGUgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25zLmFkZChkZWYubmFtZS5uYW1lLCBkZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZS53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoX3VuaXEoaW5fdXNlLCBub2RlLmRlZmluaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhdmVfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc2F2ZV9zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLndhbGsodHcpO1xuICAgICAgICAgICAgLy8gcGFzcyAyOiBmb3IgZXZlcnkgdXNlZCBzeW1ib2wgd2UgbmVlZCB0byB3YWxrIGl0c1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gY29kZSB0byBmaWd1cmUgb3V0IGlmIGl0IHVzZXMgb3RoZXJcbiAgICAgICAgICAgIC8vIHN5bWJvbHMgKHRoYXQgbWF5IG5vdCBiZSBpbl91c2UpLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbl91c2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbl91c2VbaV0ub3JpZy5mb3JFYWNoKGZ1bmN0aW9uKGRlY2wpe1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlY2xhcmVkIGdsb2JhbHMgd2lsbCBiZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSBpbml0aWFsaXphdGlvbnMuZ2V0KGRlY2wubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0KSBpbml0LmZvckVhY2goZnVuY3Rpb24oaW5pdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF91bmlxKGluX3VzZSwgbm9kZS5kZWZpbml0aW9uKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdC53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwYXNzIDM6IHdlIHNob3VsZCBkcm9wIGRlY2xhcmF0aW9ucyBub3QgaW5fdXNlXG4gICAgICAgICAgICB2YXIgdHQgPSBuZXcgVHJlZVRyYW5zZm9ybWVyKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlZm9yZShub2RlLCBkZXNjZW5kLCBpbl9saXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfQWNjZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwia2VlcF9mYXJnc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSBub2RlLmFyZ25hbWVzLCBpID0gYS5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gYVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bS51bnJlZmVyZW5jZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHVudXNlZCBmdW5jdGlvbiBhcmd1bWVudCB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIDogc3ltLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA6IHN5bS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgOiBzeW0uc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgIDogc3ltLnN0YXJ0LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4gJiYgbm9kZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1iZXIobm9kZS5uYW1lLmRlZmluaXRpb24oKSwgaW5fdXNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHVudXNlZCBmdW5jdGlvbiB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA6IG5vZGUubmFtZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIDogbm9kZS5uYW1lLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgOiBub2RlLm5hbWUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sICA6IG5vZGUubmFtZS5zdGFydC5jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiAhKHR0LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0ZvckluKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IG5vZGUuZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcihkZWYubmFtZS5kZWZpbml0aW9uKCksIGluX3VzZSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIDogZGVmLm5hbWUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA6IGRlZi5uYW1lLnN0YXJ0LmZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgOiBkZWYubmFtZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgIDogZGVmLm5hbWUuc3RhcnQuY29sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlICYmIGRlZi52YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi5fdW51c2VkX3NpZGVfZWZmZWN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIlNpZGUgZWZmZWN0cyBpbiBpbml0aWFsaXphdGlvbiBvZiB1bnVzZWQgdmFyaWFibGUge25hbWV9IFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkRyb3BwaW5nIHVudXNlZCB2YXJpYWJsZSB7bmFtZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgdW5pbml0aWFsaXplZCBuYW1lcyBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZiA9IG1lcmdlU29ydChkZWYsIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYS52YWx1ZSAmJiBiLnZhbHVlKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiLnZhbHVlICYmIGEudmFsdWUpIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdW51c2VkIG5hbWVzIHdob3NlIGluaXRpYWxpemF0aW9uIGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2lkZSBlZmZlY3RzLCB3ZSBjYW4gY2FzY2FkZSB0aGUgaW5pdC4gY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGUgbmV4dCBvbmUsIG9yIG5leHQgc3RhdGVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGVfZWZmZWN0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWYubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZGVmW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4Ll91bnVzZWRfc2lkZV9lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cy5wdXNoKHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9lZmZlY3RzLnB1c2goeC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnZhbHVlID0gQVNUX1NlcS5mcm9tX2FycmF5KHNpZGVfZWZmZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGVfZWZmZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9lZmZlY3RzID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBbIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBBU1RfU2VxLmZyb21fYXJyYXkoc2lkZV9lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZWZmZWN0cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmxlbmd0aCA9PSAwICYmICFzaWRlX2VmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGVfZWZmZWN0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVmaW5pdGlvbnMgPSBkZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZV9lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9lZmZlY3RzLmJvZHkudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gc2lkZV9lZmZlY3RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pbml0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb21iaW5hdGlvbiBvZiB1bnVzZWQgbmFtZSArIHNpZGUgZWZmZWN0IGxlYWRzIHRvOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2lzc3Vlcy80NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQncyBhbiBpbnZhbGlkIEFTVC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmaXggaXQgYXQgdGhpcyBzdGFnZSBieSBtb3ZpbmcgdGhlIGB2YXJgIG91dHNpZGUgdGhlIGBmb3JgLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBub2RlLmluaXQuYm9keS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbml0ID0gbm9kZS5pbml0LmJvZHkuc2xpY2UoLTEpWzBdLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc3BsaWNlKGJvZHkpIDogbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUgJiYgbm9kZSAhPT0gc2VsZilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWxmLnRyYW5zZm9ybSh0dCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIEFTVF9TY29wZS5ERUZNRVRIT0QoXCJob2lzdF9kZWNsYXJhdGlvbnNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBob2lzdF9mdW5zID0gY29tcHJlc3Nvci5vcHRpb24oXCJob2lzdF9mdW5zXCIpO1xuICAgICAgICB2YXIgaG9pc3RfdmFycyA9IGNvbXByZXNzb3Iub3B0aW9uKFwiaG9pc3RfdmFyc1wiKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoaG9pc3RfZnVucyB8fCBob2lzdF92YXJzKSB7XG4gICAgICAgICAgICB2YXIgZGlycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGhvaXN0ZWQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2YXJzID0gbmV3IERpY3Rpb25hcnkoKSwgdmFyc19mb3VuZCA9IDAsIHZhcl9kZWNsID0gMDtcbiAgICAgICAgICAgIC8vIGxldCdzIGNvdW50IHZhcl9kZWNsIGZpcnN0LCB3ZSBzZWVtIHRvIHdhc3RlIGEgbG90IG9mXG4gICAgICAgICAgICAvLyBzcGFjZSBpZiB3ZSBob2lzdCBgdmFyYCB3aGVuIHRoZXJlJ3Mgb25seSBvbmUuXG4gICAgICAgICAgICBzZWxmLndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUgJiYgbm9kZSAhPT0gc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICsrdmFyX2RlY2w7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGhvaXN0X3ZhcnMgPSBob2lzdF92YXJzICYmIHZhcl9kZWNsID4gMTtcbiAgICAgICAgICAgIHZhciB0dCA9IG5ldyBUcmVlVHJhbnNmb3JtZXIoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmVmb3JlKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1biAmJiBob2lzdF9mdW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RlZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1ZhciAmJiBob2lzdF92YXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuc2V0KGRlZi5uYW1lLm5hbWUsIGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdmFyc19mb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VxID0gbm9kZS50b19hc3NpZ25tZW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdHQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfRm9ySW4gJiYgcC5pbml0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXEgPT0gbnVsbCkgcmV0dXJuIG5vZGUuZGVmaW5pdGlvbnNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfRm9yICYmIHAuaW5pdCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlcSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzZXFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlOyAvLyB0byBhdm9pZCBkZXNjZW5kaW5nIGluIG5lc3RlZCBzY29wZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWxmID0gc2VsZi50cmFuc2Zvcm0odHQpO1xuICAgICAgICAgICAgaWYgKHZhcnNfZm91bmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBvbmx5IHZhcnMgd2hpY2ggZG9uJ3Qgc2hvdyB1cCBpbiBzZWxmJ3MgYXJndW1lbnRzIGxpc3RcbiAgICAgICAgICAgICAgICB2YXIgZGVmcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhcnMuZWFjaChmdW5jdGlvbihkZWYsIG5hbWUpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZiBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGZpbmRfaWYoZnVuY3Rpb24oeCl7IHJldHVybiB4Lm5hbWUgPT0gZGVmLm5hbWUubmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ25hbWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFycy5kZWwobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYgPSBkZWYuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuc2V0KG5hbWUsIGRlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBtZXJnZSBpbiBhc3NpZ25tZW50c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuYm9keS5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ib2R5W2ldIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByID0gc2VsZi5ib2R5W2ldLmJvZHksIHN5bSwgYXNzaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBleHByLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChzeW0gPSBleHByLmxlZnQpIGluc3RhbmNlb2YgQVNUX1N5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2YXJzLmhhcyhzeW0ubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gdmFycy5nZXQoc3ltLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gZXhwci5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGRlZnMsIGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU2VxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChhc3NpZ24gPSBleHByLmNhcikgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGFzc2lnbi5vcGVyYXRvciA9PSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc3ltID0gYXNzaWduLmxlZnQpIGluc3RhbmNlb2YgQVNUX1N5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2YXJzLmhhcyhzeW0ubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gdmFycy5nZXQoc3ltLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gYXNzaWduLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoZGVmcywgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcy5wdXNoKGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keVtpXS5ib2R5ID0gZXhwci5jZHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJvZHlbaV0gaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYm9keVtpXSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBbIGksIDEgXS5jb25jYXQoc2VsZi5ib2R5W2ldLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keS5zcGxpY2UuYXBwbHkoc2VsZi5ib2R5LCB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmcyA9IG1ha2Vfbm9kZShBU1RfVmFyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uczogZGVmc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaG9pc3RlZC5wdXNoKGRlZnMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmJvZHkgPSBkaXJzLmNvbmNhdChob2lzdGVkLCBzZWxmLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJEcm9wcGluZyBzaWRlLWVmZmVjdC1mcmVlIHN0YXRlbWVudCBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9EV0xvb3AsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGNvbmRbMF07XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJsb29wc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjb25kLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb25kWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRm9yLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuYm9keVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX1doaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfZGVjbGFyYXRpb25zX2Zyb21fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzZWxmLmJvZHksIGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcikge1xuICAgICAgICBmdW5jdGlvbiBkcm9wX2l0KHJlc3QpIHtcbiAgICAgICAgICAgIHJlc3QgPSBhc19zdGF0ZW1lbnRfYXJyYXkocmVzdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5LmJvZHkgPSByZXN0LmNvbmNhdChzZWxmLmJvZHkuYm9keS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib2R5ID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZi5ib2R5LCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHJlc3RcbiAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdCA9IHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCA/IHNlbGYuYm9keS5ib2R5WzBdIDogc2VsZi5ib2R5O1xuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdC5ib2R5IGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoZmlyc3QuYm9keS5sYWJlbCkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmaXJzdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGZpcnN0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyb3BfaXQoZmlyc3QuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfQnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICYmIGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KGZpcnN0LmFsdGVybmF0aXZlLmxhYmVsKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZpcnN0LmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBmaXJzdC5jb25kaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyb3BfaXQoZmlyc3QuYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgT1BUKEFTVF9XaGlsZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwibG9vcHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICBzZWxmID0gQVNUX0RXTG9vcC5wcm90b3R5cGUub3B0aW1pemUuY2FsbChzZWxmLCBjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfV2hpbGUpIHtcbiAgICAgICAgICAgIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9Gb3IsIHNlbGYsIHNlbGYpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRm9yLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKGNvbmQpIHtcbiAgICAgICAgICAgIGNvbmQgPSBjb25kLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBjb25kWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJsb29wc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjb25kKSB7XG4gICAgICAgICAgICBpZiAoY29uZC5sZW5ndGggPiAxICYmICFjb25kWzFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmluaXQgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goc2VsZi5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5pbml0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VsZi5pbml0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9kZWNsYXJhdGlvbnNfZnJvbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYm9keSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmX2JyZWFrX2luX2xvb3Aoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikpIHJldHVybiBzZWxmO1xuICAgICAgICAvLyBpZiBjb25kaXRpb24gY2FuIGJlIHN0YXRpY2FsbHkgZGV0ZXJtaW5lZCwgd2FybiBhbmQgZHJvcFxuICAgICAgICAvLyBvbmUgb2YgdGhlIGJsb2Nrcy4gIG5vdGUsIHN0YXRpY2FsbHkgZGV0ZXJtaW5lZCBpbXBsaWVzXG4gICAgICAgIC8vIOKAnGhhcyBubyBzaWRlIGVmZmVjdHPigJ07IGFsc28gaXQgZG9lc24ndCB3b3JrIGZvciBjYXNlcyBsaWtlXG4gICAgICAgIC8vIGB4ICYmIHRydWVgLCB0aG91Z2ggaXQgcHJvYmFibHkgc2hvdWxkLlxuICAgICAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGNvbmRbMF07XG4gICAgICAgIGlmIChjb25kLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb25kWzFdKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLmNvbmRpdGlvbi5zdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5hbHRlcm5hdGl2ZSwgYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHNlbGYuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IGEgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyBmYWxzZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5jb25kaXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2RlY2xhcmF0aW9uc19mcm9tX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5ib2R5LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIGEucHVzaChzZWxmLmFsdGVybmF0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHsgYm9keTogYSB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc19lbXB0eShzZWxmLmFsdGVybmF0aXZlKSkgc2VsZi5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgIHZhciBuZWdhdGVkID0gc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICB2YXIgbmVnYXRlZF9pc19iZXN0ID0gYmVzdF9vZihzZWxmLmNvbmRpdGlvbiwgbmVnYXRlZCkgPT09IG5lZ2F0ZWQ7XG4gICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlICYmIG5lZ2F0ZWRfaXNfYmVzdCkge1xuICAgICAgICAgICAgbmVnYXRlZF9pc19iZXN0ID0gZmFsc2U7IC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBkbyB0aGUgc3dpdGNoIGhlcmUuXG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG5lZ2F0ZWQ7XG4gICAgICAgICAgICB2YXIgdG1wID0gc2VsZi5ib2R5O1xuICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5hbHRlcm5hdGl2ZSB8fCBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50KTtcbiAgICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX2VtcHR5KHNlbGYuYm9keSkgJiYgaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvblxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50XG4gICAgICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gICA6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHNlbGYuYm9keS5ib2R5LFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IHNlbGYuYWx0ZXJuYXRpdmUuYm9keVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX2VtcHR5KHNlbGYuYWx0ZXJuYXRpdmUpICYmIHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChuZWdhdGVkX2lzX2Jlc3QpIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCJ8fFwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IG5lZ2F0ZWQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5ib2R5LmJvZHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogc2VsZi5jb25kaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5ib2R5LmJvZHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnRcbiAgICAgICAgICAgICYmIHNlbGYuYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICYmIHNlbGYuYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwifHxcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLmFsdGVybmF0aXZlLmJvZHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRXhpdFxuICAgICAgICAgICAgJiYgc2VsZi5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9FeGl0XG4gICAgICAgICAgICAmJiBzZWxmLmJvZHkuVFlQRSA9PSBzZWxmLmFsdGVybmF0aXZlLlRZUEUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoc2VsZi5ib2R5LkNUT1IsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gICA6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHNlbGYuYm9keS52YWx1ZSB8fCBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5ib2R5KS5vcHRpbWl6ZShjb21wcmVzc29yKSxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBzZWxmLmFsdGVybmF0aXZlLnZhbHVlIHx8IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmLmFsdGVybmF0aXZlKS5vcHRpbWl6ZShjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9JZlxuICAgICAgICAgICAgJiYgIXNlbGYuYm9keS5hbHRlcm5hdGl2ZVxuICAgICAgICAgICAgJiYgIXNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByaWdodDogc2VsZi5ib2R5LmNvbmRpdGlvblxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0cyhzZWxmLmJvZHkpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhbHQgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IFsgc2VsZiwgYWx0IF1cbiAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0cyhzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBzZWxmLmJvZHk7XG4gICAgICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBuZWdhdGVkX2lzX2Jlc3QgPyBuZWdhdGVkIDogc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IFsgc2VsZiwgYm9keSBdXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChzZWxmLmJvZHkubGVuZ3RoID09IDAgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJjb25kaXRpb25hbHNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuZXhwcmVzc2lvblxuICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgdmFyIGxhc3RfYnJhbmNoID0gc2VsZi5ib2R5W3NlbGYuYm9keS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2JyYW5jaCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ID0gbGFzdF9icmFuY2guYm9keVtsYXN0X2JyYW5jaC5ib2R5Lmxlbmd0aCAtIDFdOyAvLyBsYXN0IHN0YXRlbWVudFxuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0JyZWFrICYmIGxvb3BfYm9keShjb21wcmVzc29yLmxvb3Bjb250cm9sX3RhcmdldChzdGF0LmxhYmVsKSkgPT09IHNlbGYpXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfYnJhbmNoLmJvZHkucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RfYnJhbmNoIGluc3RhbmNlb2YgQVNUX0RlZmF1bHQgJiYgbGFzdF9icmFuY2guYm9keS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIG91dDogaWYgKGV4cC5sZW5ndGggPT0gMikgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNvbnN0YW50IGV4cHJlc3Npb25cbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IGV4cFswXTtcbiAgICAgICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikpIGJyZWFrIG91dDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cFsxXTtcbiAgICAgICAgICAgIHZhciBpbl9pZiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGluX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBydWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB0dCA9IG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCwgaW5fbGlzdCl7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gZGVzY2VuZCB0aGVzZSBub2RlIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N3aXRjaCAmJiBub2RlID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWluZWQgPyBub2RlIDogbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbm9kZS5ib2R5LnJlZHVjZShmdW5jdGlvbihhLCBicmFuY2gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbmNhdChicmFuY2guYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0lmIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfVHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYXZlID0gaW5faWY7XG4gICAgICAgICAgICAgICAgICAgIGluX2lmID0gIWluX2Jsb2NrO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpbl9pZiA9IHNhdmU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFdpdGhCb2R5IHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYXZlID0gaW5fYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGluX2Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5fYmxvY2sgPSBzYXZlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiB0aGlzLmxvb3Bjb250cm9sX3RhcmdldChub2RlLmxhYmVsKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5faWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1aW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5fYmxvY2spIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc2tpcCA6IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N3aXRjaEJyYW5jaCAmJiB0aGlzLnBhcmVudCgpID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wcGVkKSByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Nhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHAgPSBub2RlLmV4cHJlc3Npb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnb3QgYSBjYXNlIHdpdGggbm9uLWNvbnN0YW50IGV4cHJlc3Npb24sIGJhbGluZyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZWxmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFsxXSA9PT0gdmFsdWUgfHwgc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydHMobm9kZSkpIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUFQLnNraXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0dC5zdGFjayA9IGNvbXByZXNzb3Iuc3RhY2suc2xpY2UoKTsgLy8gc28gdGhhdCdzIGFibGUgdG8gc2VlIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgc2VsZiA9IHNlbGYudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgaWYgKGV4ICE9PSBzZWxmKSB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQ2FzZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHNlbGYuYm9keSA9IHRpZ2h0ZW5fYm9keShzZWxmLmJvZHksIGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVHJ5LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZi5ib2R5ID0gdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgQVNUX0RlZmluaXRpb25zLkRFRk1FVEhPRChcInJlbW92ZV9pbml0aWFsaXplcnNcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZil7IGRlZi52YWx1ZSA9IG51bGwgfSk7XG4gICAgfSk7XG5cbiAgICBBU1RfRGVmaW5pdGlvbnMuREVGTUVUSE9EKFwidG9fYXNzaWdubWVudHNcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGFzc2lnbm1lbnRzID0gdGhpcy5kZWZpbml0aW9ucy5yZWR1Y2UoZnVuY3Rpb24oYSwgZGVmKXtcbiAgICAgICAgICAgIGlmIChkZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBkZWYubmFtZSwgZGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIGEucHVzaChtYWtlX25vZGUoQVNUX0Fzc2lnbiwgZGVmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBkZWYudmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBpZiAoYXNzaWdubWVudHMubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gQVNUX1NlcS5mcm9tX2FycmF5KGFzc2lnbm1lbnRzKTtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoc2VsZi5kZWZpbml0aW9ucy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgc2VsZiA9IEFTVF9MYW1iZGEucHJvdG90eXBlLm9wdGltaXplLmNhbGwoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVudXNlZFwiKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYubmFtZSAmJiBzZWxmLm5hbWUudW5yZWZlcmVuY2VkKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXhwID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgZXhwLnVuZGVjbGFyZWQoKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9BcnJheSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBzZWxmLmFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfT2JqZWN0LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA8PSAxKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KVxuICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIk51bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAwKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAxKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5hcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiXG4gICAgICAgICAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJCb29sZWFuXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHJldHVybiBtYWtlX25vZGUoQVNUX0ZhbHNlLCBzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBzZWxmLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIlxuICAgICAgICAgICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGwoc2VsZi5hcmdzLCBmdW5jdGlvbih4KXsgcmV0dXJuIHggaW5zdGFuY2VvZiBBU1RfU3RyaW5nIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBxdWl0ZSBhIGNvcm5lci1jYXNlLCBidXQgd2UgY2FuIGhhbmRsZSBpdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzIwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvZGUgYXJndW1lbnQgaXMgYSBjb25zdGFudCwgdGhlbiB3ZSBjYW4gbWluaWZ5IGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IFwiKGZ1bmN0aW9uKFwiICsgc2VsZi5hcmdzLnNsaWNlKDAsIC0xKS5tYXAoZnVuY3Rpb24oYXJnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiKXtcIiArIHNlbGYuYXJnc1tzZWxmLmFyZ3MubGVuZ3RoIC0gMV0udmFsdWUgKyBcIn0pKClcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gcGFyc2UoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmZpZ3VyZV9vdXRfc2NvcGUoeyBzY3Jld19pZTg6IGNvbXByZXNzb3Iub3B0aW9uKFwic2NyZXdfaWU4XCIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wID0gbmV3IENvbXByZXNzb3IoY29tcHJlc3Nvci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QgPSBhc3QudHJhbnNmb3JtKGNvbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdC5maWd1cmVfb3V0X3Njb3BlKHsgc2NyZXdfaWU4OiBjb21wcmVzc29yLm9wdGlvbihcInNjcmV3X2llOFwiKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3QubWFuZ2xlX25hbWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Qud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1biA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXggIT09IGFzdCkgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGZ1bi5hcmduYW1lcy5tYXAoZnVuY3Rpb24oYXJnLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLmFyZ3NbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcucHJpbnRfdG9fc3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBU1RfQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLl9jb2RlZ2VuLmNhbGwoZnVuLCBmdW4sIGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnRvU3RyaW5nKCkucmVwbGFjZSgvXlxce3xcXH0kL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZi5hcmdzW3NlbGYuYXJncy5sZW5ndGggLSAxXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIEpTX1BhcnNlX0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkVycm9yIHBhcnNpbmcgY29kZSBwYXNzZWQgdG8gbmV3IEZ1bmN0aW9uIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLmFyZ3Nbc2VsZi5hcmdzLmxlbmd0aCAtIDFdLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9Eb3QgJiYgZXhwLnByb3BlcnR5ID09IFwidG9TdHJpbmdcIiAmJiBzZWxmLmFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cC5leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwIGluc3RhbmNlb2YgQVNUX0RvdCAmJiBleHAuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9BcnJheSAmJiBleHAucHJvcGVydHkgPT0gXCJqb2luXCIpIEVYSVQ6IHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gc2VsZi5hcmdzLmxlbmd0aCA9PSAwID8gXCIsXCIgOiBzZWxmLmFyZ3NbMF0uZXZhbHVhdGUoY29tcHJlc3NvcilbMV07XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PSBudWxsKSBicmVhayBFWElUOyAvLyBub3QgYSBjb25zdGFudFxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGV4cC5leHByZXNzaW9uLmVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbihhLCBlbCl7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gZWwuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCA9PSAwIHx8IGVsLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBhW2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdC5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBcIlwiICsgbGFzdFsxXSArIHNlcGFyYXRvciArIGVsWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IFsgbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29tcHJlc3NvciwgdmFsLCBsYXN0WzBdKSwgdmFsIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7IHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIGVsZW1lbnRzWzBdWzBdO1xuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1swXVswXSBpbnN0YW5jZW9mIEFTVF9TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGVsZW1lbnRzWzFdWzBdIGluc3RhbmNlb2YgQVNUX1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBlbGVtZW50cy5zaGlmdCgpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgZWxbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgICAgIDogcHJldixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IGVsWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZpcnN0KS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBhd2t3YXJkIGNsb25pbmcgdG8gbm90IGFmZmVjdCBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gYmVzdF9vZiB3aWxsIGRlY2lkZSB3aGljaCBvbmUgdG8gZ2V0IHRocm91Z2guXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzZWxmLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uID0gbm9kZS5leHByZXNzaW9uLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24gPSBub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uLmVsZW1lbnRzID0gZWxlbWVudHMubWFwKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0X29mKHNlbGYsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvblxuICAgICAgICAgICAgICAgICYmIHNlbGYuYXJncy5sZW5ndGggPT0gMFxuICAgICAgICAgICAgICAgICYmICFBU1RfQmxvY2sucHJvdG90eXBlLmhhc19zaWRlX2VmZmVjdHMuY2FsbChzZWxmLmV4cHJlc3Npb24sIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZHJvcF9jb25zb2xlXCIpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24uZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24uZXhwcmVzc2lvbi5uYW1lID09IFwiY29uc29sZVwiICYmXG4gICAgICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLmV4cHJlc3Npb24udW5kZWNsYXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKS50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZXZhbHVhdGUoY29tcHJlc3NvcilbMF07XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX05ldywgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZVwiKSkge1xuICAgICAgICAgICAgdmFyIGV4cCA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChleHAgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIGV4cC51bmRlY2xhcmVkKCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiUmVnRXhwXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0NhbGwsIHNlbGYsIHNlbGYpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1NlcSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikpXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKCFzZWxmLmNhci5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3QgY29tcHJlc3MgKDEsZXZhbCkoc29tZXRoaW5nKSB0b1xuICAgICAgICAgICAgLy8gZXZhbChzb21ldGhpbmcpIGJlY2F1c2UgdGhhdCBjaGFuZ2VzIHRoZSBtZWFuaW5nIG9mXG4gICAgICAgICAgICAvLyBldmFsIChiZWNvbWVzIGxleGljYWwgaW5zdGVhZCBvZiBnbG9iYWwpLlxuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBpZiAoIShzZWxmLmNkciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICYmIHNlbGYuY2RyLm5hbWUgPT0gXCJldmFsXCJcbiAgICAgICAgICAgICAgICAgICYmIHNlbGYuY2RyLnVuZGVjbGFyZWQoKVxuICAgICAgICAgICAgICAgICAgJiYgKHAgPSBjb21wcmVzc29yLnBhcmVudCgpKSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImNhc2NhZGVcIikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNhciBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAmJiAhc2VsZi5jYXIubGVmdC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FyLmxlZnQuZXF1aXZhbGVudF90byhzZWxmLmNkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jZHIgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmNkci5leHByZXNzaW9uLmVxdWl2YWxlbnRfdG8oc2VsZi5jYXIubGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jZHIuZXhwcmVzc2lvbiA9IHNlbGYuY2FyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jZHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNhci5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgJiYgIXNlbGYuY2RyLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmNhci5lcXVpdmFsZW50X3RvKHNlbGYuY2RyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5jZHIgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICYmIHNlbGYuY2RyLm9wZXJhdG9yID09IFwidm9pZFwiXG4gICAgICAgICAgICAmJiAhc2VsZi5jZHIuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICBzZWxmLmNkci5vcGVyYXRvciA9IHNlbGYuY2FyO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmNkciBpbnN0YW5jZW9mIEFTVF9VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgICA6IFwidm9pZFwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBzZWxmLmNhclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBBU1RfVW5hcnkuREVGTUVUSE9EKFwibGlmdF9zZXF1ZW5jZXNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc2VxLnRvX2FycmF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHgpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9VbmFyeVBvc3RmaXgsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICByZXR1cm4gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICAgICAgdmFyIGUgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpICYmIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIGUub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gISFmb28gPT0+IGZvbywgaWYgd2UncmUgaW4gYm9vbGVhbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidHlwZW9mXCI6XG4gICAgICAgICAgICAgICAgLy8gdHlwZW9mIGFsd2F5cyByZXR1cm5zIGEgbm9uLWVtcHR5IHN0cmluZywgdGh1cyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIHRydWUgaW4gYm9vbGVhbnNcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJCb29sZWFuIGV4cHJlc3Npb24gYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIHNlbGYub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gYmVzdF9vZihzZWxmLCBlLm5lZ2F0ZShjb21wcmVzc29yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuZXZhbHVhdGUoY29tcHJlc3NvcilbMF07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBoYXNfc2lkZV9lZmZlY3RzX29yX3Byb3BfYWNjZXNzKG5vZGUsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIHNhdmVfcHVyZV9nZXR0ZXJzID0gY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIik7XG4gICAgICAgIGNvbXByZXNzb3Iub3B0aW9ucy5wdXJlX2dldHRlcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICAgICAgY29tcHJlc3Nvci5vcHRpb25zLnB1cmVfZ2V0dGVycyA9IHNhdmVfcHVyZV9nZXR0ZXJzO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIEFTVF9CaW5hcnkuREVGTUVUSE9EKFwibGlmdF9zZXF1ZW5jZXNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciB4ID0gc2VxLnRvX2FycmF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHgpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgaW5zdGFuY2VvZiBBU1RfU2VxXG4gICAgICAgICAgICAgICAgJiYgdGhpcyBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAmJiAhaGFzX3NpZGVfZWZmZWN0c19vcl9wcm9wX2FjY2Vzcyh0aGlzLmxlZnQsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IHRoaXMucmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBzZXEudG9fYXJyYXkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgc2VxID0gQVNUX1NlcS5mcm9tX2FycmF5KHgpLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgdmFyIGNvbW11dGF0aXZlT3BlcmF0b3JzID0gbWFrZVByZWRpY2F0ZShcIj09ID09PSAhPSAhPT0gKiAmIHwgXlwiKTtcblxuICAgIE9QVChBU1RfQmluYXJ5LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgdmFyIHJldmVyc2UgPSBjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2UgYXNtXCIpID8gbm9vcFxuICAgICAgICAgICAgOiBmdW5jdGlvbihvcCwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UgfHwgIShzZWxmLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSB8fCBzZWxmLnJpZ2h0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcCkgc2VsZi5vcGVyYXRvciA9IG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc2VsZi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gdG1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmIChjb21tdXRhdGl2ZU9wZXJhdG9ycyhzZWxmLm9wZXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiByaWdodCBpcyBhIGNvbnN0YW50LCB3aGF0ZXZlciBzaWRlIGVmZmVjdHMgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVmdCBzaWRlIG1pZ2h0IGhhdmUgY291bGQgbm90IGluZmx1ZW5jZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXN1bHQuICBoZW5jZSwgZm9yY2Ugc3dpdGNoLlxuXG4gICAgICAgICAgICAgICAgaWYgKCEoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAgICYmIFBSRUNFREVOQ0Vbc2VsZi5sZWZ0Lm9wZXJhdG9yXSA+PSBQUkVDRURFTkNFW3NlbGYub3BlcmF0b3JdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXlshPV09PT8kLy50ZXN0KHNlbGYub3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodC5jb25zZXF1ZW50IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5jb25zZXF1ZW50LmRlZmluaXRpb24oKSA9PT0gc2VsZi5sZWZ0LmRlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9ePT0vLnRlc3Qoc2VsZi5vcGVyYXRvcikpIHJldHVybiBzZWxmLnJpZ2h0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXiE9Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5yaWdodC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0LmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5hbHRlcm5hdGl2ZS5kZWZpbml0aW9uKCkgPT09IHNlbGYubGVmdC5kZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXj09Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5yaWdodC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eIT0vLnRlc3Qoc2VsZi5vcGVyYXRvcikpIHJldHVybiBzZWxmLnJpZ2h0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnQuY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5jb25zZXF1ZW50LmRlZmluaXRpb24oKSA9PT0gc2VsZi5yaWdodC5kZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXj09Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5sZWZ0LmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXiE9Ly50ZXN0KHNlbGYub3BlcmF0b3IpKSByZXR1cm4gc2VsZi5sZWZ0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdC5hbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5hbHRlcm5hdGl2ZS5kZWZpbml0aW9uKCkgPT09IHNlbGYucmlnaHQuZGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL149PS8udGVzdChzZWxmLm9wZXJhdG9yKSkgcmV0dXJuIHNlbGYubGVmdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eIT0vLnRlc3Qoc2VsZi5vcGVyYXRvcikpIHJldHVybiBzZWxmLmxlZnQuY29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYgPSBzZWxmLmxpZnRfc2VxdWVuY2VzKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJjb21wYXJpc29uc1wiKSkgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIj09PVwiOlxuICAgICAgICAgIGNhc2UgXCIhPT1cIjpcbiAgICAgICAgICAgIGlmICgoc2VsZi5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKSAmJiBzZWxmLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5sZWZ0LmlzX2Jvb2xlYW4oKSAmJiBzZWxmLnJpZ2h0LmlzX2Jvb2xlYW4oKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gc2VsZi5vcGVyYXRvci5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBYWFg6IGludGVudGlvbmFsbHkgZmFsbGluZyBkb3duIHRvIHRoZSBuZXh0IGNhc2VcbiAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICBjYXNlIFwiIT1cIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LnZhbHVlID09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBcInR5cGVvZlwiXG4gICAgICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShzZWxmLnJpZ2h0LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKVxuICAgICAgICAgICAgICAgICAgICB8fCAhc2VsZi5yaWdodC5leHByZXNzaW9uLnVuZGVjbGFyZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5sZWZ0KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IubGVuZ3RoID09IDIpIHNlbGYub3BlcmF0b3IgKz0gXCI9XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiYm9vbGVhbnNcIikgJiYgY29tcHJlc3Nvci5pbl9ib29sZWFuX2NvbnRleHQoKSkgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIiYmXCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKChsbC5sZW5ndGggPiAxICYmICFsbFsxXSkgfHwgKHJyLmxlbmd0aCA+IDEgJiYgIXJyWzFdKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkJvb2xlYW4gJiYgYWx3YXlzIGZhbHNlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9GYWxzZSwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGwubGVuZ3RoID4gMSAmJiBsbFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyci5sZW5ndGggPiAxICYmIHJyWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxsWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKChsbC5sZW5ndGggPiAxICYmIGxsWzFdKSB8fCAocnIubGVuZ3RoID4gMSAmJiByclsxXSkpIHtcbiAgICAgICAgICAgICAgICBjb21wcmVzc29yLndhcm4oXCJCb29sZWFuIHx8IGFsd2F5cyB0cnVlIFt7ZmlsZX06e2xpbmV9LHtjb2x9XVwiLCBzZWxmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsbC5sZW5ndGggPiAxICYmICFsbFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyci5sZW5ndGggPiAxICYmICFyclsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsbFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKChsbC5sZW5ndGggPiAxICYmIGxsWzBdIGluc3RhbmNlb2YgQVNUX1N0cmluZyAmJiBsbFsxXSkgfHxcbiAgICAgICAgICAgICAgICAocnIubGVuZ3RoID4gMSAmJiByclswXSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgJiYgcnJbMV0pKSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiKyBpbiBib29sZWFuIGNvbnRleHQgYWx3YXlzIHRydWUgW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHNlbGYuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiY29tcGFyaXNvbnNcIikpIHtcbiAgICAgICAgICAgIGlmICghKGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KVxuICAgICAgICAgICAgICAgIHx8IGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5lZ2F0ZWQgPSBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5uZWdhdGUoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmID0gYmVzdF9vZihzZWxmLCBuZWdhdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiPFwiOiByZXZlcnNlKFwiPlwiKTsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PVwiOiByZXZlcnNlKFwiPj1cIik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiK1wiICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3RyaW5nXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmdldFZhbHVlKCkgPT09IFwiXCIgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiK1wiICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZXZhbHVhdGVcIikpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IFwiK1wiXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIgKyBzZWxmLmxlZnQuZ2V0VmFsdWUoKSArIHNlbGYucmlnaHQubGVmdC5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWxmLmxlZnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWxmLnJpZ2h0LmxlZnQuZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdC5vcGVyYXRvciA9PSBcIitcIlxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIgKyBzZWxmLmxlZnQucmlnaHQuZ2V0VmFsdWUoKSArIHNlbGYucmlnaHQuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZi5sZWZ0LnJpZ2h0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc2VsZi5yaWdodC5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LmlzX3N0cmluZyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBcIitcIlxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmxlZnQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX1N0cmluZywgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiArIHNlbGYubGVmdC5yaWdodC5nZXRWYWx1ZSgpICsgc2VsZi5yaWdodC5sZWZ0LmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWxmLmxlZnQucmlnaHQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc2VsZi5yaWdodC5sZWZ0LmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB4ICogKHkgKiB6KSAgPT0+ICB4ICogeSAqIHpcbiAgICAgICAgaWYgKHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IHNlbGYub3BlcmF0b3JcbiAgICAgICAgICAgICYmIChzZWxmLm9wZXJhdG9yID09IFwiKlwiIHx8IHNlbGYub3BlcmF0b3IgPT0gXCImJlwiIHx8IHNlbGYub3BlcmF0b3IgPT0gXCJ8fFwiKSlcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsZi5sZWZ0ID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYubGVmdCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IHNlbGYubGVmdCxcbiAgICAgICAgICAgICAgICByaWdodCAgICA6IHNlbGYucmlnaHQubGVmdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5yaWdodDtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5ldmFsdWF0ZShjb21wcmVzc29yKVswXTtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKHNlbGYudW5kZWNsYXJlZCgpKSB7XG4gICAgICAgICAgICB2YXIgZGVmaW5lcyA9IGNvbXByZXNzb3Iub3B0aW9uKFwiZ2xvYmFsX2RlZnNcIik7XG4gICAgICAgICAgICBpZiAoZGVmaW5lcyAmJiBkZWZpbmVzLmhhc093blByb3BlcnR5KHNlbGYubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29tcHJlc3NvciwgZGVmaW5lc1tzZWxmLm5hbWVdLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpO1xuICAgICAgICAgICAgICBjYXNlIFwiTmFOXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTmFOLCBzZWxmKTtcbiAgICAgICAgICAgICAgY2FzZSBcIkluZmluaXR5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfSW5maW5pdHksIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH0pO1xuXG4gICAgT1BUKEFTVF9VbmRlZmluZWQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IGNvbXByZXNzb3IuZmluZF9wYXJlbnQoQVNUX1Njb3BlKTtcbiAgICAgICAgICAgIHZhciB1bmRlZiA9IHNjb3BlLmZpbmRfdmFyaWFibGUoXCJ1bmRlZmluZWRcIik7XG4gICAgICAgICAgICBpZiAodW5kZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSAgIDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgIDogc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIHRoZWRlZiA6IHVuZGVmXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVmLnJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICB2YXIgQVNTSUdOX09QUyA9IFsgJysnLCAnLScsICcvJywgJyonLCAnJScsICc+PicsICc8PCcsICc+Pj4nLCAnfCcsICdeJywgJyYnIF07XG4gICAgT1BUKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3Ipe1xuICAgICAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmxlZnQubmFtZSA9PSBzZWxmLmxlZnQubmFtZVxuICAgICAgICAgICAgJiYgbWVtYmVyKHNlbGYucmlnaHQub3BlcmF0b3IsIEFTU0lHTl9PUFMpKSB7XG4gICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gc2VsZi5yaWdodC5vcGVyYXRvciArIFwiPVwiO1xuICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbiBpbnN0YW5jZW9mIEFTVF9TZXEpIHtcbiAgICAgICAgICAgIHZhciBjYXIgPSBzZWxmLmNvbmRpdGlvbi5jYXI7XG4gICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLmNkcjtcbiAgICAgICAgICAgIHJldHVybiBBU1RfU2VxLmNvbnMoY2FyLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoY29uZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoY29uZFsxXSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIkNvbmRpdGlvbiBhbHdheXMgdHJ1ZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uc2VxdWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Nvci53YXJuKFwiQ29uZGl0aW9uIGFsd2F5cyBmYWxzZSBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgc2VsZi5zdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lZ2F0ZWQgPSBjb25kWzBdLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGJlc3Rfb2YoY29uZFswXSwgbmVnYXRlZCkgPT09IG5lZ2F0ZWQpIHtcbiAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBuZWdhdGVkLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IHNlbGYuYWx0ZXJuYXRpdmUsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IHNlbGYuY29uc2VxdWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSBzZWxmLmNvbnNlcXVlbnQ7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZSA9IHNlbGYuYWx0ZXJuYXRpdmU7XG4gICAgICAgIGlmIChjb25zZXF1ZW50IGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgJiYgYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAmJiBjb25zZXF1ZW50Lm9wZXJhdG9yID09IGFsdGVybmF0aXZlLm9wZXJhdG9yXG4gICAgICAgICAgICAmJiBjb25zZXF1ZW50LmxlZnQuZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZS5sZWZ0KVxuICAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBTdHVmZiBsaWtlIHRoaXM6XG4gICAgICAgICAgICAgKiBpZiAoZm9vKSBleHAgPSBzb21ldGhpbmc7IGVsc2UgZXhwID0gc29tZXRoaW5nX2Vsc2U7XG4gICAgICAgICAgICAgKiA9PT5cbiAgICAgICAgICAgICAqIGV4cCA9IGZvbyA/IHNvbWV0aGluZyA6IHNvbWV0aGluZ19lbHNlO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Bc3NpZ24sIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogY29uc2VxdWVudC5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBsZWZ0OiBjb25zZXF1ZW50LmxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGFsdGVybmF0aXZlLnJpZ2h0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zZXF1ZW50IGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgICYmIGFsdGVybmF0aXZlLlRZUEUgPT09IGNvbnNlcXVlbnQuVFlQRVxuICAgICAgICAgICAgJiYgY29uc2VxdWVudC5hcmdzLmxlbmd0aCA9PSBhbHRlcm5hdGl2ZS5hcmdzLmxlbmd0aFxuICAgICAgICAgICAgJiYgY29uc2VxdWVudC5leHByZXNzaW9uLmVxdWl2YWxlbnRfdG8oYWx0ZXJuYXRpdmUuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChjb25zZXF1ZW50LmFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TZXEsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2RyOiBjb25zZXF1ZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc2VxdWVudC5hcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc2VxdWVudC5hcmdzWzBdID0gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBhbHRlcm5hdGl2ZS5hcmdzWzBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8geD95P3o6YTphIC0tPiB4JiZ5P3o6YVxuICAgICAgICBpZiAoY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbFxuICAgICAgICAgICAgJiYgY29uc2VxdWVudC5hbHRlcm5hdGl2ZS5lcXVpdmFsZW50X3RvKGFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29uc2VxdWVudC5jb25kaXRpb25cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LmNvbnNlcXVlbnQsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGFsdGVybmF0aXZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfQm9vbGVhbiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImJvb2xlYW5zXCIpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGNvbXByZXNzb3IucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgKHAub3BlcmF0b3IgPT0gXCI9PVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHAub3BlcmF0b3IgPT0gXCIhPVwiKSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzb3Iud2FybihcIk5vbi1zdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCBib29sZWFuOiB7b3BlcmF0b3J9IHt2YWx1ZX0gW3tmaWxlfTp7bGluZX0se2NvbH1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBwLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHNlbGYudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUgICAgIDogcC5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lICAgICA6IHAuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sICAgICAgOiBwLnN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICtzZWxmLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMSAtIHNlbGYudmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSk7XG5cbiAgICBPUFQoQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcil7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0eTtcbiAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfU3RyaW5nICYmIGNvbXByZXNzb3Iub3B0aW9uKFwicHJvcGVydGllc1wiKSkge1xuICAgICAgICAgICAgcHJvcCA9IHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChSRVNFUlZFRF9XT1JEUyhwcm9wKSA/IGNvbXByZXNzb3Iub3B0aW9uKFwic2NyZXdfaWU4XCIpIDogaXNfaWRlbnRpZmllcl9zdHJpbmcocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Eb3QsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHNlbGYuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IHByb3BcbiAgICAgICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2ID0gcGFyc2VGbG9hdChwcm9wKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4odikgJiYgdi50b1N0cmluZygpID09IHByb3ApIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByb3BlcnR5ID0gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYucHJvcGVydHksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcblxuICAgIE9QVChBU1RfRG90LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKXtcbiAgICAgICAgcmV0dXJuIHNlbGYuZXZhbHVhdGUoY29tcHJlc3NvcilbMF07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsaXRlcmFsc19pbl9ib29sZWFuX2NvbnRleHQoc2VsZiwgY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJib29sZWFuc1wiKSAmJiBjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIE9QVChBU1RfQXJyYXksIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dCk7XG4gICAgT1BUKEFTVF9PYmplY3QsIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dCk7XG4gICAgT1BUKEFTVF9SZWdFeHAsIGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dCk7XG5cbn0pKCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGEgc21hbGwgd3JhcHBlciBhcm91bmQgZml0emdlbidzIHNvdXJjZS1tYXAgbGlicmFyeVxuZnVuY3Rpb24gU291cmNlTWFwKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBmaWxlIDogbnVsbCxcbiAgICAgICAgcm9vdCA6IG51bGwsXG4gICAgICAgIG9yaWcgOiBudWxsLFxuXG4gICAgICAgIG9yaWdfbGluZV9kaWZmIDogMCxcbiAgICAgICAgZGVzdF9saW5lX2RpZmYgOiAwLFxuICAgIH0pO1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgTU9aX1NvdXJjZU1hcC5Tb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlICAgICAgIDogb3B0aW9ucy5maWxlLFxuICAgICAgICBzb3VyY2VSb290IDogb3B0aW9ucy5yb290XG4gICAgfSk7XG4gICAgdmFyIG9yaWdfbWFwID0gb3B0aW9ucy5vcmlnICYmIG5ldyBNT1pfU291cmNlTWFwLlNvdXJjZU1hcENvbnN1bWVyKG9wdGlvbnMub3JpZyk7XG4gICAgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZ2VuX2xpbmUsIGdlbl9jb2wsIG9yaWdfbGluZSwgb3JpZ19jb2wsIG5hbWUpIHtcbiAgICAgICAgaWYgKG9yaWdfbWFwKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IG9yaWdfbWFwLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdfbGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdfY29sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmZvLnNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IGluZm8uc291cmNlO1xuICAgICAgICAgICAgb3JpZ19saW5lID0gaW5mby5saW5lO1xuICAgICAgICAgICAgb3JpZ19jb2wgPSBpbmZvLmNvbHVtbjtcbiAgICAgICAgICAgIG5hbWUgPSBpbmZvLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgZ2VuZXJhdGVkIDogeyBsaW5lOiBnZW5fbGluZSArIG9wdGlvbnMuZGVzdF9saW5lX2RpZmYsIGNvbHVtbjogZ2VuX2NvbCB9LFxuICAgICAgICAgICAgb3JpZ2luYWwgIDogeyBsaW5lOiBvcmlnX2xpbmUgKyBvcHRpb25zLm9yaWdfbGluZV9kaWZmLCBjb2x1bW46IG9yaWdfY29sIH0sXG4gICAgICAgICAgICBzb3VyY2UgICAgOiBzb3VyY2UsXG4gICAgICAgICAgICBuYW1lICAgICAgOiBuYW1lXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkICAgICAgICA6IGFkZCxcbiAgICAgICAgZ2V0ICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2VuZXJhdG9yIH0sXG4gICAgICAgIHRvU3RyaW5nICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGdlbmVyYXRvci50b1N0cmluZygpIH1cbiAgICB9O1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIuXG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcbiAgICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXG4gICAgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcbiAgICBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAgICBTVUNIIERBTUFHRS5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgTU9aX1RPX01FID0ge1xuICAgICAgICBUcnlTdGF0ZW1lbnQgOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Ucnkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgYm9keSAgICAgOiBmcm9tX21veihNLmJsb2NrKS5ib2R5LFxuICAgICAgICAgICAgICAgIGJjYXRjaCAgIDogZnJvbV9tb3ooTS5oYW5kbGVycyA/IE0uaGFuZGxlcnNbMF0gOiBNLmhhbmRsZXIpLFxuICAgICAgICAgICAgICAgIGJmaW5hbGx5IDogTS5maW5hbGl6ZXIgPyBuZXcgQVNUX0ZpbmFsbHkoZnJvbV9tb3ooTS5maW5hbGl6ZXIpKSA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBDYXRjaENsYXVzZSA6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NhdGNoKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBhcmduYW1lIDogZnJvbV9tb3ooTS5wYXJhbSksXG4gICAgICAgICAgICAgICAgYm9keSAgICA6IGZyb21fbW96KE0uYm9keSkuYm9keVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb24gOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgOiBNLnByb3BlcnRpZXMubWFwKGZ1bmN0aW9uKHByb3Ape1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0ga2V5LnR5cGUgPT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA6IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgICAgICA6IG15X2VuZF90b2tlbihwcm9wLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSAgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogZnJvbV9tb3oocHJvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0S2V5VmFsKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUubmFtZSA9IGZyb21fbW96KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3RTZXR0ZXIoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy52YWx1ZS5uYW1lID0gZnJvbV9tb3ooa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdEdldHRlcihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIEFTVF9TZXEuZnJvbV9hcnJheShNLmV4cHJlc3Npb25zLm1hcChmcm9tX21veikpO1xuICAgICAgICB9LFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoTS5jb21wdXRlZCA/IEFTVF9TdWIgOiBBU1RfRG90KSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IE0uY29tcHV0ZWQgPyBmcm9tX21veihNLnByb3BlcnR5KSA6IE0ucHJvcGVydHkubmFtZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZnJvbV9tb3ooTS5vYmplY3QpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgU3dpdGNoQ2FzZSA6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKE0udGVzdCA/IEFTVF9DYXNlIDogQVNUX0RlZmF1bHQpKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZnJvbV9tb3ooTS50ZXN0KSxcbiAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogTS5jb25zZXF1ZW50Lm1hcChmcm9tX21veilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBMaXRlcmFsIDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IE0udmFsdWUsIGFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgIDogbXlfZW5kX3Rva2VuKE0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIG5ldyBBU1RfTnVsbChhcmdzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9TdHJpbmcoYXJncyk7XG4gICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX051bWJlcihhcmdzKTtcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh2YWwgPyBBU1RfVHJ1ZSA6IEFTVF9GYWxzZSkoYXJncyk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9SZWdFeHAoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogRnJvbV9Nb3pfVW5hcnksXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IEZyb21fTW96X1VuYXJ5LFxuICAgICAgICBJZGVudGlmaWVyOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICB2YXIgcCA9IEZST01fTU9aX1NUQUNLW0ZST01fTU9aX1NUQUNLLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoTS5uYW1lID09IFwidGhpc1wiID8gQVNUX1RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiTGFiZWxlZFN0YXRlbWVudFwiID8gQVNUX0xhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiICYmIHAuaWQgPT09IE0gPyAocC5raW5kID09IFwiY29uc3RcIiA/IEFTVF9TeW1ib2xDb25zdCA6IEFTVF9TeW1ib2xWYXIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID8gKHAuaWQgPT09IE0gPyBBU1RfU3ltYm9sTGFtYmRhIDogQVNUX1N5bWJvbEZ1bmFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID8gKHAuaWQgPT09IE0gPyBBU1RfU3ltYm9sRGVmdW4gOiBBU1RfU3ltYm9sRnVuYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJDYXRjaENsYXVzZVwiID8gQVNUX1N5bWJvbENhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkJyZWFrU3RhdGVtZW50XCIgfHwgcC50eXBlID09IFwiQ29udGludWVTdGF0ZW1lbnRcIiA/IEFTVF9MYWJlbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBBU1RfU3ltYm9sUmVmKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICA6IE0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRnJvbV9Nb3pfVW5hcnkoTSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJwcmVmaXhcIiBpbiBNID8gTS5wcmVmaXhcbiAgICAgICAgICAgIDogTS50eXBlID09IFwiVW5hcnlFeHByZXNzaW9uXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgKHByZWZpeCA/IEFTVF9VbmFyeVByZWZpeCA6IEFTVF9VbmFyeVBvc3RmaXgpKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICBvcGVyYXRvciAgIDogTS5vcGVyYXRvcixcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLmFyZ3VtZW50KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIE1FX1RPX01PWiA9IHt9O1xuXG4gICAgbWFwKFwiTm9kZVwiLCBBU1RfTm9kZSk7XG4gICAgbWFwKFwiUHJvZ3JhbVwiLCBBU1RfVG9wbGV2ZWwsIFwiYm9keUBib2R5XCIpO1xuICAgIG1hcChcIkZ1bmN0aW9uXCIsIEFTVF9GdW5jdGlvbiwgXCJpZD5uYW1lLCBwYXJhbXNAYXJnbmFtZXMsIGJvZHklYm9keVwiKTtcbiAgICBtYXAoXCJFbXB0eVN0YXRlbWVudFwiLCBBU1RfRW1wdHlTdGF0ZW1lbnQpO1xuICAgIG1hcChcIkJsb2NrU3RhdGVtZW50XCIsIEFTVF9CbG9ja1N0YXRlbWVudCwgXCJib2R5QGJvZHlcIik7XG4gICAgbWFwKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCBBU1RfU2ltcGxlU3RhdGVtZW50LCBcImV4cHJlc3Npb24+Ym9keVwiKTtcbiAgICBtYXAoXCJJZlN0YXRlbWVudFwiLCBBU1RfSWYsIFwidGVzdD5jb25kaXRpb24sIGNvbnNlcXVlbnQ+Ym9keSwgYWx0ZXJuYXRlPmFsdGVybmF0aXZlXCIpO1xuICAgIG1hcChcIkxhYmVsZWRTdGF0ZW1lbnRcIiwgQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIFwibGFiZWw+bGFiZWwsIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJCcmVha1N0YXRlbWVudFwiLCBBU1RfQnJlYWssIFwibGFiZWw+bGFiZWxcIik7XG4gICAgbWFwKFwiQ29udGludWVTdGF0ZW1lbnRcIiwgQVNUX0NvbnRpbnVlLCBcImxhYmVsPmxhYmVsXCIpO1xuICAgIG1hcChcIldpdGhTdGF0ZW1lbnRcIiwgQVNUX1dpdGgsIFwib2JqZWN0PmV4cHJlc3Npb24sIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJTd2l0Y2hTdGF0ZW1lbnRcIiwgQVNUX1N3aXRjaCwgXCJkaXNjcmltaW5hbnQ+ZXhwcmVzc2lvbiwgY2FzZXNAYm9keVwiKTtcbiAgICBtYXAoXCJSZXR1cm5TdGF0ZW1lbnRcIiwgQVNUX1JldHVybiwgXCJhcmd1bWVudD52YWx1ZVwiKTtcbiAgICBtYXAoXCJUaHJvd1N0YXRlbWVudFwiLCBBU1RfVGhyb3csIFwiYXJndW1lbnQ+dmFsdWVcIik7XG4gICAgbWFwKFwiV2hpbGVTdGF0ZW1lbnRcIiwgQVNUX1doaWxlLCBcInRlc3Q+Y29uZGl0aW9uLCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRG9XaGlsZVN0YXRlbWVudFwiLCBBU1RfRG8sIFwidGVzdD5jb25kaXRpb24sIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJGb3JTdGF0ZW1lbnRcIiwgQVNUX0ZvciwgXCJpbml0PmluaXQsIHRlc3Q+Y29uZGl0aW9uLCB1cGRhdGU+c3RlcCwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkZvckluU3RhdGVtZW50XCIsIEFTVF9Gb3JJbiwgXCJsZWZ0PmluaXQsIHJpZ2h0Pm9iamVjdCwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIEFTVF9EZWJ1Z2dlcik7XG4gICAgbWFwKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBBU1RfRGVmdW4sIFwiaWQ+bmFtZSwgcGFyYW1zQGFyZ25hbWVzLCBib2R5JWJvZHlcIik7XG4gICAgbWFwKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBBU1RfVmFyLCBcImRlY2xhcmF0aW9uc0BkZWZpbml0aW9uc1wiKTtcbiAgICBtYXAoXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwgQVNUX1ZhckRlZiwgXCJpZD5uYW1lLCBpbml0PnZhbHVlXCIpO1xuXG4gICAgbWFwKFwiVGhpc0V4cHJlc3Npb25cIiwgQVNUX1RoaXMpO1xuICAgIG1hcChcIkFycmF5RXhwcmVzc2lvblwiLCBBU1RfQXJyYXksIFwiZWxlbWVudHNAZWxlbWVudHNcIik7XG4gICAgbWFwKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIEFTVF9GdW5jdGlvbiwgXCJpZD5uYW1lLCBwYXJhbXNAYXJnbmFtZXMsIGJvZHklYm9keVwiKTtcbiAgICBtYXAoXCJCaW5hcnlFeHByZXNzaW9uXCIsIEFTVF9CaW5hcnksIFwib3BlcmF0b3I9b3BlcmF0b3IsIGxlZnQ+bGVmdCwgcmlnaHQ+cmlnaHRcIik7XG4gICAgbWFwKFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgQVNUX0Fzc2lnbiwgXCJvcGVyYXRvcj1vcGVyYXRvciwgbGVmdD5sZWZ0LCByaWdodD5yaWdodFwiKTtcbiAgICBtYXAoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCBBU1RfQmluYXJ5LCBcIm9wZXJhdG9yPW9wZXJhdG9yLCBsZWZ0PmxlZnQsIHJpZ2h0PnJpZ2h0XCIpO1xuICAgIG1hcChcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCBBU1RfQ29uZGl0aW9uYWwsIFwidGVzdD5jb25kaXRpb24sIGNvbnNlcXVlbnQ+Y29uc2VxdWVudCwgYWx0ZXJuYXRlPmFsdGVybmF0aXZlXCIpO1xuICAgIG1hcChcIk5ld0V4cHJlc3Npb25cIiwgQVNUX05ldywgXCJjYWxsZWU+ZXhwcmVzc2lvbiwgYXJndW1lbnRzQGFyZ3NcIik7XG4gICAgbWFwKFwiQ2FsbEV4cHJlc3Npb25cIiwgQVNUX0NhbGwsIFwiY2FsbGVlPmV4cHJlc3Npb24sIGFyZ3VtZW50c0BhcmdzXCIpO1xuXG4gICAgLyogLS0tLS1bIHRvb2xzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gbXlfc3RhcnRfdG9rZW4obW96bm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Ub2tlbih7XG4gICAgICAgICAgICBmaWxlICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5zb3VyY2UsXG4gICAgICAgICAgICBsaW5lICAgOiBtb3pub2RlLmxvYyAmJiBtb3pub2RlLmxvYy5zdGFydC5saW5lLFxuICAgICAgICAgICAgY29sICAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2Muc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgcG9zICAgIDogbW96bm9kZS5zdGFydCxcbiAgICAgICAgICAgIGVuZHBvcyA6IG1vem5vZGUuc3RhcnRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG15X2VuZF90b2tlbihtb3pub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Rva2VuKHtcbiAgICAgICAgICAgIGZpbGUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLnNvdXJjZSxcbiAgICAgICAgICAgIGxpbmUgICA6IG1vem5vZGUubG9jICYmIG1vem5vZGUubG9jLmVuZC5saW5lLFxuICAgICAgICAgICAgY29sICAgIDogbW96bm9kZS5sb2MgJiYgbW96bm9kZS5sb2MuZW5kLmNvbHVtbixcbiAgICAgICAgICAgIHBvcyAgICA6IG1vem5vZGUuZW5kLFxuICAgICAgICAgICAgZW5kcG9zIDogbW96bm9kZS5lbmRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1hcChtb3p0eXBlLCBteXR5cGUsIHByb3BtYXApIHtcbiAgICAgICAgdmFyIG1vel90b19tZSA9IFwiZnVuY3Rpb24gRnJvbV9Nb3pfXCIgKyBtb3p0eXBlICsgXCIoTSl7XFxuXCI7XG4gICAgICAgIG1vel90b19tZSArPSBcInJldHVybiBuZXcgbXl0eXBlKHtcXG5cIiArXG4gICAgICAgICAgICBcInN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcXG5cIiArXG4gICAgICAgICAgICBcImVuZDogbXlfZW5kX3Rva2VuKE0pXCI7XG5cbiAgICAgICAgaWYgKHByb3BtYXApIHByb3BtYXAuc3BsaXQoL1xccyosXFxzKi8pLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICB2YXIgbSA9IC8oW2EtejAtOSRfXSspKD18QHw+fCUpKFthLXowLTkkX10rKS9pLmV4ZWMocHJvcCk7XG4gICAgICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVuZGVyc3RhbmQgcHJvcGVydHkgbWFwOiBcIiArIHByb3ApO1xuICAgICAgICAgICAgdmFyIG1veiA9IFwiTS5cIiArIG1bMV0sIGhvdyA9IG1bMl0sIG15ID0gbVszXTtcbiAgICAgICAgICAgIG1vel90b19tZSArPSBcIixcXG5cIiArIG15ICsgXCI6IFwiO1xuICAgICAgICAgICAgaWYgKGhvdyA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBtb3ogKyBcIi5tYXAoZnJvbV9tb3opXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdyA9PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBcImZyb21fbW96KFwiICsgbW96ICsgXCIpXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdyA9PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBtb3o7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdyA9PSBcIiVcIikge1xuICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBcImZyb21fbW96KFwiICsgbW96ICsgXCIpLmJvZHlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1bmRlcnN0YW5kIG9wZXJhdG9yIGluIHByb3BtYXA6IFwiICsgcHJvcCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb3pfdG9fbWUgKz0gXCJcXG59KX1cIjtcblxuICAgICAgICAvLyBtb3pfdG9fbWUgPSBwYXJzZShtb3pfdG9fbWUpLnByaW50X3RvX3N0cmluZyh7IGJlYXV0aWZ5OiB0cnVlIH0pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhtb3pfdG9fbWUpO1xuXG4gICAgICAgIG1vel90b19tZSA9IG5ldyBGdW5jdGlvbihcIm15dHlwZVwiLCBcIm15X3N0YXJ0X3Rva2VuXCIsIFwibXlfZW5kX3Rva2VuXCIsIFwiZnJvbV9tb3pcIiwgXCJyZXR1cm4oXCIgKyBtb3pfdG9fbWUgKyBcIilcIikoXG4gICAgICAgICAgICBteXR5cGUsIG15X3N0YXJ0X3Rva2VuLCBteV9lbmRfdG9rZW4sIGZyb21fbW96XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBNT1pfVE9fTUVbbW96dHlwZV0gPSBtb3pfdG9fbWU7XG4gICAgfTtcblxuICAgIHZhciBGUk9NX01PWl9TVEFDSyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBmcm9tX21veihub2RlKSB7XG4gICAgICAgIEZST01fTU9aX1NUQUNLLnB1c2gobm9kZSk7XG4gICAgICAgIHZhciByZXQgPSBub2RlICE9IG51bGwgPyBNT1pfVE9fTUVbbm9kZS50eXBlXShub2RlKSA6IG51bGw7XG4gICAgICAgIEZST01fTU9aX1NUQUNLLnBvcCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBBU1RfTm9kZS5mcm9tX21vemlsbGFfYXN0ID0gZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIHZhciBzYXZlX3N0YWNrID0gRlJPTV9NT1pfU1RBQ0s7XG4gICAgICAgIEZST01fTU9aX1NUQUNLID0gW107XG4gICAgICAgIHZhciBhc3QgPSBmcm9tX21veihub2RlKTtcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sgPSBzYXZlX3N0YWNrO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG5cbn0pKCk7XG5cblxuZXhwb3J0cy5zeXMgPSBzeXM7XG5leHBvcnRzLk1PWl9Tb3VyY2VNYXAgPSBNT1pfU291cmNlTWFwO1xuZXhwb3J0cy5VZ2xpZnlKUyA9IFVnbGlmeUpTO1xuZXhwb3J0cy5hcnJheV90b19oYXNoID0gYXJyYXlfdG9faGFzaDtcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMuY2hhcmFjdGVycyA9IGNoYXJhY3RlcnM7XG5leHBvcnRzLm1lbWJlciA9IG1lbWJlcjtcbmV4cG9ydHMuZmluZF9pZiA9IGZpbmRfaWY7XG5leHBvcnRzLnJlcGVhdF9zdHJpbmcgPSByZXBlYXRfc3RyaW5nO1xuZXhwb3J0cy5EZWZhdWx0c0Vycm9yID0gRGVmYXVsdHNFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5leHBvcnRzLk1BUCA9IE1BUDtcbmV4cG9ydHMucHVzaF91bmlxID0gcHVzaF91bmlxO1xuZXhwb3J0cy5zdHJpbmdfdGVtcGxhdGUgPSBzdHJpbmdfdGVtcGxhdGU7XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbmV4cG9ydHMubWVyZ2VTb3J0ID0gbWVyZ2VTb3J0O1xuZXhwb3J0cy5zZXRfZGlmZmVyZW5jZSA9IHNldF9kaWZmZXJlbmNlO1xuZXhwb3J0cy5zZXRfaW50ZXJzZWN0aW9uID0gc2V0X2ludGVyc2VjdGlvbjtcbmV4cG9ydHMubWFrZVByZWRpY2F0ZSA9IG1ha2VQcmVkaWNhdGU7XG5leHBvcnRzLmFsbCA9IGFsbDtcbmV4cG9ydHMuRGljdGlvbmFyeSA9IERpY3Rpb25hcnk7XG5leHBvcnRzLkRFRk5PREUgPSBERUZOT0RFO1xuZXhwb3J0cy5BU1RfVG9rZW4gPSBBU1RfVG9rZW47XG5leHBvcnRzLkFTVF9Ob2RlID0gQVNUX05vZGU7XG5leHBvcnRzLkFTVF9TdGF0ZW1lbnQgPSBBU1RfU3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfRGVidWdnZXIgPSBBU1RfRGVidWdnZXI7XG5leHBvcnRzLkFTVF9EaXJlY3RpdmUgPSBBU1RfRGlyZWN0aXZlO1xuZXhwb3J0cy5BU1RfU2ltcGxlU3RhdGVtZW50ID0gQVNUX1NpbXBsZVN0YXRlbWVudDtcbmV4cG9ydHMud2Fsa19ib2R5ID0gd2Fsa19ib2R5O1xuZXhwb3J0cy5BU1RfQmxvY2sgPSBBU1RfQmxvY2s7XG5leHBvcnRzLkFTVF9CbG9ja1N0YXRlbWVudCA9IEFTVF9CbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuQVNUX0VtcHR5U3RhdGVtZW50ID0gQVNUX0VtcHR5U3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfU3RhdGVtZW50V2l0aEJvZHkgPSBBU1RfU3RhdGVtZW50V2l0aEJvZHk7XG5leHBvcnRzLkFTVF9MYWJlbGVkU3RhdGVtZW50ID0gQVNUX0xhYmVsZWRTdGF0ZW1lbnQ7XG5leHBvcnRzLkFTVF9JdGVyYXRpb25TdGF0ZW1lbnQgPSBBU1RfSXRlcmF0aW9uU3RhdGVtZW50O1xuZXhwb3J0cy5BU1RfRFdMb29wID0gQVNUX0RXTG9vcDtcbmV4cG9ydHMuQVNUX0RvID0gQVNUX0RvO1xuZXhwb3J0cy5BU1RfV2hpbGUgPSBBU1RfV2hpbGU7XG5leHBvcnRzLkFTVF9Gb3IgPSBBU1RfRm9yO1xuZXhwb3J0cy5BU1RfRm9ySW4gPSBBU1RfRm9ySW47XG5leHBvcnRzLkFTVF9XaXRoID0gQVNUX1dpdGg7XG5leHBvcnRzLkFTVF9TY29wZSA9IEFTVF9TY29wZTtcbmV4cG9ydHMuQVNUX1RvcGxldmVsID0gQVNUX1RvcGxldmVsO1xuZXhwb3J0cy5BU1RfTGFtYmRhID0gQVNUX0xhbWJkYTtcbmV4cG9ydHMuQVNUX0FjY2Vzc29yID0gQVNUX0FjY2Vzc29yO1xuZXhwb3J0cy5BU1RfRnVuY3Rpb24gPSBBU1RfRnVuY3Rpb247XG5leHBvcnRzLkFTVF9EZWZ1biA9IEFTVF9EZWZ1bjtcbmV4cG9ydHMuQVNUX0p1bXAgPSBBU1RfSnVtcDtcbmV4cG9ydHMuQVNUX0V4aXQgPSBBU1RfRXhpdDtcbmV4cG9ydHMuQVNUX1JldHVybiA9IEFTVF9SZXR1cm47XG5leHBvcnRzLkFTVF9UaHJvdyA9IEFTVF9UaHJvdztcbmV4cG9ydHMuQVNUX0xvb3BDb250cm9sID0gQVNUX0xvb3BDb250cm9sO1xuZXhwb3J0cy5BU1RfQnJlYWsgPSBBU1RfQnJlYWs7XG5leHBvcnRzLkFTVF9Db250aW51ZSA9IEFTVF9Db250aW51ZTtcbmV4cG9ydHMuQVNUX0lmID0gQVNUX0lmO1xuZXhwb3J0cy5BU1RfU3dpdGNoID0gQVNUX1N3aXRjaDtcbmV4cG9ydHMuQVNUX1N3aXRjaEJyYW5jaCA9IEFTVF9Td2l0Y2hCcmFuY2g7XG5leHBvcnRzLkFTVF9EZWZhdWx0ID0gQVNUX0RlZmF1bHQ7XG5leHBvcnRzLkFTVF9DYXNlID0gQVNUX0Nhc2U7XG5leHBvcnRzLkFTVF9UcnkgPSBBU1RfVHJ5O1xuZXhwb3J0cy5BU1RfQ2F0Y2ggPSBBU1RfQ2F0Y2g7XG5leHBvcnRzLkFTVF9GaW5hbGx5ID0gQVNUX0ZpbmFsbHk7XG5leHBvcnRzLkFTVF9EZWZpbml0aW9ucyA9IEFTVF9EZWZpbml0aW9ucztcbmV4cG9ydHMuQVNUX1ZhciA9IEFTVF9WYXI7XG5leHBvcnRzLkFTVF9Db25zdCA9IEFTVF9Db25zdDtcbmV4cG9ydHMuQVNUX1ZhckRlZiA9IEFTVF9WYXJEZWY7XG5leHBvcnRzLkFTVF9DYWxsID0gQVNUX0NhbGw7XG5leHBvcnRzLkFTVF9OZXcgPSBBU1RfTmV3O1xuZXhwb3J0cy5BU1RfU2VxID0gQVNUX1NlcTtcbmV4cG9ydHMuQVNUX1Byb3BBY2Nlc3MgPSBBU1RfUHJvcEFjY2VzcztcbmV4cG9ydHMuQVNUX0RvdCA9IEFTVF9Eb3Q7XG5leHBvcnRzLkFTVF9TdWIgPSBBU1RfU3ViO1xuZXhwb3J0cy5BU1RfVW5hcnkgPSBBU1RfVW5hcnk7XG5leHBvcnRzLkFTVF9VbmFyeVByZWZpeCA9IEFTVF9VbmFyeVByZWZpeDtcbmV4cG9ydHMuQVNUX1VuYXJ5UG9zdGZpeCA9IEFTVF9VbmFyeVBvc3RmaXg7XG5leHBvcnRzLkFTVF9CaW5hcnkgPSBBU1RfQmluYXJ5O1xuZXhwb3J0cy5BU1RfQ29uZGl0aW9uYWwgPSBBU1RfQ29uZGl0aW9uYWw7XG5leHBvcnRzLkFTVF9Bc3NpZ24gPSBBU1RfQXNzaWduO1xuZXhwb3J0cy5BU1RfQXJyYXkgPSBBU1RfQXJyYXk7XG5leHBvcnRzLkFTVF9PYmplY3QgPSBBU1RfT2JqZWN0O1xuZXhwb3J0cy5BU1RfT2JqZWN0UHJvcGVydHkgPSBBU1RfT2JqZWN0UHJvcGVydHk7XG5leHBvcnRzLkFTVF9PYmplY3RLZXlWYWwgPSBBU1RfT2JqZWN0S2V5VmFsO1xuZXhwb3J0cy5BU1RfT2JqZWN0U2V0dGVyID0gQVNUX09iamVjdFNldHRlcjtcbmV4cG9ydHMuQVNUX09iamVjdEdldHRlciA9IEFTVF9PYmplY3RHZXR0ZXI7XG5leHBvcnRzLkFTVF9TeW1ib2wgPSBBU1RfU3ltYm9sO1xuZXhwb3J0cy5BU1RfU3ltYm9sQWNjZXNzb3IgPSBBU1RfU3ltYm9sQWNjZXNzb3I7XG5leHBvcnRzLkFTVF9TeW1ib2xEZWNsYXJhdGlvbiA9IEFTVF9TeW1ib2xEZWNsYXJhdGlvbjtcbmV4cG9ydHMuQVNUX1N5bWJvbFZhciA9IEFTVF9TeW1ib2xWYXI7XG5leHBvcnRzLkFTVF9TeW1ib2xDb25zdCA9IEFTVF9TeW1ib2xDb25zdDtcbmV4cG9ydHMuQVNUX1N5bWJvbEZ1bmFyZyA9IEFTVF9TeW1ib2xGdW5hcmc7XG5leHBvcnRzLkFTVF9TeW1ib2xEZWZ1biA9IEFTVF9TeW1ib2xEZWZ1bjtcbmV4cG9ydHMuQVNUX1N5bWJvbExhbWJkYSA9IEFTVF9TeW1ib2xMYW1iZGE7XG5leHBvcnRzLkFTVF9TeW1ib2xDYXRjaCA9IEFTVF9TeW1ib2xDYXRjaDtcbmV4cG9ydHMuQVNUX0xhYmVsID0gQVNUX0xhYmVsO1xuZXhwb3J0cy5BU1RfU3ltYm9sUmVmID0gQVNUX1N5bWJvbFJlZjtcbmV4cG9ydHMuQVNUX0xhYmVsUmVmID0gQVNUX0xhYmVsUmVmO1xuZXhwb3J0cy5BU1RfVGhpcyA9IEFTVF9UaGlzO1xuZXhwb3J0cy5BU1RfQ29uc3RhbnQgPSBBU1RfQ29uc3RhbnQ7XG5leHBvcnRzLkFTVF9TdHJpbmcgPSBBU1RfU3RyaW5nO1xuZXhwb3J0cy5BU1RfTnVtYmVyID0gQVNUX051bWJlcjtcbmV4cG9ydHMuQVNUX1JlZ0V4cCA9IEFTVF9SZWdFeHA7XG5leHBvcnRzLkFTVF9BdG9tID0gQVNUX0F0b207XG5leHBvcnRzLkFTVF9OdWxsID0gQVNUX051bGw7XG5leHBvcnRzLkFTVF9OYU4gPSBBU1RfTmFOO1xuZXhwb3J0cy5BU1RfVW5kZWZpbmVkID0gQVNUX1VuZGVmaW5lZDtcbmV4cG9ydHMuQVNUX0hvbGUgPSBBU1RfSG9sZTtcbmV4cG9ydHMuQVNUX0luZmluaXR5ID0gQVNUX0luZmluaXR5O1xuZXhwb3J0cy5BU1RfQm9vbGVhbiA9IEFTVF9Cb29sZWFuO1xuZXhwb3J0cy5BU1RfRmFsc2UgPSBBU1RfRmFsc2U7XG5leHBvcnRzLkFTVF9UcnVlID0gQVNUX1RydWU7XG5leHBvcnRzLlRyZWVXYWxrZXIgPSBUcmVlV2Fsa2VyO1xuZXhwb3J0cy5LRVlXT1JEUyA9IEtFWVdPUkRTO1xuZXhwb3J0cy5LRVlXT1JEU19BVE9NID0gS0VZV09SRFNfQVRPTTtcbmV4cG9ydHMuUkVTRVJWRURfV09SRFMgPSBSRVNFUlZFRF9XT1JEUztcbmV4cG9ydHMuS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04gPSBLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTjtcbmV4cG9ydHMuT1BFUkFUT1JfQ0hBUlMgPSBPUEVSQVRPUl9DSEFSUztcbmV4cG9ydHMuUkVfSEVYX05VTUJFUiA9IFJFX0hFWF9OVU1CRVI7XG5leHBvcnRzLlJFX09DVF9OVU1CRVIgPSBSRV9PQ1RfTlVNQkVSO1xuZXhwb3J0cy5SRV9ERUNfTlVNQkVSID0gUkVfREVDX05VTUJFUjtcbmV4cG9ydHMuT1BFUkFUT1JTID0gT1BFUkFUT1JTO1xuZXhwb3J0cy5XSElURVNQQUNFX0NIQVJTID0gV0hJVEVTUEFDRV9DSEFSUztcbmV4cG9ydHMuUFVOQ19CRUZPUkVfRVhQUkVTU0lPTiA9IFBVTkNfQkVGT1JFX0VYUFJFU1NJT047XG5leHBvcnRzLlBVTkNfQ0hBUlMgPSBQVU5DX0NIQVJTO1xuZXhwb3J0cy5SRUdFWFBfTU9ESUZJRVJTID0gUkVHRVhQX01PRElGSUVSUztcbmV4cG9ydHMuVU5JQ09ERSA9IFVOSUNPREU7XG5leHBvcnRzLmlzX2xldHRlciA9IGlzX2xldHRlcjtcbmV4cG9ydHMuaXNfZGlnaXQgPSBpc19kaWdpdDtcbmV4cG9ydHMuaXNfYWxwaGFudW1lcmljX2NoYXIgPSBpc19hbHBoYW51bWVyaWNfY2hhcjtcbmV4cG9ydHMuaXNfdW5pY29kZV9jb21iaW5pbmdfbWFyayA9IGlzX3VuaWNvZGVfY29tYmluaW5nX21hcms7XG5leHBvcnRzLmlzX3VuaWNvZGVfY29ubmVjdG9yX3B1bmN0dWF0aW9uID0gaXNfdW5pY29kZV9jb25uZWN0b3JfcHVuY3R1YXRpb247XG5leHBvcnRzLmlzX2lkZW50aWZpZXIgPSBpc19pZGVudGlmaWVyO1xuZXhwb3J0cy5pc19pZGVudGlmaWVyX3N0YXJ0ID0gaXNfaWRlbnRpZmllcl9zdGFydDtcbmV4cG9ydHMuaXNfaWRlbnRpZmllcl9jaGFyID0gaXNfaWRlbnRpZmllcl9jaGFyO1xuZXhwb3J0cy5pc19pZGVudGlmaWVyX3N0cmluZyA9IGlzX2lkZW50aWZpZXJfc3RyaW5nO1xuZXhwb3J0cy5wYXJzZV9qc19udW1iZXIgPSBwYXJzZV9qc19udW1iZXI7XG5leHBvcnRzLkpTX1BhcnNlX0Vycm9yID0gSlNfUGFyc2VfRXJyb3I7XG5leHBvcnRzLmpzX2Vycm9yID0ganNfZXJyb3I7XG5leHBvcnRzLmlzX3Rva2VuID0gaXNfdG9rZW47XG5leHBvcnRzLkVYX0VPRiA9IEVYX0VPRjtcbmV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuZXhwb3J0cy5VTkFSWV9QUkVGSVggPSBVTkFSWV9QUkVGSVg7XG5leHBvcnRzLlVOQVJZX1BPU1RGSVggPSBVTkFSWV9QT1NURklYO1xuZXhwb3J0cy5BU1NJR05NRU5UID0gQVNTSUdOTUVOVDtcbmV4cG9ydHMuUFJFQ0VERU5DRSA9IFBSRUNFREVOQ0U7XG5leHBvcnRzLlNUQVRFTUVOVFNfV0lUSF9MQUJFTFMgPSBTVEFURU1FTlRTX1dJVEhfTEFCRUxTO1xuZXhwb3J0cy5BVE9NSUNfU1RBUlRfVE9LRU4gPSBBVE9NSUNfU1RBUlRfVE9LRU47XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLlRyZWVUcmFuc2Zvcm1lciA9IFRyZWVUcmFuc2Zvcm1lcjtcbmV4cG9ydHMuU3ltYm9sRGVmID0gU3ltYm9sRGVmO1xuZXhwb3J0cy5iYXNlNTQgPSBiYXNlNTQ7XG5leHBvcnRzLk91dHB1dFN0cmVhbSA9IE91dHB1dFN0cmVhbTtcbmV4cG9ydHMuQ29tcHJlc3NvciA9IENvbXByZXNzb3I7XG5leHBvcnRzLlNvdXJjZU1hcCA9IFNvdXJjZU1hcDtcblxuZXhwb3J0cy5BU1RfTm9kZS53YXJuX2Z1bmN0aW9uID0gZnVuY3Rpb24gKHR4dCkgeyBpZiAodHlwZW9mIGNvbnNvbGUgIT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIGNvbnNvbGUud2Fybih0eHQpIH1cblxuZXhwb3J0cy5taW5pZnkgPSBmdW5jdGlvbiAoZmlsZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVWdsaWZ5SlMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBzcGlkZXJtb25rZXkgOiBmYWxzZSxcbiAgICAgICAgb3V0U291cmNlTWFwIDogbnVsbCxcbiAgICAgICAgc291cmNlUm9vdCAgIDogbnVsbCxcbiAgICAgICAgaW5Tb3VyY2VNYXAgIDogbnVsbCxcbiAgICAgICAgZnJvbVN0cmluZyAgIDogZmFsc2UsXG4gICAgICAgIHdhcm5pbmdzICAgICA6IGZhbHNlLFxuICAgICAgICBtYW5nbGUgICAgICAgOiB7fSxcbiAgICAgICAgb3V0cHV0ICAgICAgIDogbnVsbCxcbiAgICAgICAgY29tcHJlc3MgICAgIDoge31cbiAgICB9KTtcbiAgICBVZ2xpZnlKUy5iYXNlNTQucmVzZXQoKTtcblxuICAgIC8vIDEuIHBhcnNlXG4gICAgdmFyIHRvcGxldmVsID0gbnVsbCxcbiAgICAgICAgc291cmNlc0NvbnRlbnQgPSB7fTtcblxuICAgIGlmIChvcHRpb25zLnNwaWRlcm1vbmtleSkge1xuICAgICAgICB0b3BsZXZlbCA9IFVnbGlmeUpTLkFTVF9Ob2RlLmZyb21fbW96aWxsYV9hc3QoZmlsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZXMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZpbGVzID0gWyBmaWxlcyBdO1xuICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBvcHRpb25zLmZyb21TdHJpbmdcbiAgICAgICAgICAgICAgICA/IGZpbGVcbiAgICAgICAgICAgICAgICA6IGZzLnJlYWRGaWxlU3luYyhmaWxlLCBcInV0ZjhcIik7XG4gICAgICAgICAgICBzb3VyY2VzQ29udGVudFtmaWxlXSA9IGNvZGU7XG4gICAgICAgICAgICB0b3BsZXZlbCA9IFVnbGlmeUpTLnBhcnNlKGNvZGUsIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogb3B0aW9ucy5mcm9tU3RyaW5nID8gXCI/XCIgOiBmaWxlLFxuICAgICAgICAgICAgICAgIHRvcGxldmVsOiB0b3BsZXZlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIDIuIGNvbXByZXNzXG4gICAgaWYgKG9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzID0geyB3YXJuaW5nczogb3B0aW9ucy53YXJuaW5ncyB9O1xuICAgICAgICBVZ2xpZnlKUy5tZXJnZShjb21wcmVzcywgb3B0aW9ucy5jb21wcmVzcyk7XG4gICAgICAgIHRvcGxldmVsLmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgdmFyIHNxID0gVWdsaWZ5SlMuQ29tcHJlc3Nvcihjb21wcmVzcyk7XG4gICAgICAgIHRvcGxldmVsID0gdG9wbGV2ZWwudHJhbnNmb3JtKHNxKTtcbiAgICB9XG5cbiAgICAvLyAzLiBtYW5nbGVcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgdG9wbGV2ZWwuZmlndXJlX291dF9zY29wZSgpO1xuICAgICAgICB0b3BsZXZlbC5jb21wdXRlX2NoYXJfZnJlcXVlbmN5KCk7XG4gICAgICAgIHRvcGxldmVsLm1hbmdsZV9uYW1lcyhvcHRpb25zLm1hbmdsZSk7XG4gICAgfVxuXG4gICAgLy8gNC4gb3V0cHV0XG4gICAgdmFyIGluTWFwID0gb3B0aW9ucy5pblNvdXJjZU1hcDtcbiAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluU291cmNlTWFwID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaW5NYXAgPSBmcy5yZWFkRmlsZVN5bmMob3B0aW9ucy5pblNvdXJjZU1hcCwgXCJ1dGY4XCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vdXRTb3VyY2VNYXApIHtcbiAgICAgICAgb3V0cHV0LnNvdXJjZV9tYXAgPSBVZ2xpZnlKUy5Tb3VyY2VNYXAoe1xuICAgICAgICAgICAgZmlsZTogb3B0aW9ucy5vdXRTb3VyY2VNYXAsXG4gICAgICAgICAgICBvcmlnOiBpbk1hcCxcbiAgICAgICAgICAgIHJvb3Q6IG9wdGlvbnMuc291cmNlUm9vdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwSW5jbHVkZVNvdXJjZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGZpbGUgaW4gc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlc0NvbnRlbnQuaGFzT3duUHJvcGVydHkoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNvdXJjZV9tYXAuZ2V0KCkuc2V0U291cmNlQ29udGVudChmaWxlLCBzb3VyY2VzQ29udGVudFtmaWxlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgICAgIFVnbGlmeUpTLm1lcmdlKG91dHB1dCwgb3B0aW9ucy5vdXRwdXQpO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtID0gVWdsaWZ5SlMuT3V0cHV0U3RyZWFtKG91dHB1dCk7XG4gICAgdG9wbGV2ZWwucHJpbnQoc3RyZWFtKTtcblxuICAgIGlmKG9wdGlvbnMub3V0U291cmNlTWFwKXtcbiAgICAgICAgc3RyZWFtICs9IFwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9XCIgKyBvcHRpb25zLm91dFNvdXJjZU1hcDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlIDogc3RyZWFtICsgXCJcIixcbiAgICAgICAgbWFwICA6IG91dHB1dC5zb3VyY2VfbWFwICsgXCJcIlxuICAgIH07XG59O1xuXG5leHBvcnRzLmRlc2NyaWJlX2FzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gVWdsaWZ5SlMuT3V0cHV0U3RyZWFtKHsgYmVhdXRpZnk6IHRydWUgfSk7XG4gICAgZnVuY3Rpb24gZG9pdGVtKGN0b3IpIHtcbiAgICAgICAgb3V0LnByaW50KFwiQVNUX1wiICsgY3Rvci5UWVBFKTtcbiAgICAgICAgdmFyIHByb3BzID0gY3Rvci5TRUxGX1BST1BTLmZpbHRlcihmdW5jdGlvbihwcm9wKXtcbiAgICAgICAgICAgIHJldHVybiAhL15cXCQvLnRlc3QocHJvcCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3AsIGkpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSkgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wcmludChwcm9wKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdG9yLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0LnByaW50X3N0cmluZyhjdG9yLmRvY3VtZW50YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdG9yLlNVQkNMQVNTRVMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICBvdXQud2l0aF9ibG9jayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGN0b3IuU1VCQ0xBU1NFUy5mb3JFYWNoKGZ1bmN0aW9uKGN0b3IsIGkpe1xuICAgICAgICAgICAgICAgICAgICBvdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGRvaXRlbShjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkb2l0ZW0oVWdsaWZ5SlMuQVNUX05vZGUpO1xuICAgIHJldHVybiBvdXQgKyBcIlwiO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyogQkFTSUNTICovXFxuXFxuLkNvZGVNaXJyb3Ige1xcbiAgLyogU2V0IGhlaWdodCwgd2lkdGgsIGJvcmRlcnMsIGFuZCBnbG9iYWwgZm9udCBwcm9wZXJ0aWVzIGhlcmUgKi9cXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBoZWlnaHQ6IDMwMHB4O1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zY3JvbGwge1xcbiAgLyogU2V0IHNjcm9sbGluZyBiZWhhdmlvdXIgaGVyZSAqL1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi8qIFBBRERJTkcgKi9cXG5cXG4uQ29kZU1pcnJvci1saW5lcyB7XFxuICBwYWRkaW5nOiA0cHggMDtcXG4gIC8qIFZlcnRpY2FsIHBhZGRpbmcgYXJvdW5kIGNvbnRlbnQgKi9cXG59XFxuXFxuLkNvZGVNaXJyb3IgcHJlIHtcXG4gIHBhZGRpbmc6IDAgNHB4O1xcbiAgLyogSG9yaXpvbnRhbCBwYWRkaW5nIG9mIGNvbnRlbnQgKi9cXG59XFxuXFxuLkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlcixcXG4uQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgLyogVGhlIGxpdHRsZSBzcXVhcmUgYmV0d2VlbiBIIGFuZCBWIHNjcm9sbGJhcnMgKi9cXG59XFxuXFxuLyogR1VUVEVSICovXFxuXFxuLkNvZGVNaXJyb3ItZ3V0dGVycyB7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZGRkO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcblxcblxcbi5Db2RlTWlycm9yLWxpbmVudW1iZXIge1xcbiAgcGFkZGluZzogMCAzcHggMCA1cHg7XFxuICBtaW4td2lkdGg6IDIwcHg7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGNvbG9yOiAjOTk5O1xcbiAgLW1vei1ib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbn1cXG5cXG4uQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXIge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXItc3VidGxlIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG5cXG4vKiBDVVJTT1IgKi9cXG5cXG4uQ29kZU1pcnJvciBkaXYuQ29kZU1pcnJvci1jdXJzb3Ige1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCBibGFjaztcXG59XFxuXFxuLyogU2hvd24gd2hlbiBtb3ZpbmcgaW4gYmktZGlyZWN0aW9uYWwgdGV4dCAqL1xcblxcbi5Db2RlTWlycm9yIGRpdi5Db2RlTWlycm9yLXNlY29uZGFyeWN1cnNvciB7XFxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkIHNpbHZlcjtcXG59XFxuXFxuLkNvZGVNaXJyb3IuY20ta2V5bWFwLWZhdC1jdXJzb3IgZGl2LkNvZGVNaXJyb3ItY3Vyc29yIHtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgYm9yZGVyOiAwO1xcbiAgYmFja2dyb3VuZDogIzdlNztcXG59XFxuXFxuLmNtLWFuaW1hdGUtZmF0LWN1cnNvciB7XFxuICB3aWR0aDogYXV0bztcXG4gIGJvcmRlcjogMDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBibGluayAxLjA2cyBzdGVwcygxKSBpbmZpbml0ZTtcXG4gIC1tb3otYW5pbWF0aW9uOiBibGluayAxLjA2cyBzdGVwcygxKSBpbmZpbml0ZTtcXG4gIGFuaW1hdGlvbjogYmxpbmsgMS4wNnMgc3RlcHMoMSkgaW5maW5pdGU7XFxufVxcblxcbkAtbW96LWtleWZyYW1lcyBibGluayB7XFxuICAwJSB7XFxuICAgIGJhY2tncm91bmQ6ICM3ZTc7XFxuICB9XFxuXFxuICA1MCUge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgfVxcblxcbiAgMTAwJSB7XFxuICAgIGJhY2tncm91bmQ6ICM3ZTc7XFxuICB9XFxufVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBibGluayB7XFxuICAwJSB7XFxuICAgIGJhY2tncm91bmQ6ICM3ZTc7XFxuICB9XFxuXFxuICA1MCUge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgfVxcblxcbiAgMTAwJSB7XFxuICAgIGJhY2tncm91bmQ6ICM3ZTc7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgYmxpbmsge1xcbiAgMCUge1xcbiAgICBiYWNrZ3JvdW5kOiAjN2U3O1xcbiAgfVxcblxcbiAgNTAlIHtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gIH1cXG5cXG4gIDEwMCUge1xcbiAgICBiYWNrZ3JvdW5kOiAjN2U3O1xcbiAgfVxcbn1cXG5cXG4vKiBDYW4gc3R5bGUgY3Vyc29yIGRpZmZlcmVudCBpbiBvdmVyd3JpdGUgKG5vbi1pbnNlcnQpIG1vZGUgKi9cXG5cXG5cXG5cXG4uY20tdGFiIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLkNvZGVNaXJyb3ItcnVsZXIge1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjY2NjO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4vKiBERUZBVUxUIFRIRU1FICovXFxuXFxuLmNtLXMtZGVmYXVsdCAuY20ta2V5d29yZCB7XFxuICBjb2xvcjogIzcwODtcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tYXRvbSB7XFxuICBjb2xvcjogIzIxOTtcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tbnVtYmVyIHtcXG4gIGNvbG9yOiAjMTY0O1xcbn1cXG5cXG4uY20tcy1kZWZhdWx0IC5jbS1kZWYge1xcbiAgY29sb3I6ICMwMGY7XFxufVxcblxcblxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLXZhcmlhYmxlLTIge1xcbiAgY29sb3I6ICMwNWE7XFxufVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLXZhcmlhYmxlLTMge1xcbiAgY29sb3I6ICMwODU7XFxufVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWNvbW1lbnQge1xcbiAgY29sb3I6ICNhNTA7XFxufVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLXN0cmluZyB7XFxuICBjb2xvcjogI2ExMTtcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tc3RyaW5nLTIge1xcbiAgY29sb3I6ICNmNTA7XFxufVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLW1ldGEge1xcbiAgY29sb3I6ICM1NTU7XFxufVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLXF1YWxpZmllciB7XFxuICBjb2xvcjogIzU1NTtcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tYnVpbHRpbiB7XFxuICBjb2xvcjogIzMwYTtcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tYnJhY2tldCB7XFxuICBjb2xvcjogIzk5NztcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tdGFnIHtcXG4gIGNvbG9yOiAjMTcwO1xcbn1cXG5cXG4uY20tcy1kZWZhdWx0IC5jbS1hdHRyaWJ1dGUge1xcbiAgY29sb3I6ICMwMGM7XFxufVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWhlYWRlciB7XFxuICBjb2xvcjogYmx1ZTtcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tcXVvdGUge1xcbiAgY29sb3I6ICMwOTA7XFxufVxcblxcbi5jbS1zLWRlZmF1bHQgLmNtLWhyIHtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG5cXG4uY20tcy1kZWZhdWx0IC5jbS1saW5rIHtcXG4gIGNvbG9yOiAjMDBjO1xcbn1cXG5cXG4uY20tbmVnYXRpdmUge1xcbiAgY29sb3I6ICNkNDQ7XFxufVxcblxcbi5jbS1wb3NpdGl2ZSB7XFxuICBjb2xvcjogIzI5MjtcXG59XFxuXFxuLmNtLWhlYWRlcixcXG4uY20tc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG4uY20tZW0ge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG5cXG4uY20tbGluayB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuLmNtLXMtZGVmYXVsdCAuY20tZXJyb3Ige1xcbiAgY29sb3I6ICNmMDA7XFxufVxcblxcbi5jbS1pbnZhbGlkY2hhciB7XFxuICBjb2xvcjogI2YwMDtcXG59XFxuXFxuLyogRGVmYXVsdCBzdHlsZXMgZm9yIGNvbW1vbiBhZGRvbnMgKi9cXG5cXG5kaXYuQ29kZU1pcnJvciBzcGFuLkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0IHtcXG4gIGNvbG9yOiAjMGYwO1xcbn1cXG5cXG5kaXYuQ29kZU1pcnJvciBzcGFuLkNvZGVNaXJyb3Itbm9ubWF0Y2hpbmdicmFja2V0IHtcXG4gIGNvbG9yOiAjZjIyO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1tYXRjaGluZ3RhZyB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMTUwLCAwLCAuMyk7XFxufVxcblxcbi5Db2RlTWlycm9yLWFjdGl2ZWxpbmUtYmFja2dyb3VuZCB7XFxuICBiYWNrZ3JvdW5kOiAjZThmMmZmO1xcbn1cXG5cXG4vKiBTVE9QICovXFxuXFxuLyogVGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGNvbnRhaW5zIHN0eWxlcyByZWxhdGVkIHRvIHRoZSBtZWNoYW5pY3Mgb2ZcXG4gICB0aGUgZWRpdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IHRvdWNoIHRoZW0uICovXFxuXFxuLkNvZGVNaXJyb3Ige1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbi5Db2RlTWlycm9yLXNjcm9sbCB7XFxuICAvKiAzMHB4IGlzIHRoZSBtYWdpYyBtYXJnaW4gdXNlZCB0byBoaWRlIHRoZSBlbGVtZW50J3MgcmVhbCBzY3JvbGxiYXJzICovXFxuICAvKiBTZWUgb3ZlcmZsb3c6IGhpZGRlbiBpbiAuQ29kZU1pcnJvciAqL1xcbiAgbWFyZ2luLWJvdHRvbTogLTMwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IC0zMHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDMwcHg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgLyogUHJldmVudCBkcmFnZ2luZyBmcm9tIGhpZ2hsaWdodGluZyB0aGUgZWxlbWVudCAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLW1vei1ib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zaXplciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXItcmlnaHQ6IDMwcHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAtbW96LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxufVxcblxcbi8qIFRoZSBmYWtlLCB2aXNpYmxlIHNjcm9sbGJhcnMuIFVzZWQgdG8gZm9yY2UgcmVkcmF3IGR1cmluZyBzY3JvbGxpbmdcXG4gICBiZWZvcmUgYWN0dWFsbCBzY3JvbGxpbmcgaGFwcGVucywgdGh1cyBwcmV2ZW50aW5nIHNoYWtpbmcgYW5kXFxuICAgZmxpY2tlcmluZyBhcnRpZmFjdHMuICovXFxuXFxuLkNvZGVNaXJyb3ItdnNjcm9sbGJhcixcXG4uQ29kZU1pcnJvci1oc2Nyb2xsYmFyLFxcbi5Db2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXIsXFxuLkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA2O1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItdnNjcm9sbGJhciB7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItaHNjcm9sbGJhciB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbiAgb3ZlcmZsb3cteDogc2Nyb2xsO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyIHtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyIHtcXG4gIGxlZnQ6IDA7XFxuICBib3R0b206IDA7XFxufVxcblxcbi5Db2RlTWlycm9yLWd1dHRlcnMge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHBhZGRpbmctYm90dG9tOiAzMHB4O1xcbiAgei1pbmRleDogMztcXG59XFxuXFxuLkNvZGVNaXJyb3ItZ3V0dGVyIHtcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICAtbW96LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gIG1hcmdpbi1ib3R0b206IC0zMnB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgLyogSGFjayB0byBtYWtlIElFNyBiZWhhdmUgKi9cXG4gICp6b29tOiAxO1xcbiAgKmRpc3BsYXk6IGlubGluZTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItZ3V0dGVyLWVsdCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxuICB6LWluZGV4OiA0O1xcbn1cXG5cXG4uQ29kZU1pcnJvci1saW5lcyB7XFxuICBjdXJzb3I6IHRleHQ7XFxufVxcblxcbi5Db2RlTWlycm9yIHByZSB7XFxuICAvKiBSZXNldCBzb21lIHN0eWxlcyB0aGF0IHRoZSByZXN0IG9mIHRoZSBwYWdlIG1pZ2h0IGhhdmUgc2V0ICovXFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDA7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDA7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIG1hcmdpbjogMDtcXG4gIHdoaXRlLXNwYWNlOiBwcmU7XFxuICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB6LWluZGV4OiAyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi5Db2RlTWlycm9yLXdyYXAgcHJlIHtcXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIHdvcmQtYnJlYWs6IG5vcm1hbDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGluZWJhY2tncm91bmQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgei1pbmRleDogMDtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbGluZXdpZGdldCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAyO1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcblxcblxcbi5Db2RlTWlycm9yLXdyYXAgLkNvZGVNaXJyb3Itc2Nyb2xsIHtcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuXFxuLkNvZGVNaXJyb3ItbWVhc3VyZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcblxcbi5Db2RlTWlycm9yLW1lYXN1cmUgcHJlIHtcXG4gIHBvc2l0aW9uOiBzdGF0aWM7XFxufVxcblxcbi5Db2RlTWlycm9yIGRpdi5Db2RlTWlycm9yLWN1cnNvciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3JkZXItcmlnaHQ6IG5vbmU7XFxuICB3aWR0aDogMDtcXG59XFxuXFxuZGl2LkNvZGVNaXJyb3ItY3Vyc29ycyB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1mb2N1c2VkIGRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG59XFxuXFxuLkNvZGVNaXJyb3Itc2VsZWN0ZWQge1xcbiAgYmFja2dyb3VuZDogI2Q5ZDlkOTtcXG59XFxuXFxuLkNvZGVNaXJyb3ItZm9jdXNlZCAuQ29kZU1pcnJvci1zZWxlY3RlZCB7XFxuICBiYWNrZ3JvdW5kOiAjZDdkNGYwO1xcbn1cXG5cXG4uQ29kZU1pcnJvci1jcm9zc2hhaXIge1xcbiAgY3Vyc29yOiBjcm9zc2hhaXI7XFxufVxcblxcbi5jbS1zZWFyY2hpbmcge1xcbiAgYmFja2dyb3VuZDogI2ZmYTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDAsIC40KTtcXG59XFxuXFxuLyogSUU3IGhhY2sgdG8gcHJldmVudCBpdCBmcm9tIHJldHVybmluZyBmdW5ueSBvZmZzZXRUb3BzIG9uIHRoZSBzcGFucyAqL1xcblxcbi5Db2RlTWlycm9yIHNwYW4ge1xcbiAgKnZlcnRpY2FsLWFsaWduOiB0ZXh0LWJvdHRvbTtcXG59XFxuXFxuLyogVXNlZCB0byBmb3JjZSBhIGJvcmRlciBtb2RlbCBmb3IgYSBub2RlICovXFxuXFxuLmNtLWZvcmNlLWJvcmRlciB7XFxuICBwYWRkaW5nLXJpZ2h0OiAuMXB4O1xcbn1cXG5cXG5AbWVkaWEgcHJpbnQge1xcbiAgLyogSGlkZSB0aGUgY3Vyc29yIHdoZW4gcHJpbnRpbmcgKi9cXG5cXG4gIC5Db2RlTWlycm9yIGRpdi5Db2RlTWlycm9yLWN1cnNvcnMge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICB9XFxufVxcbi8qKlxcbiAqIFBhc3RlbCBPbiBEYXJrIHRoZW1lIHBvcnRlZCBmcm9tIEFDRSBlZGl0b3JcXG4gKiBAbGljZW5zZSBNSVRcXG4gKiBAY29weXJpZ2h0IEF0b21pY1BhZ2VzIExMQyAyMDE0XFxuICogQGF1dGhvciBEZW5uaXMgVGhvbXBzb24sIEF0b21pY1BhZ2VzIExMQ1xcbiAqIEB2ZXJzaW9uIDEuMVxcbiAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL2F0b21pY3BhZ2VzL2NvZGVtaXJyb3ItcGFzdGVsLW9uLWRhcmstdGhlbWVcXG4gKi9cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyay5Db2RlTWlycm9yIHtcXG4gIGJhY2tncm91bmQ6ICMyYzI4Mjc7XFxuICBjb2xvcjogIzhGOTM4RjtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbi5jbS1zLXBhc3RlbC1vbi1kYXJrIGRpdi5Db2RlTWlycm9yLXNlbGVjdGVkIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjIxLDI0MCwyNTUsMC4yKSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayAuQ29kZU1pcnJvci1ndXR0ZXJzIHtcXG4gIGJhY2tncm91bmQ6ICMzNDMwMmY7XFxuICBib3JkZXItcmlnaHQ6IDBweDtcXG4gIHBhZGRpbmc6IDAgM3B4O1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayAuQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXIge1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayAuQ29kZU1pcnJvci1ndXR0ZXJtYXJrZXItc3VidGxlIHtcXG4gIGNvbG9yOiAjOEY5MzhGO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayAuQ29kZU1pcnJvci1saW5lbnVtYmVyIHtcXG4gIGNvbG9yOiAjOEY5MzhGO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayAuQ29kZU1pcnJvci1jdXJzb3Ige1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjQTdBN0E3ICFpbXBvcnRhbnQ7XFxufVxcblxcbi5jbS1zLXBhc3RlbC1vbi1kYXJrIHNwYW4uY20tY29tbWVudCB7XFxuICBjb2xvcjogI0E2QzZGRjtcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgc3Bhbi5jbS1hdG9tIHtcXG4gIGNvbG9yOiAjREU4RTMwO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayBzcGFuLmNtLW51bWJlciB7XFxuICBjb2xvcjogI0NDQ0NDQztcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgc3Bhbi5jbS1wcm9wZXJ0eSB7XFxuICBjb2xvcjogIzhGOTM4RjtcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgc3Bhbi5jbS1hdHRyaWJ1dGUge1xcbiAgY29sb3I6ICNhNmUyMmU7XFxufVxcblxcbi5jbS1zLXBhc3RlbC1vbi1kYXJrIHNwYW4uY20ta2V5d29yZCB7XFxuICBjb2xvcjogI0FFQjJGODtcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgc3Bhbi5jbS1zdHJpbmcge1xcbiAgY29sb3I6ICM2NkE5Njg7XFxufVxcblxcbi5jbS1zLXBhc3RlbC1vbi1kYXJrIHNwYW4uY20tdmFyaWFibGUge1xcbiAgY29sb3I6ICNBRUIyRjg7XFxufVxcblxcbi5jbS1zLXBhc3RlbC1vbi1kYXJrIHNwYW4uY20tdmFyaWFibGUtMiB7XFxuICBjb2xvcjogI0JFQkY1NTtcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgc3Bhbi5jbS12YXJpYWJsZS0zIHtcXG4gIGNvbG9yOiAjREU4RTMwO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayBzcGFuLmNtLWRlZiB7XFxuICBjb2xvcjogIzc1N2FEODtcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgc3Bhbi5jbS1icmFja2V0IHtcXG4gIGNvbG9yOiAjZjhmOGYyO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayBzcGFuLmNtLXRhZyB7XFxuICBjb2xvcjogI0MxQzE0NDtcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgc3Bhbi5jbS1saW5rIHtcXG4gIGNvbG9yOiAjYWU4MWZmO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayBzcGFuLmNtLXF1YWxpZmllcixcXG4uY20tcy1wYXN0ZWwtb24tZGFyayBzcGFuLmNtLWJ1aWx0aW4ge1xcbiAgY29sb3I6ICNDMUMxNDQ7XFxufVxcblxcbi5jbS1zLXBhc3RlbC1vbi1kYXJrIHNwYW4uY20tZXJyb3Ige1xcbiAgYmFja2dyb3VuZDogIzc1N2FEODtcXG4gIGNvbG9yOiAjZjhmOGYwO1xcbn1cXG5cXG4uY20tcy1wYXN0ZWwtb24tZGFyayAuQ29kZU1pcnJvci1hY3RpdmVsaW5lLWJhY2tncm91bmQge1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjAzMSkgIWltcG9ydGFudDtcXG59XFxuXFxuLmNtLXMtcGFzdGVsLW9uLWRhcmsgLkNvZGVNaXJyb3ItbWF0Y2hpbmdicmFja2V0IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yNSk7XFxuICBjb2xvcjogIzhGOTM4RiAhaW1wb3J0YW50O1xcbiAgbWFyZ2luOiAtMXB4IC0xcHggMCAtMXB4O1xcbn1cIjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlQmV6aWVyRWRpdG9yOiBjcmVhdGVCZXppZXJFZGl0b3IsXG5cbiAgICAgICAgRUFTRTJCRVpJRVI6IHtcbiAgICAgICAgICAgICdlYXNlJzogJ2N1YmljLWJlemllciguMjUsLjEsLjI1LDEpJyxcbiAgICAgICAgICAgICdsaW5lYXInOiAnY3ViaWMtYmV6aWVyKDAsMCwxLDEpJyxcbiAgICAgICAgICAgICdlYXNlLWluJzogJ2N1YmljLWJlemllciguNDIsMCwxLDEpJyxcbiAgICAgICAgICAgICdlYXNlLW91dCc6ICdjdWJpYy1iZXppZXIoMCwwLC41OCwxKScsXG4gICAgICAgICAgICAnZWFzZS1pbi1vdXQnOiAnY3ViaWMtYmV6aWVyKC40MiwwLC41OCwxKScsXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyRWRpdG9yKG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdmFyIHAwID0ge3g6IDAuMywgeTogMC4zfSxcbiAgICAgICAgcDEgPSB7eDogMC43LCB5OiAwLjd9LFxuICAgICAgICB3ID0gb3B0LndpZHRoIHx8IDMxMixcbiAgICAgICAgaCA9IG9wdC5oZWlnaHQgfHwgMzEyO1xuXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGRlLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgZGUuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG5cbiAgICB2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGMud2lkdGggPSB3O1xuICAgIGMuaGVpZ2h0ID0gaDtcbiAgICBkZS5hcHBlbmRDaGlsZChjKTtcblxuICAgIHZhciBjdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gIFxuICAgIHZhciBkZUNwMCA9IGNyZWF0ZUNwKHAwKTtcbiAgICB2YXIgZGVDcDEgPSBjcmVhdGVDcChwMSk7XG5cbiAgICBkZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gJ2N1YmljLWJlemllcignK3AwLngrJywnK3AwLnkrJywnK3AxLngrJywnK3AxLnkrJyknO1xuICAgIH07XG5cbiAgICBkZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChwb2ludHMpIHtcblxuICAgICAgICBpZiAoYW1ndWkuRUFTRTJCRVpJRVIuaGFzT3duUHJvcGVydHkocG9pbnRzKSkge1xuXG4gICAgICAgICAgICBwb2ludHMgPSBhbWd1aS5FQVNFMkJFWklFUltwb2ludHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihwb2ludHMpID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICB2YXIgcnggPSAvY3ViaWMtYmV6aWVyXFwoXFxzKihbXFxkXFwuXSspXFxzKixcXHMqKFtcXGRcXC4tXSspXFxzKixcXHMqKFtcXGRcXC5dKylcXHMqLFxccyooW1xcZFxcLi1dKylcXHMqXFwpLyxcbiAgICAgICAgICAgICAgICBtID0gcnguZXhlYyhwb2ludHMpO1xuXG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3AweDogbVsxXSxcbiAgICAgICAgICAgICAgICAgICAgY3AweTogbVsyXSxcbiAgICAgICAgICAgICAgICAgICAgY3AxeDogbVszXSxcbiAgICAgICAgICAgICAgICAgICAgY3AxeTogbVs0XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBjcDB4OiAwLjMsXG4gICAgICAgICAgICAgICAgICAgIGNwMHk6IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgY3AxeDogMC43LFxuICAgICAgICAgICAgICAgICAgICBjcDF5OiAwLjcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAwLnggPSBwb2ludHMuY3AweDtcbiAgICAgICAgcDAueSA9IHBvaW50cy5jcDB5O1xuICAgICAgICBwMS54ID0gcG9pbnRzLmNwMXg7XG4gICAgICAgIHAxLnkgPSBwb2ludHMuY3AxeTtcbiAgICAgICAgXG4gICAgICAgIHJlbmRlcigpO1xuICAgIH07XG4gICAgXG4gICAgcmVuZGVyKCk7XG5cbiAgICBpZiAob3B0Lm9uQ2hhbmdlKSB7XG4gICAgICAgIGRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9wdC5vbkNoYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdC5wYXJlbnQpIHtcbiAgICAgICAgb3B0LnBhcmVudC5hcHBlbmRDaGlsZChkZSk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gZGU7XG4gIFxuXG4gIFxuICBcblxuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeChwMC54KSwgeShwMC55KSk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgeSgwKSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgeChwMC54KSwgeShwMC55KSxcbiAgICAgICAgICAgIHgocDEueCksIHkocDEueSksXG4gICAgICAgICAgICB4KDEpLCB5KDEpKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4KHAxLngpLCB5KHAxLnkpKTtcbiAgICAgICAgXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoeCgwKSwgeSgwKSwgeCgxKSwgeSgxKSAtIHkoMCkpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2ZmZic7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBcbiAgICAgICAgZGVDcDAucmVmcmVzaFBvc2l0aW9uKCk7XG4gICAgICAgIGRlQ3AxLnJlZnJlc2hQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHggKHApIHtcbiAgICAgICAgcmV0dXJuIHAgKiB3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHkgKHApIHtcblxuICAgICAgICB2YXIgbWluID0gbWluWSgpLFxuICAgICAgICAgICAgbWF4ID0gbWF4WSgpLFxuICAgICAgICAgICAgZnVsbCA9IG1heCAtIG1pbjtcblxuICAgICAgICByZXR1cm4gaCAtICgoKHAgLSBtaW4pIC8gZnVsbCkgKiBoKTtcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIG1pblkoKSB7XG4gICAgXG4gICAgICAgIHJldHVybiBNYXRoLm1pbigwLCBwMC55LCBwMS55KTtcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIG1heFkoKSB7XG4gICAgXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgxLCBwMC55LCBwMS55KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDcChwb2ludCkge1xuXG4gICAgICAgIHZhciByID0gNjtcblxuICAgICAgICB2YXIgZGVDcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkZUNwLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZGVDcC5zdHlsZS5jdXJzb3IgPSAnZ3JhYic7XG4gICAgICAgIGRlQ3Auc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgICAgICBkZUNwLnN0eWxlLndpZHRoID0gcioyICsgJ3B4JztcbiAgICAgICAgZGVDcC5zdHlsZS5oZWlnaHQgPSByKjIgKyAncHgnO1xuICAgICAgICBkZUNwLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLScrcisncHgsLScrcisncHgpJztcbiAgICAgICAgZGVDcC5zdHlsZS5ib3JkZXJSYWRpdXMgPSByICsgJ3B4JztcbiAgICAgICAgZGVDcC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JnYmEoMjU2LCAyNTYsIDI1NiwgMSknO1xuICAgICAgICBkZS5hcHBlbmRDaGlsZChkZUNwKTtcbiAgICAgIFxuICAgICAgICBhbWd1aS5tYWtlRHJhZ2dhYmxlKHtcbiAgICAgICAgICAgIGRlVGFyZ2V0OiBkZUNwLFxuICAgICAgICAgICAgb25Eb3duOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZUNwLnN0eWxlLmN1cnNvciA9ICdncmFiYmluZyc7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWQgPSB7fTtcbiAgICAgICAgICAgICAgICBtZC5taW5ZID0gbWluWSgpO1xuICAgICAgICAgICAgICAgIG1kLmZ1bGxZID0gbWF4WSgpIC0gbWQubWluWTsgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1kO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKG1kLCBteCwgbXkpIHtcblxuICAgICAgICAgICAgICAgIHZhciBiciA9IGRlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChteCAtIGJyLmxlZnQpIC8gdykpO1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSAoKChici5ib3R0b20gLSBteSkgLyBoKSAqIG1kLmZ1bGxZKSAtIG1kLm1pblk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGZpeCA9IDEwMDA7XG4gICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlSW50KHBvaW50LnggKiBmaXgpIC8gZml4O1xuICAgICAgICAgICAgICAgIHBvaW50LnkgPSBwYXJzZUludChwb2ludC55ICogZml4KSAvIGZpeDtcblxuICAgICAgICAgICAgICAgIHJlbmRlcigpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkZS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywge2RldGFpbDoge3ZhbHVlOiBkZS5nZXRWYWx1ZSgpfX0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblVwOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZUNwLnN0eWxlLmN1cnNvciA9ICdncmFiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgICAgZGVDcC5yZWZyZXNoUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRlQ3Auc3R5bGUubGVmdCA9IHgocG9pbnQueCkgKyAncHgnO1xuICAgICAgICAgICAgZGVDcC5zdHlsZS50b3AgPSB5KHBvaW50LnkpICsgJ3B4JztcbiAgICAgICAgfTtcbiAgICAgICAgZGVDcC5yZWZyZXNoUG9zaXRpb24oKTtcbiAgICAgIFxuICAgICAgICByZXR1cm4gZGVDcDtcbiAgICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9udGVsbG9Db25mID0gcmVxdWlyZSgnLi4vYXNzZXRzL2ZvbnRlbGxvL2NvbmZpZy5qc29uJyk7XG52YXIgYW1ndWk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9hbWd1aSkge1xuXG4gICAgYW1ndWkgPSBfYW1ndWk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGVJY29uOiBjcmVhdGVJY29uLFxuICAgICAgICBjcmVhdGVMYWJlbDogY3JlYXRlTGFiZWwsXG4gICAgICAgIGNyZWF0ZUJ0bjogY3JlYXRlQnRuLFxuICAgICAgICBjcmVhdGVJY29uQnRuOiBjcmVhdGVJY29uQnRuLFxuICAgICAgICBjcmVhdGVUb2dnbGVJY29uQnRuOiBjcmVhdGVUb2dnbGVJY29uQnRuLFxuICAgICAgICBjcmVhdGVMaW5lYnJlYWs6IGNyZWF0ZUxpbmVicmVhayxcbiAgICB9O1xufTtcblxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lYnJlYWsob3B0KSB7XG5cbiAgICB2YXIgZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpO1xuICAgIGRlLmlubmVySFRNTCA9IG9wdC5jYXB0aW9uIHx8ICdsYWJlbCc7XG4gICAgXG4gICAgaWYgKG9wdC5wYXJlbnQpIHtcbiAgICAgICAgb3B0LnBhcmVudC5hcHBlbmRDaGlsZChkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMYWJlbChvcHQpIHtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBkZS5pbm5lckhUTUwgPSBvcHQuY2FwdGlvbiB8fCAnbGFiZWwnO1xuXG4gICAgaWYgKCdmb250U2l6ZScgaW4gb3B0KSBkZS5zdHlsZS5mb250U2l6ZSA9IG9wdC5mb250U2l6ZTtcbiAgICBpZiAoJ2Rpc3BsYXknIGluIG9wdCkgZGUuc3R5bGUuZGlzcGxheSA9IG9wdC5kaXNwbGF5O1xuICAgIGlmICgncG9zaXRpb24nIGluIG9wdCkgZGUuc3R5bGUucG9zaXRpb24gPSBvcHQucG9zaXRpb247XG4gICAgXG4gICAgaWYgKG9wdC5wYXJlbnQpIHtcbiAgICAgICAgb3B0LnBhcmVudC5hcHBlbmRDaGlsZChkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCdG4ob3B0KSB7XG5cbiAgICBvcHQuYmFja2dyb3VuZENvbG9yID0gb3B0LmJhY2tncm91bmRDb2xvciB8fCBhbWd1aS5jb2xvci5iZzA7XG5cbiAgICB2YXIgZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZS5zdHlsZS5oZWlnaHQgPSAob3B0LmhlaWdodCB8fCAyMSkgKyAncHgnO1xuICAgIGRlLnN0eWxlLnBhZGRpbmcgPSAnMCAxNXB4JztcbiAgICBkZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgZGUuc3R5bGUuY29sb3IgPSBhbWd1aS5jb2xvci50ZXh0O1xuICAgIGRlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG9wdC5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBkZS5zZXRDYXB0aW9uID0gZnVuY3Rpb24gKGNhcHRpb24pIHtcblxuICAgICAgICBkZS50ZXh0Q29udGVudCA9IGNhcHRpb247XG4gICAgfTtcbiAgICBcbiAgICBkZS5zZXRDYXB0aW9uKG9wdC5jYXB0aW9uIHx8ICdidXR0b24nKTtcblxuICAgIGRlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1PdmVyKTtcbiAgICBkZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25NT3V0KTtcblxuICAgIGZ1bmN0aW9uIG9uTU92ZXIoKSB7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kID0gYW1ndWkuY29sb3IuYmdIb3ZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1PdXQoKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnN0eWxlLmJhY2tncm91bmQgPSBvcHQuYmFja2dyb3VuZENvbG9yO1xuICAgIH1cblxuICAgIGlmIChvcHQucGFyZW50KSB7XG4gICAgICAgIG9wdC5wYXJlbnQuYXBwZW5kQ2hpbGQoZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBkZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSWNvbkJ0bihvcHQpIHtcblxuICAgIHZhciBpc0ZpeGVkSGlnaGxpZ2h0ID0gZmFsc2U7XG5cbiAgICB2YXIgZGUgPSBhbWd1aS5jcmVhdGVJY29uKHtcbiAgICAgICAgc2l6ZTogb3B0LmhlaWdodCwgXG4gICAgICAgIGljb246IG9wdC5pY29uLFxuICAgICAgICBwYXJlbnQ6IG9wdC5wYXJlbnQsXG4gICAgICAgIHRvb2x0aXA6IG9wdC50b29sdGlwLFxuICAgICAgICBkaXNwbGF5OiBvcHQuZGlzcGxheSxcbiAgICB9KTtcbiAgICBkZS5zdHlsZS53aWR0aCA9IChvcHQud2lkdGggfHwgMjEpICsgJ3B4JztcbiAgICBkZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgZGUuc3R5bGUuY29sb3IgPSAnd2hpdGUnO1xuICAgIGRlLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICBkZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25NT3Zlcik7XG4gICAgZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTU91dCk7XG5cbiAgICBpZiAoJ29uQ2xpY2snIGluIG9wdCkge1xuICAgICAgICBkZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9wdC5vbkNsaWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1PdmVyKCkge1xuXG4gICAgICAgIGRlLnN0eWxlLmJhY2tncm91bmQgPSBhbWd1aS5jb2xvci5iZ0hvdmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTU91dCgpIHtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc0ZpeGVkSGlnaGxpZ2h0KSByZXR1cm47XG5cbiAgICAgICAgZGUuc3R5bGUuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICB9XG5cbiAgICBkZS5maXhIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaXNGaXhlZEhpZ2hsaWdodCA9IHRydWU7XG4gICAgICAgIG9uTU92ZXIoKTtcbiAgICB9O1xuXG4gICAgZGUucmVtb3ZlRml4SGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlzRml4ZWRIaWdobGlnaHQgPSBmYWxzZTtcbiAgICAgICAgb25NT3V0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVG9nZ2xlSWNvbkJ0bihvcHQpIHtcblxuICAgIG9wdC5pY29uT24gPSBvcHQuaWNvbk9uIHx8IG9wdC5pY29uO1xuICAgIG9wdC5pY29uT2ZmID0gb3B0Lmljb25PZmYgfHwgb3B0Lmljb247XG4gICAgb3B0LmNvbG9yID0gb3B0LmNvbG9yIHx8IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgb3B0LmNvbG9ySW5hY3RpdmUgPSBvcHQuY29sb3JJbmFjdGl2ZSB8fCBhbWd1aS5jb2xvci50ZXh0SW5hY3RpdmU7XG5cbiAgICB2YXIgaXNPbiA9IG9wdC5kZWZhdWx0VG9nZ2xlIHx8IGZhbHNlO1xuICAgIHZhciBkZSA9IGFtZ3VpLmNyZWF0ZUljb25CdG4ob3B0KTtcbiAgICBzZXRJY29uKCk7XG5cbiAgICBpZiAoJ2F1dG9Ub2dnbGUnIGluIG9wdCA/IG9wdC5hdXRvVG9nZ2xlIDogIW9wdC5vbkNsaWNrKSB7XG4gICAgICAgIFxuICAgICAgICBkZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2spO1xuICAgIH1cblxuICAgIGlmICgnb25Ub2dnbGUnIGluIG9wdCkge1xuXG4gICAgICAgIGRlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvZ2dsZScsIG9wdC5vblRvZ2dsZSk7XG4gICAgfVxuXG4gICAgZGUuc2V0VG9nZ2xlID0gZnVuY3Rpb24gKG9uKSB7XG5cbiAgICAgICAgb24gPSAhIW9uO1xuICAgICAgICBpZiAob24gPT09IGlzT24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaXNPbiA9IG9uO1xuICAgICAgICBzZXRJY29uKCk7XG5cbiAgICAgICAgZGUuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3RvZ2dsZScsIHtkZXRhaWw6IHtzdGF0ZTogaXNPbn19KSk7XG4gICAgICAgIGRlLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGlzT24gPyAndG9nZ2xlT24nIDogJ3RvZ2dsZU9mZicpKTtcbiAgICB9O1xuXG4gICAgZGUuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIGlzT247XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgXG4gICAgICAgIGRlLnNldFRvZ2dsZSghaXNPbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SWNvbigpIHtcblxuICAgICAgICBkZS5zZXRJY29uKGlzT24gPyBvcHQuaWNvbk9uIDogb3B0Lmljb25PZmYpO1xuXG4gICAgICAgIGlmIChvcHQuY2hhbmdlQ29sb3IpIHtcbiAgICAgICAgICAgIGRlLnN0eWxlLmNvbG9yID0gaXNPbiA/IG9wdC5jb2xvciA6IG9wdC5jb2xvckluYWN0aXZlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJY29uKG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIG9wdC5zaXplID0gb3B0LnNpemUgfHwgMjM7XG4gICAgXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUuc3R5bGUuY29sb3IgPSAnI2ZmZic7XG4gICAgZGUuc3R5bGUud2lkdGggPSBvcHQuc2l6ZSArICdweCc7XG4gICAgZGUuc3R5bGUuaGVpZ2h0ID0gb3B0LnNpemUgKyAncHgnO1xuICAgIGRlLnN0eWxlLmxpbmVIZWlnaHQgPSBvcHQuc2l6ZSArICdweCc7XG4gICAgZGUuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgZGUuc3R5bGUuZm9udEZhbWlseSA9ICdhbWd1aSc7XG4gICAgZGUuc3R5bGUuZm9udFNpemUgPSBNYXRoLnJvdW5kKG9wdC5zaXplICogMC43MikgKyAncHgnO1xuICAgIGRlLnN0eWxlLmRpc3BsYXkgPSBvcHQuZGlzcGxheSB8fCAnYmxvY2snO1xuXG4gICAgZGUuc2V0SWNvbiA9IGZ1bmN0aW9uIChpY29uKSB7XG5cbiAgICAgICAgdmFyIGdseXBoID0gZm9udGVsbG9Db25mLmdseXBocy5maW5kKGZ1bmN0aW9uIChnbHlwaCkge1xuXG4gICAgICAgICAgICByZXR1cm4gZ2x5cGguY3NzID09PSBpY29uO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY29kZSA9IGdseXBoID8gZ2x5cGguY29kZSA6IDU5NDA3O1xuICAgICAgICBkZS50ZXh0Q29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfTtcblxuICAgIGRlLnNldEljb24ob3B0Lmljb24pO1xuXG4gICAgaWYgKG9wdC50b29sdGlwKSB7XG4gICAgICAgIGFtZ3VpLmFkZFRvb2x0aXAoe1xuICAgICAgICAgICAgZGVUYXJnZXQ6IGRlLFxuICAgICAgICAgICAgdGV4dDogb3B0LnRvb2x0aXBcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdC5wYXJlbnQpIHtcbiAgICAgICAgb3B0LnBhcmVudC5hcHBlbmRDaGlsZChkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlRGlhbG9nOiBjcmVhdGVEaWFsb2csXG4gICAgfTtcbn07XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVEaWFsb2cob3B0KSB7XG5cbiAgICB2YXIgZGUsIGRlVGl0bGUsIGRlVGl0bGVUZXh0LCBkZVRpdGxlSWNvbiwgdGl0bGVFbmQsXG4gICAgICAgIGNvbnRlbnRDb250LCBidXR0b25zQ29udCwgYnV0dG9uc0VuZDtcblxuICAgIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGlhbG9nJyk7XG4gICAgKG9wdC5wYXJlbnQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoZGUpO1xuXG4gICAgZGUuc3R5bGUuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICBkZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICBkZS5zdHlsZS5mb250RmFtaWx5ID0gYW1ndWkuRk9OVF9GQU1JTFk7XG4gICAgZGUuc3R5bGUuY29sb3IgPSBhbWd1aS5jb2xvci50ZXh0O1xuXG5cbiAgICBkZVRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVUaXRsZS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgZGVUaXRsZS5zdHlsZS5wYWRkaW5nID0gJzAgMThweCc7XG4gICAgZGVUaXRsZS5zdHlsZS5oZWlnaHQgPSAnMzRweCc7XG4gICAgZGVUaXRsZS5zdHlsZS5mb250U2l6ZSA9ICcyM3B4JztcbiAgICBkZVRpdGxlLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgZGVUaXRsZS5zdHlsZS5iYWNrZ3JvdW5kID0gYW1ndWkuY29sb3Iub3ZlcmxheTtcbiAgICBkZVRpdGxlLnN0eWxlLmNvbG9yID0gYW1ndWkuY29sb3IudGV4dDtcbiAgICBkZS5hcHBlbmRDaGlsZChkZVRpdGxlKTtcblxuICAgIGRlVGl0bGVUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGRlVGl0bGUuYXBwZW5kQ2hpbGQoZGVUaXRsZVRleHQpO1xuXG4gICAgaWYgKG9wdC50aXRsZUljb24pIHtcblxuICAgICAgICBkZVRpdGxlSWNvbiA9IGFtZ3VpLmNyZWF0ZUljb24oe1xuICAgICAgICAgICAgaWNvbjogb3B0LnRpdGxlSWNvbixcbiAgICAgICAgICAgIHBhcmVudDogZGVUaXRsZSxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aXRsZUVuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRpdGxlRW5kLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB0aXRsZUVuZC5zdHlsZS53aWR0aCA9ICcwJztcbiAgICB0aXRsZUVuZC5zdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAgdGl0bGVFbmQuc3R5bGUudmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgIHRpdGxlRW5kLnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgICB0aXRsZUVuZC5zdHlsZS5ib3JkZXJXaWR0aCA9ICczNHB4IDAgMCA4cHgnO1xuICAgIHRpdGxlRW5kLnN0eWxlLmJvcmRlckNvbG9yID0gJ3RyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICcgKyBhbWd1aS5jb2xvci5vdmVybGF5O1xuICAgIGRlLmFwcGVuZENoaWxkKHRpdGxlRW5kKTtcblxuICAgIFxuXG4gICAgY29udGVudENvbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50Q29udC5zdHlsZS5iYWNrZ3JvdW5kID0gYW1ndWkuY29sb3Iub3ZlcmxheTtcbiAgICBkZS5hcHBlbmRDaGlsZChjb250ZW50Q29udCk7XG5cbiAgICBidXR0b25zQ29udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ1dHRvbnNDb250LnN0eWxlLmJhY2tncm91bmQgPSBhbWd1aS5jb2xvci5vdmVybGF5O1xuICAgIGJ1dHRvbnNDb250LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICBidXR0b25zQ29udC5zdHlsZS5mbG9hdCA9ICdyaWdodCc7XG4gICAgZGUuYXBwZW5kQ2hpbGQoYnV0dG9uc0NvbnQpO1xuXG5cbiAgICBkZS5zZXRUaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuXG4gICAgICAgIGRlVGl0bGVUZXh0LnRleHRDb250ZW50ID0gdGl0bGUgfHwgJ0RpYWxvZyc7XG4gICAgfTtcblxuICAgIGRlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkge1xuXG4gICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudENvbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGNvbnRlbnRDb250LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBkZS5zZXRCdXR0b25zID0gZnVuY3Rpb24gKGJ1dHRvbnMpIHtcblxuICAgICAgICBpZiAoIWJ1dHRvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1dHRvbnNDb250LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgIGJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoY2FwdGlvbikge1xuXG4gICAgICAgICAgICB2YXIgYnRuID0gYW1ndWkuY3JlYXRlQnRuKHtjYXB0aW9uOiBjYXB0aW9ufSk7XG4gICAgICAgICAgICBidG4uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgYnRuLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgICAgICAgICBidG4uc3R5bGUuZm9udFNpemUgPSAnMThweCc7XG4gICAgICAgICAgICBidG4uc3R5bGUuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICAgICAgICAgIGJ1dHRvbnNDb250LmFwcGVuZENoaWxkKGJ0bik7XG5cbiAgICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2xpY2tfJyArIGNhcHRpb24udG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkZS5zZXRUaXRsZShvcHQudGl0bGUpO1xuICAgIGRlLnNldENvbnRlbnQob3B0LmNvbnRlbnQpO1xuICAgIGRlLnNldEJ1dHRvbnMob3B0LmJ1dHRvbnMpO1xuXG4gICAgYnV0dG9uc0VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ1dHRvbnNFbmQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIGJ1dHRvbnNFbmQuc3R5bGUuZmxvYXQgPSAncmlnaHQnO1xuICAgIGJ1dHRvbnNFbmQuc3R5bGUud2lkdGggPSAnMCc7XG4gICAgYnV0dG9uc0VuZC5zdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAgYnV0dG9uc0VuZC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG4gICAgYnV0dG9uc0VuZC5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gICAgYnV0dG9uc0VuZC5zdHlsZS5ib3JkZXJXaWR0aCA9ICcwIDZweCAyMXB4IDAnO1xuICAgIGJ1dHRvbnNFbmQuc3R5bGUuYm9yZGVyQ29sb3IgPSAndHJhbnNwYXJlbnQgJythbWd1aS5jb2xvci5vdmVybGF5KycgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQnO1xuICAgIGRlLmFwcGVuZENoaWxkKGJ1dHRvbnNFbmQpO1xuXG4gICAgcmV0dXJuIGRlO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlRHJvcGRvd246IGNyZWF0ZURyb3Bkb3duLFxuICAgICAgICBiaW5kRHJvcGRvd246IGJpbmREcm9wZG93bixcbiAgICB9O1xufTtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZURyb3Bkb3duKG9wdCkge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHQub3B0aW9ucyB8fCBbXTtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgZGUuc3R5bGUubGlzdFN0eWxlVHlwZSA9ICdub25lJztcbiAgICBkZS5zdHlsZS5tYXJnaW4gPSAwO1xuICAgIGRlLnN0eWxlLnBhZGRpbmcgPSAwO1xuXG4gICAgb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHQpIHtcblxuICAgICAgICBpZiAodHlwZW9mKG9wdCkgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIG9wdCA9IHt0ZXh0OiBvcHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgbGkudGV4dENvbnRlbnQgPSBvcHQudGV4dDtcbiAgICAgICAgbGkuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBsaS5zdHlsZS5mb250RmFtaWx5ID0gYW1ndWkuRk9OVF9GQU1JTFk7XG4gICAgICAgIGxpLnN0eWxlLmZvbnRTaXplID0gJzE0cHgnO1xuICAgICAgICBsaS5zdHlsZS5wYWRkaW5nID0gJzAgM3B4JztcbiAgICAgICAgbGkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICBsaS5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgICAgIGxpLnN0eWxlLmJhY2tncm91bmQgPSBhbWd1aS5jb2xvci5iZzI7XG5cbiAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAob3B0Lm9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgb3B0Lm9uU2VsZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzZWxlY3QnLCB7ZGV0YWlsOiB7c2VsZWN0aW9uOiBvcHQudGV4dH19KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZS5hcHBlbmRDaGlsZChsaSk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0Lm9uU2VsZWN0KSB7XG5cbiAgICAgICAgZGUuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0Jywgb3B0Lm9uU2VsZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGU7XG59XG5cbmZ1bmN0aW9uIGJpbmREcm9wZG93bihvcHQpIHtcblxuICAgIHZhciBpc09wZW5lZCA9IGZhbHNlO1xuICAgIHZhciBkZUJ0biA9IG9wdC5kZVRhcmdldDtcbiAgICB2YXIgZGVEcm9wZG93biA9IG9wdC5kZU1lbnU7XG5cbiAgICBpZiAob3B0LmFzQ29udGV4dE1lbnUpIHtcblxuICAgICAgICBkZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpc09wZW5lZCA/IGNsb3NlKGUpIDogb3BlbihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBcbiAgICAgICAgZGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaXNPcGVuZWQgPyBjbG9zZShlKSA6IG9wZW4oZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlRHJvcGRvd24uc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGRlRHJvcGRvd24uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICBcbiAgICBkZURyb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdCcsIGNsb3NlKTtcblxuICAgIGZ1bmN0aW9uIG9wZW4oZSkge1xuXG4gICAgICAgIGlmIChpc09wZW5lZCkgcmV0dXJuO1xuICAgICAgICBpc09wZW5lZCA9IHRydWU7XG5cbiAgICAgICAgXG4gICAgICAgIGFtZ3VpLnBsYWNlVG9Qb2ludChkZURyb3Bkb3duLCBlLmNsaWVudFgsIGUuY2xpZW50WSwgb3B0LnNpZGUpO1xuXG4gICAgICAgIHZhciBkZUNvbnQgPSBvcHQubWVudVBhcmVudCB8fCBhbWd1aS5kZU92ZXJsYXlDb250IHx8IGRlQnRuO1xuXG4gICAgICAgIGRlQ29udC5hcHBlbmRDaGlsZChkZURyb3Bkb3duKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuXG4gICAgICAgIGlmICghaXNPcGVuZWQpIHJldHVybjtcbiAgICAgICAgaXNPcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkZURyb3Bkb3duLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRlRHJvcGRvd24ucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChkZURyb3Bkb3duKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbG9zZSk7XG4gICAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlSW5wdXQ6IGNyZWF0ZUlucHV0LFxuICAgIH07XG59O1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0KG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdmFyIGlucCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaW5wLnR5cGUgPSBvcHQudHlwZSB8fCAndGV4dCc7XG4gICAgaW5wLnN0eWxlLndpZHRoID0gb3B0LndpZHRoIHx8ICcyNDVweCc7XG4gICAgaW5wLnN0eWxlLmhlaWdodCA9IG9wdC5oZWlnaHQgfHwgJzE0cHgnO1xuICAgIGlucC5zdHlsZS5mb250U2l6ZSA9IG9wdC5mb250U2l6ZSB8fCAnMTRweCc7XG4gICAgaW5wLnN0eWxlLmZvbnRGYW1pbHkgPSBhbWd1aS5GT05UX0ZBTUlMWTtcbiAgICBpbnAuc3R5bGUuY29sb3IgPSBhbWd1aS5jb2xvci50ZXh0O1xuICAgIGlucC5zdHlsZS5iYWNrZ3JvdW5kID0gJ25vbmUnO1xuICAgIGlucC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG5cbiAgICBpZiAoJ3BhbGNlaG9sZGVyJyBpbiBvcHQpIGlucC5wYWxjZWhvbGRlciA9IG9wdC5wYWxjZWhvbGRlcjtcbiAgICBpZiAoJ3ZhbHVlJyBpbiBvcHQpIGlucC52YWx1ZSA9IG9wdC52YWx1ZTtcblxuICAgIGlmIChvcHQucGFyZW50KSB7XG4gICAgICAgIG9wdC5wYXJlbnQuYXBwZW5kQ2hpbGQoaW5wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuV2ViRm9udC5sb2FkKHtcbiAgICBnb29nbGU6IHtcbiAgICAgIGZhbWlsaWVzOiBbJ09wZW4gU2FucyddXG4gICAgfVxufSk7XG5cbnZhciBhbWd1aSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXy5leHRlbmQoYW1ndWksXG4gICAgcmVxdWlyZSgnLi9hbWd1aS5iZXppZXJFZGl0b3InKShhbWd1aSksXG4gICAgcmVxdWlyZSgnLi9hbWd1aS5idXR0b24nKShhbWd1aSksXG4gICAgcmVxdWlyZSgnLi9hbWd1aS5kaWFsb2cnKShhbWd1aSksXG4gICAgcmVxdWlyZSgnLi9hbWd1aS5kcm9wZG93bicpKGFtZ3VpKSxcbiAgICByZXF1aXJlKCcuL2FtZ3VpLmlucHV0JykoYW1ndWkpLFxuICAgIHJlcXVpcmUoJy4vYW1ndWkua2V5cycpKGFtZ3VpKSxcbiAgICByZXF1aXJlKCcuL2FtZ3VpLmtleVZhbHVlSW5wdXQnKShhbWd1aSksXG4gICAgcmVxdWlyZSgnLi9hbWd1aS5tYWtlRHJhZ2dhYmxlJykoYW1ndWkpLFxuICAgIHJlcXVpcmUoJy4vYW1ndWkuc2Nyb2xsJykoYW1ndWkpLFxuICAgIHJlcXVpcmUoJy4vYW1ndWkudG9vbHRpcCcpKGFtZ3VpKSxcbiAgICByZXF1aXJlKCcuL2FtZ3VpLnV0aWxzJykoYW1ndWkpLFxuICAgIHtcblxuICAgICAgICBGT05UX0ZBTUlMWTogJ1wiT3BlbiBTYW5zXCIsIHNhbnMtc2VyaWYnLFxuICAgICAgICBGT05UX1NJWkU6ICcxNXB4JyxcblxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgYmcwOiAnIzAwMCcsXG4gICAgICAgICAgICBiZzE6ICcjMjIyJyxcbiAgICAgICAgICAgIGJnMjogJyM0NDQnLFxuICAgICAgICAgICAgYmczOiAnIzY2NicsXG4gICAgICAgICAgICB0ZXh0OiAnI2VmZScsXG4gICAgICAgICAgICB0ZXh0SW5hY3RpdmU6ICdyZ2JhKDI1NSwyNTUsMjU1LC4yMyknLFxuICAgICAgICAgICAgb3ZlcmxheTogJ3JnYmEoMCwwLDAsLjc4NSknLFxuICAgICAgICAgICAgYmdIb3ZlcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC4xMiknLFxuICAgICAgICB9LFxuXG4gICAgICAgIGdldFN0eWxlU2hlZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICAgICAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gJ2RpYWxvZzo6YmFja2Ryb3AgeyBiYWNrZ3JvdW5kOicrYW1ndWkuY29sb3IuYmdIb3ZlcisnIH0nO1xuXG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG5cbmFtZ3VpLnNldE1heExpc3RlbmVycygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbWd1aTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbWd1aTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2FtZ3VpKSB7XG5cbiAgICBhbWd1aSA9IF9hbWd1aTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZUtleVZhbHVlSW5wdXQ6IGNyZWF0ZUtleVZhbHVlSW5wdXQsXG4gICAgfTtcbn07XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVLZXlWYWx1ZUlucHV0KG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGUuc3R5bGUubWFyZ2luID0gJzAgMXB4JztcblxuICAgICAgICB2YXIga2V5T24gPSBmYWxzZTtcblxuICAgICAgICB2YXIgb2xkS2V5LCBvbGRWYWx1ZTtcblxuICAgICAgICB2YXIgaW5wS2V5ID0gY3JlYXRlSW5wdXQoJ3BhcmFtZXRlciBuYW1lJyk7XG4gICAgICAgIGlucEtleS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIG9uS2V5UHJlc3MpO1xuXG4gICAgICAgIHZhciBkaXZpZGVyID0gY3JlYXRlRGl2aWRlcigpO1xuXG4gICAgICAgIHZhciBpbnBWYWx1ZSA9IGNyZWF0ZUlucHV0KCd2YWx1ZScpO1xuICAgICAgICAvLyBpbnBWYWx1ZS5zdHlsZS5jb2xvciA9ICdsaWdodGJsdWUnO1xuICAgICAgICBpbnBWYWx1ZS5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBpbnBWYWx1ZS5zdHlsZS5yaWdodCA9ICcwcHgnO1xuXG4gICAgICAgIHNob3dIaWRlVmFsdWUoa2V5T24pO1xuXG4gICAgICAgIGRlLmdldEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBLZXkudmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZGUuc2V0S2V5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHYgPT09IG9sZEtleSkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBvbGRLZXkgPSB2O1xuICAgICAgICAgICAgaW5wS2V5LnZhbHVlID0gdjtcbiAgICAgICAgICAgIGNoZWNrS2V5T24oKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBWYWx1ZS52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBkZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh2ID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHY7XG4gICAgICAgICAgICBpbnBWYWx1ZS52YWx1ZSA9IHY7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdC5wYXJlbnQpIHtcbiAgICAgICAgICAgIG9wdC5wYXJlbnQuYXBwZW5kQ2hpbGQoZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdC5rZXkpIHtcbiAgICAgICAgICAgIGRlLnNldEtleShvcHQua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQudmFsdWUpIHtcbiAgICAgICAgICAgIGRlLnNldFZhbHVlKG9wdC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0Lm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICBkZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvcHQub25DaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjaGVja0tleU9uKCk7XG5cbiAgICAgICAgICAgIHZhciBkZXRhaWwgPSB7fTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGRlLmdldEtleSgpICE9PSBvbGRLZXkpIHtcbiAgICAgICAgICAgICAgICBvbGRLZXkgPSBkZXRhaWwua2V5ID0gZGUuZ2V0S2V5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGUuZ2V0VmFsdWUoKSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGRldGFpbC52YWx1ZSA9IGRlLmdldFZhbHVlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRldGFpbCB8fCAna2V5JyBpbiBkZXRhaWwpIHtcblxuICAgICAgICAgICAgICAgIGRlLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCB7ZGV0YWlsOiBkZXRhaWx9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbktleVByZXNzKGUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGlucFZhbHVlLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja0tleU9uKCkge1xuXG4gICAgICAgICAgICB2YXIgb24gPSAhIWlucEtleS52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKG9uICE9PSBrZXlPbikge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGtleU9uID0gb247XG4gICAgICAgICAgICAgICAgc2hvd0hpZGVWYWx1ZShrZXlPbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaG93SGlkZVZhbHVlKHNob3cpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZGl2aWRlci5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/ICdpbmxpbmUnIDogJ25vbmUnO1xuICAgICAgICAgICAgaW5wVmFsdWUuc3R5bGUuZGlzcGxheSA9IHNob3cgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJztcbiAgICAgICAgICAgIGlucEtleS5zdHlsZS53aWR0aCA9IHNob3cgPyAnY2FsYyg1MCUgLSA1cHgpJyA6ICcxMDAlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0KHBsYWNlaG9sZGVyKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgaW5wLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICBpbnAucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIGlucC5zdHlsZS53aWR0aCA9ICc1MCUnO1xuICAgICAgICAgICAgaW5wLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIGlucC5zdHlsZS5mb250U2l6ZSA9IGFtZ3VpLkZPTlRfU0laRTtcbiAgICAgICAgICAgIGlucC5zdHlsZS5mb250RmFtaWx5ID0gYW1ndWkuRk9OVF9GQU1JTFk7XG4gICAgICAgICAgICBpbnAuc3R5bGUuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICAgICAgICAgIGlucC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgICAgICAgICBpbnAuc3R5bGUuY29sb3IgPSBhbWd1aS5jb2xvci50ZXh0O1xuICAgICAgICAgICAgaW5wLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGlucC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICAgICAgICAgIC8vICQoaW5wKS5hdXRvc2l6ZUlucHV0KHtzcGFjZTogMH0pO1xuICAgICAgICAgICAgZGUuYXBwZW5kQ2hpbGQoaW5wKTtcbiAgICAgICAgICAgIHJldHVybiBpbnA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEaXZpZGVyICgpIHtcblxuICAgICAgICAgICAgdmFyIGRpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBkaXZpZGVyLnRleHRDb250ZW50ID0gJzonO1xuICAgICAgICAgICAgZGl2aWRlci5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgICAgICAgICBkaXZpZGVyLnN0eWxlLndpZHRoID0gJzJweCc7XG4gICAgICAgICAgICBkaXZpZGVyLnN0eWxlLmZvbnRTaXplID0gYW1ndWkuRk9OVF9TSVpFO1xuICAgICAgICAgICAgZGl2aWRlci5zdHlsZS5mb250RmFtaWx5ID0gYW1ndWkuRk9OVF9GQU1JTFk7XG4gICAgICAgICAgICBkZS5hcHBlbmRDaGlsZChkaXZpZGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGU7XG4gICAgfSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlS2V5bGluZTogY3JlYXRlS2V5bGluZSxcbiAgICAgICAgY3JlYXRlS2V5OiBjcmVhdGVLZXlcbiAgICB9O1xufTtcblxuXG5mdW5jdGlvbiBjcmVhdGVLZXlsaW5lKG9wdCkge1xuXG4gICAgdmFyIGRlS2V5cyA9IFtdO1xuXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgZGUuc3R5bGUuaGVpZ2h0ID0gKG9wdC5oZWlnaHQgfHwgMjEpICsgJ3B4JztcbiAgICBkZS5zdHlsZS5iYWNrZ3JvdW5kID0gb3B0LmJhY2tncm91bmQgfHwgJ2dyZXknO1xuICAgIGRlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblxuICAgIHZhciBzdmdFYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICBzdmdFYXNlLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHN2Z0Vhc2Uuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHN2Z0Vhc2Uuc3R5bGUuZmlsbCA9ICdub25lJztcbiAgICBzdmdFYXNlLnN0eWxlLnN0cm9rZSA9ICd3aGl0ZSc7XG4gICAgc3ZnRWFzZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZGUuYXBwZW5kQ2hpbGQoc3ZnRWFzZSk7XG5cbiAgICBhbWd1aS5jYWxsT25BZGRlZChkZSwgcmVuZGVyRWFzZSk7XG5cbiAgICBkZS5hZGRLZXkgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICAgICAgdmFyIGRlS2V5ID0gYW1ndWkuY3JlYXRlS2V5KG9wdCk7XG4gICAgICAgIGRlS2V5cy5wdXNoKGRlS2V5KTtcblxuICAgICAgICBkZS5hcHBlbmRDaGlsZChkZUtleSk7XG5cbiAgICAgICAgZGVLZXkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVuZGVyRWFzZSk7XG4gICAgICAgIGRlS2V5LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZScsIG9uS2V5UmVtb3ZlKTtcbiAgICAgICAgcmVuZGVyRWFzZSgpO1xuXG4gICAgICAgIHJldHVybiBkZUtleTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc29ydEtleXMoKSB7XG5cbiAgICAgICAgZGVLZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gYS5vZmZzZXRMZWZ0IC0gYi5vZmZzZXRMZWZ0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbktleVJlbW92ZSAoKSB7XG5cbiAgICAgICAgdmFyIGRlS2V5ID0gdGhpcyxcbiAgICAgICAgICAgIGlkeCA9IGRlS2V5cy5pbmRleE9mKGRlS2V5KTtcblxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVLZXlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICBcbiAgICAgICAgZGVLZXkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVuZGVyRWFzZSk7XG4gICAgICAgIGRlS2V5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZScsIG9uS2V5UmVtb3ZlKTtcblxuICAgICAgICBpZiAoZGVLZXkucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZGVLZXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkZUtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJFYXNlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyRWFzZSgpIHtcblxuICAgICAgICBzb3J0S2V5cygpO1xuXG4gICAgICAgIHN2Z0Vhc2UuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgZGVLZXlzLmZvckVhY2goZnVuY3Rpb24gKGRlS2V5LCBpZHgpIHtcblxuICAgICAgICAgICAgaWYgKGlkeCA9PT0gZGVLZXlzLmxlbmd0aC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWFzZSA9IGRlS2V5LmVhc2U7XG5cbiAgICAgICAgICAgIGlmIChhbWd1aS5FQVNFMkJFWklFUi5oYXNPd25Qcm9wZXJ0eShlYXNlKSkge1xuICAgICAgICAgICAgICAgIGVhc2UgPSBhbWd1aS5FQVNFMkJFWklFUltlYXNlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJ4ID0gL2N1YmljLWJlemllclxcKFxccyooW1xcZFxcLl0rKVxccyosXFxzKihbXFxkXFwuLV0rKVxccyosXFxzKihbXFxkXFwuXSspXFxzKixcXHMqKFtcXGRcXC4tXSspXFxzKlxcKS8sXG4gICAgICAgICAgICAgICAgbSA9IHJ4LmV4ZWMoZWFzZSksXG4gICAgICAgICAgICAgICAgeCA9IGRlS2V5Lm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgdyA9IGRlS2V5c1tpZHgrMV0ub2Zmc2V0TGVmdCAtIHgsXG4gICAgICAgICAgICAgICAgaCA9IGRlLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyksXG4gICAgICAgICAgICAgICAgZCA9ICcnO1xuXG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGQgKz0gJ00nICsgeCArICcsJyArIGggKyAnICc7XG4gICAgICAgICAgICAgICAgZCArPSAnQycgKyAoeCArIHcqbVsxXSkgKyAnLCcgKyAoaCAtIGgqbVsyXSkgKyAnICc7XG4gICAgICAgICAgICAgICAgZCArPSAoeCArIHcqbVszXSkgKyAnLCcgKyAoaCAtIGgqbVs0XSkgKyAnICc7XG4gICAgICAgICAgICAgICAgZCArPSAoeCArIHcpICsgJywnICsgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvL1RPRE8gc3RlcHMoKVxuICAgICAgICAgICAgICAgIC8vIGQgKz0gJ00nICsgeCArICcsJyArIGggKyAnICc7XG4gICAgICAgICAgICAgICAgLy8gZCArPSAnTCcgKyAoeCArIHcpICsgJywwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBkKTtcbiAgICAgICAgICAgIHN2Z0Vhc2UuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgb3B0LmNvbG9yID0gb3B0LmNvbG9yIHx8ICcjNzcwMGZmJztcblxuICAgIHZhciBpc1VzZXJTZWxlY3RlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lID0gb3B0LnRpbWUgfHwgMCwgXG4gICAgICAgIHRpbWVzY2FsZSA9IG9wdC50aW1lc2NhbGUgfHwgMTtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgtNHB4KSc7XG5cbiAgICB2YXIga2V5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAga2V5LnN0eWxlLndpZHRoID0gJzAnO1xuICAgIGtleS5zdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAga2V5LnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgICBrZXkuc3R5bGUuYm9yZGVyV2lkdGggPSAnMjFweCA0cHggMCA0cHgnO1xuICAgIGtleS5zdHlsZS5ib3JkZXJDb2xvciA9IG9wdC5jb2xvciArICcgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQnO1xuICAgIGRlLmFwcGVuZENoaWxkKGtleSk7XG5cbiAgICBhbWd1aS5tYWtlRHJhZ2dhYmxlKHtcbiAgICAgICAgZGVUYXJnZXQ6IGRlLFxuICAgICAgICBvbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSAmJiAhZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgYW1ndWkuZW1pdCgnZGVzZWxlY3RBbGxLZXlzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGVVc2VyU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKG1kLCBteCkge1xuXG4gICAgICAgICAgICB2YXIgZGlmZiA9IG14IC0gbWQubXgsXG4gICAgICAgICAgICAgICAgZGlmZlRpbWUgPSAoZGlmZiAvIHRpbWVzY2FsZSkgLSBtZC5kcmFnZ2VkO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgbWQuZHJhZ2dlZCArPSBkaWZmVGltZTtcblxuICAgICAgICAgICAgYW1ndWkuZW1pdCgndHJhbnNsYXRlU2VsZWN0ZWRLZXlzJywgZGlmZlRpbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhbWd1aS5vbignZGVzZWxlY3RBbGxLZXlzJywgb25EZXNlbGVjdEFsbEtleXMpO1xuICAgIGFtZ3VpLm9uKCd0cmFuc2xhdGVTZWxlY3RlZEtleXMnLCBvblRyYW5zbGF0ZVNlbGVjdGVkS2V5cyk7XG5cbiAgICBkZS5zZXRUaW1lID0gZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICh0aW1lID09PSB0KSByZXR1cm47XG5cbiAgICAgICAgdGltZSA9IHQ7XG4gICAgICAgIHNldExlZnQoKTtcbiAgICAgICAgZGUuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKTtcblxuICAgICAgICBkZS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2hhbmdlVGltZScsIHtkZXRhaWw6IHt0aW1lOiB0aW1lfX0pKTtcbiAgICB9O1xuICAgIGRlLnNldFRpbWVzY2FsZSA9IGZ1bmN0aW9uKHRzKSB7XG5cbiAgICAgICAgaWYgKHRpbWVzY2FsZSA9PT0gdHMpIHJldHVybjtcblxuICAgICAgICB0aW1lc2NhbGUgPSB0cztcbiAgICAgICAgc2V0TGVmdCgpO1xuICAgICAgICBkZS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgIH07XG5cbiAgICBkZS5zZXRFYXNlID0gZnVuY3Rpb24oZWFzZSkge1xuXG4gICAgICAgIGlmIChkZS5lYXNlID09PSBlYXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gICBcblxuICAgICAgICBkZS5lYXNlID0gZWFzZTtcblxuICAgICAgICBkZS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgIH07XG5cbiAgICBkZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBhbWd1aS5yZW1vdmVMaXN0ZW5lcignZGVzZWxlY3RBbGxLZXlzJywgb25EZXNlbGVjdEFsbEtleXMpO1xuICAgICAgICBhbWd1aS5yZW1vdmVMaXN0ZW5lcigndHJhbnNsYXRlU2VsZWN0ZWRLZXlzJywgb25UcmFuc2xhdGVTZWxlY3RlZEtleXMpO1xuXG4gICAgICAgIGRlLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZW1vdmUnKSk7XG4gICAgfTtcblxuICAgIHNldExlZnQoKTtcbiAgICBkZS5zZXRFYXNlKG9wdC5lYXNlKTtcblxuICAgIHJldHVybiBkZTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgZnVuY3Rpb24gc2V0TGVmdCgpIHtcblxuICAgICAgICBkZS5zdHlsZS5sZWZ0ID0gKHRpbWUgKiB0aW1lc2NhbGUpICsgJ3B4JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVVc2VyU2VsZWN0ZWQoKSB7XG5cbiAgICAgICAgdXNlclNlbGVjdCghaXNVc2VyU2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVzZXJTZWxlY3Qob24pIHtcblxuICAgICAgICBpc1VzZXJTZWxlY3RlZCA9IG9uO1xuICAgICAgICBkZS5zdHlsZS5iYWNrZ3JvdW5kID0gaXNVc2VyU2VsZWN0ZWQgPyAnd2hpdGUnIDogJ25vbmUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRGVzZWxlY3RBbGxLZXlzKCkge1xuXG4gICAgICAgIHVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVHJhbnNsYXRlU2VsZWN0ZWRLZXlzKG9mZnNldCkge1xuXG4gICAgICAgIGlmIChpc1VzZXJTZWxlY3RlZCkge1xuXG4gICAgICAgICAgICBkZS5zZXRUaW1lKHRpbWUgKyBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFrZURyYWdnYWJsZTogbWFrZURyYWdnYWJsZSxcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gbWFrZURyYWdnYWJsZShvcHQpIHtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHZhciBtZDtcblxuICAgIG9wdC5kZVRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvd24pO1xuICAgIG9wdC5kZVRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25FbnRlcik7XG4gICAgb3B0LmRlVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcblxuICAgIGZ1bmN0aW9uIG9uRG93bihlKSB7XG5cbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBtZCA9IGNhbGwoJ29uRG93bicsIFtlXSkgfHwge307XG5cbiAgICAgICAgbWQubXggPSBlLmNsaWVudFg7XG4gICAgICAgIG1kLm15ID0gZS5jbGllbnRZO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVXApO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uVXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW92ZShlKSB7XG5cbiAgICAgICAgY2FsbCgnb25Nb3ZlJywgW21kLCBlLmNsaWVudFgsIGUuY2xpZW50WSwgZV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVXAoZSkge1xuXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uVXApO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uVXApO1xuXG4gICAgICAgIGNhbGwoJ29uVXAnLCBbbWQsIGUuY2xpZW50WCwgZS5jbGllbnRZLCBlXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FbnRlcigpIHtcblxuICAgICAgICBjYWxsKCdvbkVudGVyJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25MZWF2ZSgpIHtcbiAgICAgICAgXG4gICAgICAgIGNhbGwoJ29uTGVhdmUnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsKG5hbWUsIGFyZ3MpIHtcblxuICAgICAgICBpZiAobmFtZSBpbiBvcHQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG9wdFtuYW1lXS5hcHBseShvcHQudGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW1ndWk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9hbWd1aSkge1xuXG4gICAgYW1ndWkgPSBfYW1ndWk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGVSYW5nZTogY3JlYXRlUmFuZ2UsXG4gICAgICAgIG1ha2VTY3JvbGxhYmxlOiBtYWtlU2Nyb2xsYWJsZSxcbiAgICB9O1xufTtcblxuXG5cbmZ1bmN0aW9uIG1ha2VTY3JvbGxhYmxlKG9wdCkge1xuXG4gICAgdmFyIHBvcyA9IDAsXG4gICAgICAgIGRlQ29udHMgPSBvcHQuZGVDb250LFxuICAgICAgICBkZVRhcmdldHMgPSBvcHQuZGVUYXJnZXQsXG4gICAgICAgIGRlUmFuZ2UgPSBvcHQuZGVSYW5nZSxcbiAgICAgICAgcmV0ID0ge2Rpc3Bvc2U6IGRpc3Bvc2V9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlQ29udHMpKSBkZUNvbnRzID0gW2RlQ29udHNdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkZVRhcmdldHMpKSBkZVRhcmdldHMgPSBbZGVUYXJnZXRzXTtcblxuICAgIGRlQ29udHMuZm9yRWFjaChmdW5jdGlvbiAoZGVDKSB7XG5cbiAgICAgICAgZGVDLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVSYW5nZSkge1xuICAgICAgICBpbml0UmFuZ2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuXG4gICAgZnVuY3Rpb24gb25XaGVlbChlKSB7XG5cbiAgICAgICAgdmFyIHdheSA9IGUuZGVsdGFZLzMsXG4gICAgICAgICAgICBtYXhIID0gZ2V0VGFyZ2V0TWF4SCgpO1xuICAgICAgICBcbiAgICAgICAgcG9zID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4SCwgcG9zICsgd2F5KSk7XG5cbiAgICAgICAgaWYgKGRlUmFuZ2UpIHtcblxuICAgICAgICAgICAgZGVSYW5nZS5zZXRWYWx1ZShwb3MgLyBtYXhIKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbCgpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2VSYW5nZShlKSB7XG5cbiAgICAgICAgcG9zID0gZ2V0VGFyZ2V0TWF4SCgpICogZS5kZXRhaWwudmFsdWU7XG4gICAgICAgIHNjcm9sbCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbCgpIHtcblxuICAgICAgICBkZVRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoZGVUKSB7XG5cbiAgICAgICAgICAgIGRlVC5zdHlsZS50b3AgPSAtcG9zICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0TWF4SCgpIHtcblxuICAgICAgICB2YXIgY29udEggPSBNYXRoLm1heC5hcHBseShudWxsLCBkZUNvbnRzLnNsaWNlKCkubWFwKGdldEgpKSxcbiAgICAgICAgICAgIHRhcmdldEggPSBNYXRoLm1heC5hcHBseShudWxsLCBkZVRhcmdldHMuc2xpY2UoKS5tYXAoZ2V0SCkpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXRIIC0gY29udEg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SChkZSkge1xuXG4gICAgICAgIHJldHVybiBkZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFJhbmdlKCkge1xuXG4gICAgICAgIHZhciBzYXZlRGlzcGxheSA9IGRlUmFuZ2Uuc3R5bGUuZGlzcGxheSxcbiAgICAgICAgICAgIGlzU2hvd2luZyA9IGZhbHNlLFxuICAgICAgICAgICAgcmVmcmVzaFNldEk7XG5cbiAgICAgICAgZGVSYW5nZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgIGRlUmFuZ2UuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2VSYW5nZSk7XG5cbiAgICAgICAgcmVmcmVzaFNldEkgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBuZWVkc1JhbmdlID0gZ2V0VGFyZ2V0TWF4SCgpID4gMDtcblxuICAgICAgICAgICAgaWYgKGlzU2hvd2luZyAhPT0gbmVlZHNSYW5nZSkge1xuXG4gICAgICAgICAgICAgICAgaXNTaG93aW5nID0gbmVlZHNSYW5nZTtcblxuICAgICAgICAgICAgICAgIGRlUmFuZ2Uuc3R5bGUuZGlzcGxheSA9IGlzU2hvd2luZyA/IHNhdmVEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAzMTIpOyBcblxuICAgICAgICB2YXIgc2F2ZURpc3Bvc2UgPSByZXQuZGlzcG9zZTtcbiAgICAgICAgcmV0LmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlICgpIHtcblxuICAgICAgICAgICAgc2F2ZURpc3Bvc2UoKTtcblxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWZyZXNoU2V0SSk7XG5cbiAgICAgICAgICAgIGRlUmFuZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2VSYW5nZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuICAgICAgICBkZUNvbnRzLmZvckVhY2goZnVuY3Rpb24gKGRlQykge1xuXG4gICAgICAgICAgICBkZUMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVSYW5nZShvcHQpIHtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgXG4gICAgdmFyIHZhbHVlID0gMCwgY3Vyc29yV2lkdGggPSAwLCBpc1ZlcnRpY2FsID0gISFvcHQudmVydGljYWw7XG5cbiAgICB2YXIgZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgZGUuc3R5bGUud2lkdGggPSBvcHQud2lkdGggfHwgJzEycHgnO1xuICAgIGRlLnN0eWxlLmhlaWdodCA9IG9wdC5oZWlnaHQgfHwgJzE0MHB4JztcbiAgICBkZS5zdHlsZS5iYWNrZ3JvdW5kID0gYW1ndWkuY29sb3IuYmcxO1xuICAgIGRlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcblxuICAgIHZhciBkZUN1cnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlQ3Vyc29yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkZUN1cnNvci5zdHlsZVtkKCdsZWZ0JywndG9wJyldID0gJzAnO1xuICAgIGRlQ3Vyc29yLnN0eWxlW2QoJ3JpZ2h0JywnYm90dG9tJyldID0gJzAnO1xuICAgIGRlQ3Vyc29yLnN0eWxlLm1hcmdpbiA9IGQoJ2F1dG8gMCcsJzAgYXV0bycpO1xuICAgIGRlQ3Vyc29yLnN0eWxlLmJhY2tncm91bmQgPSBhbWd1aS5jb2xvci5iZzM7XG4gICAgZGVDdXJzb3Iuc3R5bGVbZCgnd2lkdGgnLCdoZWlnaHQnKV0gPSBvcHQuY3Vyc29ySGVpZ2h0IHx8ICcxMDAlJztcbiAgICBkZS5hcHBlbmRDaGlsZChkZUN1cnNvcik7XG5cbiAgICBpZiAob3B0LnBhcmVudCkge1xuICAgICAgICBvcHQucGFyZW50LmFwcGVuZENoaWxkKGRlKTtcbiAgICB9XG5cbiAgICBkZS5zZXRDdXJzb3JXaWR0aCA9IGZ1bmN0aW9uICh3KSB7XG5cbiAgICAgICAgZGVDdXJzb3Iuc3R5bGVbZCgnaGVpZ2h0Jywnd2lkdGgnKV0gPSB3ICsgJ3B4JztcbiAgICAgICAgY3Vyc29yV2lkdGggPSB3O1xuICAgIH07XG4gICAgZGUuc2V0Q3Vyc29yV2lkdGgob3B0LmN1cnNvcldpZHRoIHx8IDEyKTsgICBcblxuICAgIGFtZ3VpLm1ha2VEcmFnZ2FibGUoe1xuICAgICAgICBkZVRhcmdldDogZGUsXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKG1kLCBteCwgbXkpIHtcblxuICAgICAgICAgICAgdmFyIGJyID0gZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgcCA9IGQobXksIG14KSAtIChkKGJyLnRvcCwgYnIubGVmdCkgKyBjdXJzb3JXaWR0aC8yKSxcbiAgICAgICAgICAgICAgICBmdyA9IGQoYnIuaGVpZ2h0LCBici53aWR0aCkgLSBjdXJzb3JXaWR0aCxcbiAgICAgICAgICAgICAgICBwb3MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwIC8gZncpKTtcblxuICAgICAgICAgICAgZGUuc2V0VmFsdWUocG9zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodikge1xuXG4gICAgICAgIGlmICh2ID09PSB2YWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgXG4gICAgICAgIHZhciB3aWR0aCA9IGRlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2QoJ2hlaWdodCcsJ3dpZHRoJyldO1xuICAgICAgICBkZUN1cnNvci5zdHlsZVtkKCd0b3AnLCdsZWZ0JyldID0gKCh3aWR0aCAtIGN1cnNvcldpZHRoKSAqIHZhbHVlKSArICdweCc7XG5cbiAgICAgICAgZGUuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZScsIHtkZXRhaWw6IHt2YWx1ZTogdmFsdWV9fSkpO1xuICAgIH07XG5cbiAgICBkZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGQgKHZlcnRpY2FsLCBob3Jpc29udGFsKSB7XG5cbiAgICAgICAgcmV0dXJuIGlzVmVydGljYWwgPyB2ZXJ0aWNhbCA6IGhvcmlzb250YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkVG9vbHRpcDogYWRkVG9vbHRpcCxcbiAgICB9O1xufTtcblxuXG5cbmZ1bmN0aW9uIGFkZFRvb2x0aXAob3B0KSB7XG5cbiAgICB2YXIgc2hvd1NldFQsIGRlbGF5ID0gNDIzLCBteCA9IDAsIG15ID0gMDtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlLnRleHRDb250ZW50ID0gb3B0LnRleHQ7XG4gICAgZGUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGRlLnN0eWxlLnBhZGRpbmcgPSAnMTJweCc7XG4gICAgZGUuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIGRlLnN0eWxlLmJhY2tncm91bmQgPSBhbWd1aS5jb2xvci5vdmVybGF5O1xuICAgIGRlLnN0eWxlLmNvbG9yID0gYW1ndWkuY29sb3IudGV4dDtcblxuICAgIG9wdC5kZVRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25NRW50ZXIpO1xuXG4gICAgZnVuY3Rpb24gb25NRW50ZXIoZSkge1xuXG4gICAgICAgIG9wdC5kZVRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1Nb3ZlKTtcbiAgICAgICAgb3B0LmRlVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1MZWF2ZSk7XG4gICAgICAgIG9wdC5kZVRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1MZWF2ZSk7XG5cbiAgICAgICAgb25NTW92ZShlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1MZWF2ZSgpIHtcblxuICAgICAgICBvcHQuZGVUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25NTW92ZSk7XG4gICAgICAgIG9wdC5kZVRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25NTGVhdmUpO1xuICAgICAgICBvcHQuZGVUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25NTGVhdmUpO1xuXG4gICAgICAgIGhpZGUoKTtcbiAgICAgICAgY2xlYXJTaG93U2V0VCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTU1vdmUoZSkge1xuXG4gICAgICAgIGhpZGUoKTtcbiAgICAgICAgcmVmcmVzaFNob3dTZXRUKCk7XG4gICAgICAgIG14ID0gZS5jbGllbnRYO1xuICAgICAgICBteSA9IGUuY2xpZW50WTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZyZXNoU2hvd1NldFQoKSB7XG5cbiAgICAgICAgY2xlYXJTaG93U2V0VCgpO1xuICAgICAgICBzaG93U2V0VCA9IHNldFRpbWVvdXQoc2hvdywgZGVsYXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyU2hvd1NldFQoKSB7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHNob3dTZXRUKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93KCkge1xuXG4gICAgICAgIGFtZ3VpLmRlT3ZlcmxheUNvbnQuYXBwZW5kQ2hpbGQoZGUpO1xuICAgICAgICBhbWd1aS5wbGFjZVRvUG9pbnQoZGUsIG14LCBteSwgb3B0LnNpZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhpZGUoKSB7XG5cbiAgICAgICAgaWYgKGRlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZGUpO1xuICAgICAgICB9XG4gICAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfYW1ndWkpIHtcblxuICAgIGFtZ3VpID0gX2FtZ3VpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGxhY2VUb1BvaW50OiBwbGFjZVRvUG9pbnQsXG4gICAgICAgIGNhbGxPbkFkZGVkOiBjYWxsT25BZGRlZCxcbiAgICB9O1xufTtcblxuXG5mdW5jdGlvbiBwbGFjZVRvUG9pbnQoZGUsIG14LCBteSwgd2F5KSB7XG5cbiAgICBhbWd1aS5jYWxsT25BZGRlZChkZSwgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBweCA9IDAsIHB5ID0gMCxcbiAgICAgICAgICAgIGJyID0gZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICB3ID0gYnIud2lkdGgsXG4gICAgICAgICAgICBoID0gYnIuaGVpZ2h0LFxuICAgICAgICAgICAgd3cgPSB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIHdoID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgIHdheSA9IHdheSB8fCAnbGVmdCc7XG5cbiAgICAgICAgc3dpdGNoICh3YXkpIHtcblxuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBweCA9IG14IC0gKHcgLyAyKTtcbiAgICAgICAgICAgICAgICBweSA9IG15IC0gaDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHB4ID0gbXg7XG4gICAgICAgICAgICAgICAgcHkgPSBteSAtIChoIC8gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgcHggPSBteCAtICh3IC8gMik7XG4gICAgICAgICAgICAgICAgcHkgPSBteTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHB4ID0gbXggLSB3O1xuICAgICAgICAgICAgICAgIHB5ID0gbXkgLSAoaCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB5IDwgMCkgcHkgPSAwO1xuICAgICAgICBpZiAocHggKyB3ID4gd3cpIHB4IC09IChweCArIHcpIC0gd3c7XG4gICAgICAgIGlmIChweSArIGggPiB3aCkgcHkgLT0gKHB5ICsgaCkgLSB3aDtcbiAgICAgICAgaWYgKHB4IDwgMCkgcHggPSAwO1xuXG4gICAgICAgIGRlLnN0eWxlLmxlZnQgPSBweCArICdweCc7XG4gICAgICAgIGRlLnN0eWxlLnRvcCA9IHB5ICsgJ3B4JztcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsbE9uQWRkZWQoZGUsIGNiLCB0aGlzQXJnKSB7XG5cbiAgICB2YXIgc2V0SSA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAoY2hlY2soZGUpKSB7XG5cbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc2V0SSk7XG5cbiAgICAgICAgICAgIGNiLmNhbGwodGhpc0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSwgMjM0KTtcbiAgICBcbiAgICBmdW5jdGlvbiBjaGVjayAobm9kZSkge1xuXG4gICAgICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUpIHtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDkgfHwgbm9kZS5ub2RlVHlwZSA9PT0gMTEpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiYW1ndWlcIixcbiAgXCJjc3NfcHJlZml4X3RleHRcIjogXCJpY29uLVwiLFxuICBcImNzc191c2Vfc3VmZml4XCI6IGZhbHNlLFxuICBcImhpbnRpbmdcIjogdHJ1ZSxcbiAgXCJ1bml0c19wZXJfZW1cIjogMTAwMCxcbiAgXCJhc2NlbnRcIjogODUwLFxuICBcImdseXBoc1wiOiBbXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI1M2VkODU3MDIyNTU4MTI2OWNkN2VmZjU3OTVlOGJlYVwiLFxuICAgICAgXCJjc3NcIjogXCJlbW8tdW5oYXBweVwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDEyLFxuICAgICAgXCJzcmNcIjogXCJmb250ZWxpY29cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI2OGUyOThmZjJkOGIyNWRkN2Y2NDdlZDY0ZjVhZTY5MFwiLFxuICAgICAgXCJjc3NcIjogXCJlbW8tc3VycHJpc2VkXCIsXG4gICAgICBcImNvZGVcIjogNTk0MzIsXG4gICAgICBcInNyY1wiOiBcImZvbnRlbGljb1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcIjhjZTczMjY4ODU4NzkwOWFkMGE5ZDgzMjNlYWNhOGFkXCIsXG4gICAgICBcImNzc1wiOiBcIm1hcnF1ZWVcIixcbiAgICAgIFwiY29kZVwiOiA1OTQxMyxcbiAgICAgIFwic3JjXCI6IFwiZm9udGVsaWNvXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiNTIxMWFmNDc0ZDNhOTg0OGY2N2Y5NDVlMmNjYWYxNDNcIixcbiAgICAgIFwiY3NzXCI6IFwiY2FuY2VsXCIsXG4gICAgICBcImNvZGVcIjogNTk0MjcsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiNDRlMDQ3MTVhZWNiY2E3ZjI2NmExN2Q1YTc4NjNjNjhcIixcbiAgICAgIFwiY3NzXCI6IFwicGx1c1wiLFxuICAgICAgXCJjb2RlXCI6IDU5NDMxLFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcIjFhNWNmYTE4NjY0N2U4YzkyOWMyYjE3YjlmYzRkYWMxXCIsXG4gICAgICBcImNzc1wiOiBcInBsdXMtc3F1YXJlZFwiLFxuICAgICAgXCJjb2RlXCI6IDU5Mzk4LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcImM1ZmQzNDljYmQzZDIzZTRhZGUzMzM3ODljMjljNzI5XCIsXG4gICAgICBcImNzc1wiOiBcImV5ZVwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDM4LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcIjdmZDY4M2IyYzUxOGNlYjllNWZhNjc1N2YyMjc2ZmFhXCIsXG4gICAgICBcImNzc1wiOiBcImV5ZS1vZmZcIixcbiAgICAgIFwiY29kZVwiOiA1OTQzOSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI5YTc2YmMxMzVlYWMxN2QyYzhiOGFkNGE1Nzc0ZmM4N1wiLFxuICAgICAgXCJjc3NcIjogXCJkb3dubG9hZFwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDE0LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcImY1OTk5YTAxMmZjMzc1MjM4NjYzNWVjMDJhODU4NDQ3XCIsXG4gICAgICBcImNzc1wiOiBcImRvd25sb2FkLWNsb3VkXCIsXG4gICAgICBcImNvZGVcIjogMTE1LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcImRlMmZjN2E1Yzk4NmFiOGM2MjJmNjM0NTVkN2NmODE0XCIsXG4gICAgICBcImNzc1wiOiBcInVwbG9hZC1jbG91ZFwiLFxuICAgICAgXCJjb2RlXCI6IDExNyxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI3MDM0ZTRkMjI4NjZhZjgyYmVmODExZjUyZmIxYmE0NlwiLFxuICAgICAgXCJjc3NcIjogXCJjb2RlXCIsXG4gICAgICBcImNvZGVcIjogNTk0MTcsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiZjQ4YWU1NGFkZmIyN2Q4YWRhNTNkMGZkOWUzNGVlMTBcIixcbiAgICAgIFwiY3NzXCI6IFwidHJhc2hcIixcbiAgICAgIFwiY29kZVwiOiA1OTM5NixcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIxYjVhNWQ3YjdlM2M3MTQzN2Y1YTI2YmVmZGQwNDVlZFwiLFxuICAgICAgXCJjc3NcIjogXCJkb2NcIixcbiAgICAgIFwiY29kZVwiOiA1OTQwNSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIyNjYxM2EyZTZiYzQxNTkzYzU0YmVhZDQ2ZjhjOGVlM1wiLFxuICAgICAgXCJjc3NcIjogXCJmaWxlLWNvZGVcIixcbiAgICAgIFwiY29kZVwiOiA1OTQwMCxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJiMDkxYThiZDBmZGFkZTE3NDk1MWYxN2Q5MzZmNTFlNFwiLFxuICAgICAgXCJjc3NcIjogXCJmb2xkZXItZW1wdHlcIixcbiAgICAgIFwiY29kZVwiOiA1OTQwMyxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI2NTMzYmRjMTZhYjIwMWViM2YzYjI3Y2U5ODljYWIzM1wiLFxuICAgICAgXCJjc3NcIjogXCJmb2xkZXItb3Blbi1lbXB0eVwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDA0LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcIjU1OTY0N2E2ZjQzMGIzYWVhZGJlY2Q2NzE5NDQ1MWRkXCIsXG4gICAgICBcImNzc1wiOiBcIm1lbnVcIixcbiAgICAgIFwiY29kZVwiOiA1OTQ0MCxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJlOTk0NjFhYmZlZjM5MjM1NDZkYThkNzQ1MzcyYzk5NVwiLFxuICAgICAgXCJjc3NcIjogXCJjb2dcIixcbiAgICAgIFwiY29kZVwiOiA1OTM5MyxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI1YmIxMDNjZDI5ZGU3N2UwZTA2YTUyNjM4NTI3YjU3NVwiLFxuICAgICAgXCJjc3NcIjogXCJ3cmVuY2hcIixcbiAgICAgIFwiY29kZVwiOiA1OTQxNSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIyMWI0MmQzYzNlNmJlNDRjM2NjM2Q3MzA0MmZhYTIxNlwiLFxuICAgICAgXCJjc3NcIjogXCJzbGlkZXJzXCIsXG4gICAgICBcImNvZGVcIjogNTk0MTYsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiZTU5NGZjNmU1ODcwYjRhYjdlNDlmNTI1NzFkNTI1NzdcIixcbiAgICAgIFwiY3NzXCI6IFwicmVzaXplLWZ1bGxcIixcbiAgICAgIFwiY29kZVwiOiA1OTQzNyxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIzYzI0ZWUzM2M5NDg3YmJmMTg3OTZjYTZkZmZhMTkwNVwiLFxuICAgICAgXCJjc3NcIjogXCJyZXNpemUtc21hbGxcIixcbiAgICAgIFwiY29kZVwiOiA1OTQzNixcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJjNTMwNjhmZTIxYzg0MTBiMGEwOThiNGM1MmMzZDM3ZVwiLFxuICAgICAgXCJjc3NcIjogXCJkb3duLWNpcmNsZWQyXCIsXG4gICAgICBcImNvZGVcIjogNTk0MzMsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiZjNmOTBjOGM4OTc5NWRhMzBmNzQ0NDYzNDQ3NmVhNGZcIixcbiAgICAgIFwiY3NzXCI6IFwiYW5nbGUtbGVmdFwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDM0LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcIjdiZjE0MjgxYWY1NjMzYTU5N2Y4NWIwNjFlZjFjZmI5XCIsXG4gICAgICBcImNzc1wiOiBcImFuZ2xlLXJpZ2h0XCIsXG4gICAgICBcImNvZGVcIjogNTkzOTQsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiNWRlOTM3MDg0NmEyNjk0N2UwM2Y2MzE0MmEzZjFjMDdcIixcbiAgICAgIFwiY3NzXCI6IFwiYW5nbGUtdXBcIixcbiAgICAgIFwiY29kZVwiOiA1OTQzNSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJlNGRkZTE5OTJmNzg3MTYzZTJlMmI1MzRiOGM4MDY3ZFwiLFxuICAgICAgXCJjc3NcIjogXCJhbmdsZS1kb3duXCIsXG4gICAgICBcImNvZGVcIjogNTkzOTUsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiYmM3MWY0YzZlNTMzOTRkNWJhNDZiMDYzMDQwMDE0ZjFcIixcbiAgICAgIFwiY3NzXCI6IFwiY3dcIixcbiAgICAgIFwiY29kZVwiOiA1OTQyNSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJmOWMzMjA1ZGYyNmU3Nzc4YWJhYzg2MTgzYWVmZGM5OVwiLFxuICAgICAgXCJjc3NcIjogXCJjY3dcIixcbiAgICAgIFwiY29kZVwiOiA1OTQyNixcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJkNDgxNmMwODQ1YWE0Mzc2NzIxM2Q0NTU3NGIzYjE0NVwiLFxuICAgICAgXCJjc3NcIjogXCJoaXN0b3J5XCIsXG4gICAgICBcImNvZGVcIjogNTk0MTgsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiY2UwNmI1ODA1MTIwZDBjMmY4ZDYwY2QzZjFhNGZkYjVcIixcbiAgICAgIFwiY3NzXCI6IFwicGxheVwiLFxuICAgICAgXCJjb2RlXCI6IDU5Mzk3LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcIjBiMjgwNTBiYWM5ZDNmYWNmMmYwMjI2ZGI2NDNlY2UwXCIsXG4gICAgICBcImNzc1wiOiBcInBhdXNlXCIsXG4gICAgICBcImNvZGVcIjogNTkzOTksXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiODc3MjMzMWE5ZmVjOTgzY2RiNWQ3MjkwMmE2ZjllMGVcIixcbiAgICAgIFwiY3NzXCI6IFwic2Npc3NvcnNcIixcbiAgICAgIFwiY29kZVwiOiA1OTQyNCxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIxMzAzODBlNDgxYTdkZWZjNjkwZGZiMjQxMjNhMWYwY1wiLFxuICAgICAgXCJjc3NcIjogXCJjaXJjbGVcIixcbiAgICAgIFwiY29kZVwiOiA1OTQ0MixcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI0MjJlMDdlNWFmYjgwMjU4YTljNGVkMTcwNjQ5OGY4YVwiLFxuICAgICAgXCJjc3NcIjogXCJjaXJjbGUtZW1wdHlcIixcbiAgICAgIFwiY29kZVwiOiA1OTQ0MSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIyNjZkNWQ5YWRmMTVhNjE4MDA0NzdhNWFjZjlhNDQ2MlwiLFxuICAgICAgXCJjc3NcIjogXCJjaGFydC1iYXJcIixcbiAgICAgIFwiY29kZVwiOiA1OTQxOSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJmNDQ0NWZlYjU1NTIxMjgzNTcyZWU4OGJjMzA0ZjkyOFwiLFxuICAgICAgXCJjc3NcIjogXCJmbG9wcHlcIixcbiAgICAgIFwiY29kZVwiOiA1OTQwMSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIzZTY3NDk5NWNhY2MyYjA5NjkyYzA5NmVhN2ViNjE2NVwiLFxuICAgICAgXCJjc3NcIjogXCJtZWdhcGhvbmVcIixcbiAgICAgIFwiY29kZVwiOiA1OTQzMCxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCI3OTVlZmQwN2NkNTIwNWI1ODljODgzOTE2YTc2Y2ZmMFwiLFxuICAgICAgXCJjc3NcIjogXCJoZGRcIixcbiAgICAgIFwiY29kZVwiOiA1OTQxMSxcbiAgICAgIFwic3JjXCI6IFwiZm9udGF3ZXNvbWVcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCJmYTEwNzc3YjJkODhjYzY0Y2Q2ZTRmMjZlZjBlNTI2NFwiLFxuICAgICAgXCJjc3NcIjogXCJ0ZXJtaW5hbFwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDI5LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcImM5MmFkMzAyOGFjY2U5ZDUxYmFlMGFjODJmNWRlOGEyXCIsXG4gICAgICBcImNzc1wiOiBcImJ1bGxzZXllXCIsXG4gICAgICBcImNvZGVcIjogNTk0MDgsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiNTU2MDVjYTc5YTY1ZGVmMWE5YzMwMDAzN2ZmMWQwZDVcIixcbiAgICAgIFwiY3NzXCI6IFwicGF3XCIsXG4gICAgICBcImNvZGVcIjogNTk0MjAsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiZmJlZGUzYzU1ODQyODJhMGU5YjEzMTkyNmRmZjcxZGFcIixcbiAgICAgIFwiY3NzXCI6IFwiY3ViZVwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDI4LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcImM1MzQxNWZiZDI2OTUwMzNiZDcxODBkN2E5ZWQ0OTM0XCIsXG4gICAgICBcImNzc1wiOiBcInJlYmVsXCIsXG4gICAgICBcImNvZGVcIjogNTk0MjEsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiNjYzMmNlMTAxOWY5MTE1ODQyMzM1NjIyY2I1NWY0ZTdcIixcbiAgICAgIFwiY3NzXCI6IFwiZW1waXJlXCIsXG4gICAgICBcImNvZGVcIjogNTk0MjIsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiOWUzNGEwNDdmZWU5NDllYWU5YjZlNjEzZDc5MGQ2Y2ZcIixcbiAgICAgIFwiY3NzXCI6IFwiZHJvcGJveFwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDA5LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcImU3Y2I3MmExN2YzYjIxZTM1NzZmMzVjM2YwYTc2MzliXCIsXG4gICAgICBcImNzc1wiOiBcImdpdFwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDA2LFxuICAgICAgXCJzcmNcIjogXCJmb250YXdlc29tZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcIjJjMmNhOGE5NmIzMTc4MWM5YzgwNTZkMDVjMGE4OTgwXCIsXG4gICAgICBcImNzc1wiOiBcImJsYW5rXCIsXG4gICAgICBcImNvZGVcIjogNTk0MDcsXG4gICAgICBcInNyY1wiOiBcImZvbnRhd2Vzb21lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwidWlkXCI6IFwiOWM3ZmQ3NjM3YTQxYjU5YTM1OGNiNzA4OTNmOTQ1YTVcIixcbiAgICAgIFwiY3NzXCI6IFwicm9ja2V0XCIsXG4gICAgICBcImNvZGVcIjogNTk0MjMsXG4gICAgICBcInNyY1wiOiBcImVudHlwb1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcInVpZFwiOiBcImU1MzZjODBlMDExMzY2MDQ2MzYwZjVmZmU2NjlkYmZkXCIsXG4gICAgICBcImNzc1wiOiBcImZvbGRlci1hZGRcIixcbiAgICAgIFwiY29kZVwiOiA1OTQwMixcbiAgICAgIFwic3JjXCI6IFwidHlwaWNvbnNcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIzNjY1MTBlY2ZiMDhjZDAxMTAxMzRiMWVhOTA3ZmI4MVwiLFxuICAgICAgXCJjc3NcIjogXCJldmVybm90ZVwiLFxuICAgICAgXCJjb2RlXCI6IDU5NDEwLFxuICAgICAgXCJzcmNcIjogXCJ6b2NpYWxcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJ1aWRcIjogXCIyNzJlMDhlMGUxNjIyNmFhZGY5NGRjYmYzM2FhYjJiMlwiLFxuICAgICAgXCJjc3NcIjogXCJrZXlcIixcbiAgICAgIFwiY29kZVwiOiA1OTM5MixcbiAgICAgIFwic3JjXCI6IFwiZWx1c2l2ZVwiXG4gICAgfVxuICBdXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBDaHJvbmljbGVyKCkge1xuXG4gICAgdGhpcy5fc3RhY2sgPSBbXSwgXG4gICAgdGhpcy5fcG9pbnRlciA9IC0xO1xuICAgIHRoaXMuX2NoYWlucyA9IFtdO1xuICAgIHRoaXMuX2ZsYWdDb3VudGVyID0gMDtcbn1cblxudmFyIHAgPSBDaHJvbmljbGVyLnByb3RvdHlwZTtcblxucC51bmRvID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXIgPiAtMSkge1xuXG4gICAgICAgIGNhbGwodGhpcy5fc3RhY2tbdGhpcy5fcG9pbnRlci0tXS51bmRvKTtcbiAgICB9XG59O1xuXG5wLnJlZG8gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5fcG9pbnRlciA8IHRoaXMuX3N0YWNrLmxlbmd0aCAtIDEpIHtcblxuICAgICAgICBjYWxsKHRoaXMuX3N0YWNrWysrdGhpcy5fcG9pbnRlcl0ucmVkbyk7XG4gICAgfVxufTtcblxucC51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAodGhpcy5fcG9pbnRlciA8IDApIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJlYyA9IHRoaXMuX3N0YWNrW3RoaXMuX3BvaW50ZXItLV07XG5cbiAgICBpZiAodHlwZW9mKHJlYykgPT09ICdudW1iZXInKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0RmxhZ0lkeCA9IHRoaXMuX3N0YWNrLmluZGV4T2YocmVjIC0gMSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0RmxhZ0lkeCAhPT0gLTEpIHtcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BvaW50ZXIgIT09IHN0YXJ0RmxhZ0lkeCkge1xuXG4gICAgICAgICAgICAgICAgY2FsbCh0aGlzLl9zdGFja1t0aGlzLl9wb2ludGVyLS1dLnVuZG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhbGwocmVjLnVuZG8pO1xuICAgIH1cbn07XG5cbnAucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXIgPj0gdGhpcy5fc3RhY2subGVuZ3RoIC0gMSkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVjID0gdGhpcy5fc3RhY2tbKyt0aGlzLl9wb2ludGVyXTtcbiAgICBcbiAgICBpZiAodHlwZW9mKHJlYykgPT09ICdudW1iZXInKSB7XG5cbiAgICAgICAgdmFyIGVuZEZsYWdJZHggPSB0aGlzLl9zdGFjay5pbmRleE9mKHJlYyArIDEpO1xuXG4gICAgICAgIGlmIChlbmRGbGFnSWR4ICE9PSAtMSkge1xuXG4gICAgICAgICAgICB3aGlsZSAoKyt0aGlzLl9wb2ludGVyICE9PSBlbmRGbGFnSWR4KSB7XG5cbiAgICAgICAgICAgICAgICBjYWxsKHRoaXMuX3N0YWNrW3RoaXMuX3BvaW50ZXJdLnJlZG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsKHJlYy5yZWRvKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsKHJlZykge1xuXG4gICAgaWYgKHR5cGVvZiByZWcgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICByZWcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZ1swXS5hcHBseShyZWdbMV0sIHJlZy5zbGljZSgyKSk7XG4gICAgfVxufVxuXG5wLnNhdmUgPSBmdW5jdGlvbiAodW5kbywgcmVkbykge1xuXG4gICAgdmFyIHJlZyA9IHt1bmRvOiB1bmRvLCByZWRvOiByZWRvfTtcblxuICAgIHRoaXMuX3NhdmVSZWcocmVnKTtcblxuICAgIHJldHVybiByZWc7XG59O1xuXG5cbnAuX3NhdmVSZWcgPSBmdW5jdGlvbiAocmVnKSB7XG5cbiAgICB0aGlzLl9zdGFjay5zcGxpY2UoKyt0aGlzLl9wb2ludGVyLCB0aGlzLl9zdGFjay5sZW5ndGgsIHJlZyk7XG59O1xuXG5cblxuXG5cblxuXG5cbnAuc3RhcnRGbGFnID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fc2F2ZVJlZyh0aGlzLl9mbGFnQ291bnRlcisrKTtcbiAgICByZXR1cm4gdGhpcy5fZmxhZ0NvdW50ZXIrKztcbn07XG5cbnAuZW5kRmxhZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG5cbiAgICB0aGlzLl9zYXZlUmVnKGZsYWcpO1xufTtcblxucC53cmFwID0gZnVuY3Rpb24gKGZuLCBjdHgpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGVuZEZsYWcgPSB0aGlzLnN0YXJ0RmxhZygpO1xuXG4gICAgICAgIGZuLmFwcGx5KGN0eCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAgMikpO1xuXG4gICAgICAgIHRoaXMuZW5kRmxhZyhlbmRGbGFnKTtcbiAgICB9LmJpbmQodGhpcyk7XG59O1xuXG5cblxuXG5cblxuXG5cbnAuc2F2ZUNoYWluID0gZnVuY3Rpb24gKGlkLCB1bmRvLCByZWRvLCBkZWxheSkge1xuXG4gICAgdmFyIGNoYWluID0gdGhpcy5nZXRDaGFpbihpZCk7XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgICAgXG4gICAgICAgIGNoYWluLnJlZy5yZWRvID0gcmVkbztcbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgY2hhaW4gPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICByZWc6IHRoaXMuc2F2ZSh1bmRvLCByZWRvKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaGFpbnMucHVzaChjaGFpbik7XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsYXkgPSAzMTI7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNoYWluLnRpZCk7XG4gICAgY2hhaW4udGlkID0gc2V0VGltZW91dCh0aGlzLmNsb3NlQ2hhaW4uYmluZCh0aGlzLCBpZCksIGRlbGF5KTtcbn07XG5cbnAuY2xvc2VDaGFpbiA9IGZ1bmN0aW9uIChpZCkge1xuXG4gICAgdmFyIGNoYWluID0gdGhpcy5nZXRDaGFpbihpZCk7XG5cbiAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoY2hhaW4udGlkKTtcbiAgICB0aGlzLl9jaGFpbnMuc3BsaWNlKHRoaXMuX2NoYWlucy5pbmRleE9mKGNoYWluKSwgMSk7XG59O1xuXG5wLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgd2hpbGUgKHRoaXMuX2NoYWlucy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNoYWluKHRoaXMuX2NoYWluc1swXS5pZCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX3N0YWNrLmxlbmd0aCA9IDAsIFxuICAgIHRoaXMuX3BvaW50ZXIgPSAtMTtcbn07XG5cbnAuZ2V0Q2hhaW4gPSBmdW5jdGlvbiAoaWQpIHtcblxuICAgIHJldHVybiB0aGlzLl9jaGFpbnMuZmluZChmdW5jdGlvbiAoY2hhaW4pIHtcblxuICAgICAgICByZXR1cm4gY2hhaW4uaWQgPT09IGlkO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaHJvbmljbGVyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgYW1ndWkgPSByZXF1aXJlKCcuLi9hbWd1aScpO1xuXG5mdW5jdGlvbiBEaWFsb2dGZWF0dXJlRG9lc250RXhpdHMgKCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9uYW1lID0gJyc7XG4gICAgdGhpcy5fc2VsZWN0b3JzID0gW107XG5cbiAgICB0aGlzLl9vbkNsaWNrT2sgPSB0aGlzLl9vbkNsaWNrT2suYmluZCh0aGlzKTsgXG59XG5cbmluaGVyaXRzKERpYWxvZ0ZlYXR1cmVEb2VzbnRFeGl0cywgRXZlbnRFbWl0dGVyKTtcbnZhciBwID0gRGlhbG9nRmVhdHVyZURvZXNudEV4aXRzLnByb3RvdHlwZTtcblxucC5zaG93ID0gZnVuY3Rpb24gKG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdGhpcy5fY3JlYXRlRGlhbG9nKCk7XG5cbiAgICB0aGlzLmRvbUVsZW0uc2hvd01vZGFsKCk7XG59O1xuXG5wLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRvbUVsZW0uY2xvc2UoKTtcbn07XG5cbnAuX2NyZWF0ZURpYWxvZyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLl9pc0RpYWxvZ0NyZWF0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9pc0RpYWxvZ0NyZWF0ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5fY3JlYXRlQ29udGVudCgpO1xuICAgIFxuICAgIHRoaXMuZG9tRWxlbSA9IGFtZ3VpLmNyZWF0ZURpYWxvZyh7XG4gICAgICAgIHRpdGxlSWNvbjogJ2Vtby11bmhhcHB5JyxcbiAgICAgICAgdGl0bGU6ICdTb3JyeScsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuX2RlQ29udGVudCxcbiAgICAgICAgcGFyZW50OiBhbS5kZURpYWxvZ0NvbnQsXG4gICAgICAgIGJ1dHRvbnM6IFsnb2snXSxcbiAgICB9KTtcblxuICAgIHRoaXMuZG9tRWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGlja19vaycsIHRoaXMuX29uQ2xpY2tPayk7XG59O1xuXG5wLl9vbkNsaWNrT2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmhpZGUoKTtcbn07XG5cblxucC5fY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2RlQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlQ29udGVudC5zdHlsZS53aWR0aCA9ICczMzBweCc7XG4gICAgdGhpcy5fZGVDb250ZW50LnN0eWxlLnBhZGRpbmcgPSAnMzBweCAxMnB4JztcblxuICAgIGFtZ3VpLmNyZWF0ZUxhYmVsKHtcbiAgICAgICAgY2FwdGlvbjogJ1RoaXMgZmVhdHVyZSBkb2VzblxcJ3QgZXhpdHMgeWV0LiAoQnV0IGl0XFwncyBvbiB0aGUgd2F5ISknLFxuICAgICAgICBmb250U2l6ZTogJzE4cHgnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlQ29udGVudFxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlhbG9nRmVhdHVyZURvZXNudEV4aXRzKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIGFtZ3VpID0gcmVxdWlyZSgnLi4vYW1ndWknKTtcblxuZnVuY3Rpb24gRGlhbG9nRmVlZGJhY2sgKCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9uYW1lID0gJyc7XG4gICAgdGhpcy5fc2VsZWN0b3JzID0gW107XG5cbiAgICB0aGlzLl9vbkNsaWNrT2sgPSB0aGlzLl9vbkNsaWNrT2suYmluZCh0aGlzKTsgXG59XG5cbmluaGVyaXRzKERpYWxvZ0ZlZWRiYWNrLCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBEaWFsb2dGZWVkYmFjay5wcm90b3R5cGU7XG5cbnAuc2hvdyA9IGZ1bmN0aW9uIChvcHQpIHtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHRoaXMuX2NyZWF0ZURpYWxvZygpO1xuXG4gICAgdGhpcy5kb21FbGVtLnNob3dNb2RhbCgpO1xufTtcblxucC5oaWRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLmNsb3NlKCk7XG59O1xuXG5wLl9jcmVhdGVEaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNEaWFsb2dDcmVhdGVkKSByZXR1cm47XG4gICAgdGhpcy5faXNEaWFsb2dDcmVhdGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnQoKTtcbiAgICBcbiAgICB0aGlzLmRvbUVsZW0gPSBhbWd1aS5jcmVhdGVEaWFsb2coe1xuICAgICAgICB0aXRsZTogJ0ZlZWRiYWNrJyxcbiAgICAgICAgY29udGVudDogdGhpcy5fZGVDb250ZW50LFxuICAgICAgICBwYXJlbnQ6IGFtLmRlRGlhbG9nQ29udCxcbiAgICAgICAgYnV0dG9uczogWydvayddLFxuICAgIH0pO1xuXG4gICAgdGhpcy5kb21FbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrX29rJywgdGhpcy5fb25DbGlja09rKTtcbn07XG5cbnAuX29uQ2xpY2tPayA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaGlkZSgpO1xufTtcblxuXG5wLl9jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fZGVDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVDb250ZW50LnN0eWxlLndpZHRoID0gJzQ1MHB4JztcbiAgICB0aGlzLl9kZUNvbnRlbnQuc3R5bGUucGFkZGluZyA9ICczMHB4IDEycHgnO1xuXG4gICAgYW1ndWkuY3JlYXRlTGFiZWwoe1xuICAgICAgICBjYXB0aW9uOiAnSGkhIFRoaXMgcHJvZ3JhbSBpcyBpbiBhbHBoYSBzdGF0ZSwgc28gbW9zdCBvZiB0aGUgdGhpbmdzIHdpbGwgY2hhbmdlIGFuZCBtb3N0IG9mIHRoZSBidWdzIGFyZSBrbm93bi4gQnV0IGlmIHlvdSBoYXZlIGFueSBxdWVzdGlvbiwgZmVlZGJhY2ssIGZlYXR1cmUgcmVxdWVzdCwgYnVnIHJlcG9ydCBvciBqdXN0IGZlZWwgdGhlIG5lZWQgZm9yIGNvbnRhY3QsIHlvdSBjYW4gdXNlIHRoZSBhemF6ZGVhekBnbWFpbC5jb20gb3IgdGhlIDxhIHN0eWxlPVwiY29sb3I6d2hpdGU7XCIgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9hbmltYWNoaW5lL2FuaW1hY2hpbmUvaXNzdWVzXCI+Z2l0aHViIGlzc3VlczwvYT4uJyxcbiAgICAgICAgZm9udFNpemU6ICcxOHB4JyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgcGFyZW50OiB0aGlzLl9kZUNvbnRlbnRcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IERpYWxvZ0ZlZWRiYWNrKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgYW1ndWkgPSByZXF1aXJlKCcuLi9hbWd1aScpO1xuXG5mdW5jdGlvbiBEb21QaWNrZXIoKSB7XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2lzTW91c2VPdmVyID0gZmFsc2U7XG4gICAgdGhpcy5fY3J1bWJzID0gW107XG5cbiAgICB0aGlzLl9vbk1Nb3ZlID0gdGhpcy5fb25NTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlciA9IHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1Nb3ZlKTtcblxuICAgIHRoaXMuX2NyZWF0ZUJhc2UoKTtcbn1cblxuaW5oZXJpdHMoRG9tUGlja2VyLCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBEb21QaWNrZXIucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvbVBpY2tlcjtcblxucC5mb2N1c0VsZW0gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cbiAgICB2YXIgb2xkVGFyZ2V0ID0gdGhpcy5fZGVUYXJnZXQsXG4gICAgICAgIGNydW1icyA9IHRoaXMuX2NydW1icyxcbiAgICAgICAgbGFzdENydW1iID0gY3J1bWJzW2NydW1icy5sZW5ndGgtMV07XG5cbiAgICBpZiAob2xkVGFyZ2V0ICYmIG9sZFRhcmdldC5wYXJlbnRFbGVtZW50ID09PSB0YXJnZXQpIHtcblxuICAgICAgICBjcnVtYnMucHVzaChvbGRUYXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgPT09IGxhc3RDcnVtYikge1xuICAgICAgICBcbiAgICAgICAgY3J1bWJzLnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQucGFyZW50RWxlbWVudCA9PT0gbGFzdENydW1iKSB7XG5cbiAgICAgICAgY3J1bWJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVUYXJnZXQgPSB0YXJnZXQ7XG5cblxuICAgIHZhciBwID0gYW0uaXNQaWNrYWJsZURvbUVsZW0sXG4gICAgICAgIHRvcCA9IHAodGFyZ2V0LnBhcmVudEVsZW1lbnQpLFxuICAgICAgICByaWdodCA9IHAodGFyZ2V0Lm5leHRFbGVtZW50U2libGluZyksXG4gICAgICAgIGJvdHRvbSA9IHAodGFyZ2V0LmZpcnN0RWxlbWVudENoaWxkKSxcbiAgICAgICAgbGVmdCA9IHAodGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpO1xuXG4gICAgdGhpcy5fYnRuVG9wLnN0eWxlLmRpc3BsYXkgPSB0b3AgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgIHRoaXMuX2J0blJpZ2h0LnN0eWxlLmRpc3BsYXkgPSByaWdodCA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgdGhpcy5fYnRuQm90dG9tLnN0eWxlLmRpc3BsYXkgPSBib3R0b20gPyAnYmxvY2snIDogJ25vbmUnO1xuICAgIHRoaXMuX2J0bkxlZnQuc3R5bGUuZGlzcGxheSA9IGxlZnQgPyAnYmxvY2snIDogJ25vbmUnO1xuXG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGhpcy5fcmVuZGVyKCk7XG5cbiAgICB0aGlzLl9yZXJlbmRlclNldEkgPSBzZXRJbnRlcnZhbCh0aGlzLl9yZW5kZXIsIDEyMyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3JlbmRlcik7XG5cbiAgICB0aGlzLmVtaXQoJ3BpY2snLCB0YXJnZXQpO1xufTtcblxucC5oaWRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9yZXJlbmRlclNldEkpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZW5kZXIpO1xuXG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59O1xuXG5wLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYnIgPSB0aGlzLl9kZVRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5sZWZ0ID0gYnIubGVmdCArICdweCc7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLnRvcCA9IGJyLnRvcCArICdweCc7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLndpZHRoID0gYnIud2lkdGggKyAncHgnO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5oZWlnaHQgPSBici5oZWlnaHQgKyAncHgnO1xufTtcblxucC5fb25NTW92ZSA9ICBmdW5jdGlvbiAoZSkge1xuXG4gICAgdmFyIGJyID0gdGhpcy5kb21FbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBteCA9IGUuY2xpZW50WCxcbiAgICAgICAgbXkgPSBlLmNsaWVudFksXG4gICAgICAgIHMgPSB0aGlzLl9pc01vdXNlT3ZlciA/IDIxIDogMCxcbiAgICAgICAgb3ZlciA9IG14ID49IGJyLmxlZnQtcyAmJiBteCA8PSBici5yaWdodCtzICYmXG4gICAgICAgICAgICBteSA+PSBici50b3AtcyAmJiBteSA8PSBici5ib3R0b20rcztcblxuICAgIGlmIChvdmVyICE9PSB0aGlzLl9pc01vdXNlT3Zlcikge1xuXG4gICAgICAgIHRoaXMuX2lzTW91c2VPdmVyID0gb3ZlcjtcblxuICAgICAgICB2YXIgdiA9IG92ZXIgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcblxuICAgICAgICB0aGlzLl9idG5Ub3Auc3R5bGUudmlzaWJpbGl0eSA9IHY7XG4gICAgICAgIHRoaXMuX2J0blJpZ2h0LnN0eWxlLnZpc2liaWxpdHkgPSB2O1xuICAgICAgICB0aGlzLl9idG5Cb3R0b20uc3R5bGUudmlzaWJpbGl0eSA9IHY7XG4gICAgICAgIHRoaXMuX2J0bkxlZnQuc3R5bGUudmlzaWJpbGl0eSA9IHY7XG4gICAgICAgIHRoaXMuX2J0bkNsb3NlLnN0eWxlLnZpc2liaWxpdHkgPSB2O1xuICAgIH1cbn07XG5cbnAuX2NyZWF0ZUJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYnRuU2l6ZSA9IDIxO1xuXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGRlLnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICBkZS5zdHlsZS5ib3hTaGFkb3cgPSAnMHB4IDBweCAxcHggMHB4IHJnYmEoNTAsIDUwLCA1MCwgMC43NSknO1xuICAgIGRlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICBkZS5zdHlsZS5ib3JkZXIgPSAnMnB4IGRhc2hlZCAjZWVlJztcbiAgICBkZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIGFtLmRlSGFuZGxlckNvbnQuYXBwZW5kQ2hpbGQoZGUpO1xuXG4gICAgZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX29uTUVudGVyKTtcbiAgICBkZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fb25NTGVhdmUpO1xuICAgIFxuICAgIHRoaXMuZG9tRWxlbSA9IGRlO1xuXG4gICAgdGhpcy5fYnRuVG9wID0gY3JlYXRlQnRuKCdhbmdsZS11cCcsICd1cCBvbmUgbGV2ZWwnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5mb2N1c0VsZW0odGhpcy5fZGVUYXJnZXQucGFyZW50RWxlbWVudCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9idG5Ub3Auc3R5bGUudG9wID0gLWJ0blNpemUgKyAncHgnO1xuICAgIHRoaXMuX2J0blRvcC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIHRoaXMuX2J0blRvcC5zdHlsZS5yaWdodCA9ICcwJztcbiAgICB0aGlzLl9idG5Ub3Auc3R5bGUubWFyZ2luID0gJzAgYXV0byc7XG5cblxuICAgIHRoaXMuX2J0blJpZ2h0ID0gY3JlYXRlQnRuKCdhbmdsZS1yaWdodCcsICduZXh0IHNpYmxpbmcnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5mb2N1c0VsZW0odGhpcy5fZGVUYXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2J0blJpZ2h0LnN0eWxlLnJpZ2h0ID0gLWJ0blNpemUgKyAncHgnO1xuICAgIHRoaXMuX2J0blJpZ2h0LnN0eWxlLnRvcCA9ICcwJztcbiAgICB0aGlzLl9idG5SaWdodC5zdHlsZS5ib3R0b20gPSAnMCc7XG4gICAgdGhpcy5fYnRuUmlnaHQuc3R5bGUubWFyZ2luID0gJ2F1dG8gMCc7XG5cbiAgICB0aGlzLl9idG5Cb3R0b20gPSBjcmVhdGVCdG4oJ2FuZ2xlLWRvd24nLCAnZG93biBvbmUgbGV2ZWwnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5mb2N1c0VsZW0odGhpcy5fY3J1bWJzW3RoaXMuX2NydW1icy5sZW5ndGgtMV0gfHwgdGhpcy5fZGVUYXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9idG5Cb3R0b20uc3R5bGUuYm90dG9tID0gLWJ0blNpemUgKyAncHgnO1xuICAgIHRoaXMuX2J0bkJvdHRvbS5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIHRoaXMuX2J0bkJvdHRvbS5zdHlsZS5yaWdodCA9ICcwJztcbiAgICB0aGlzLl9idG5Cb3R0b20uc3R5bGUubWFyZ2luID0gJzAgYXV0byc7XG5cbiAgICB0aGlzLl9idG5MZWZ0ID0gY3JlYXRlQnRuKCdhbmdsZS1sZWZ0JywgJ3ByZXZpb3VzIHNpYmxpbmcnLCBmdW5jdGlvbiAoKSB7IFxuXG4gICAgICAgIHRoaXMuZm9jdXNFbGVtKHRoaXMuX2RlVGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fYnRuTGVmdC5zdHlsZS5sZWZ0ID0gLWJ0blNpemUgKyAncHgnO1xuICAgIHRoaXMuX2J0bkxlZnQuc3R5bGUudG9wID0gJzAnO1xuICAgIHRoaXMuX2J0bkxlZnQuc3R5bGUuYm90dG9tID0gJzAnO1xuICAgIHRoaXMuX2J0bkxlZnQuc3R5bGUubWFyZ2luID0gJ2F1dG8gMCc7XG5cbiAgICB0aGlzLl9idG5DbG9zZSA9IGNyZWF0ZUJ0bignY2FuY2VsJywgJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fYnRuQ2xvc2Uuc3R5bGUucmlnaHQgPSAtYnRuU2l6ZSArICdweCc7XG4gICAgdGhpcy5fYnRuQ2xvc2Uuc3R5bGUudG9wID0gLWJ0blNpemUgKyAncHgnO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQnRuKGljb24sIHRvb2x0aXAsIG9uQ2xpY2spIHtcblxuICAgICAgICB2YXIgZGVJY29uID0gYW1ndWkuY3JlYXRlSWNvbkJ0bih7XG4gICAgICAgICAgICBpY29uOiBpY29uLFxuICAgICAgICAgICAgd2lkaHQ6IGJ0blNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IGJ0blNpemUsXG4gICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgb25DbGljaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogZGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYW1ndWkuYWRkVG9vbHRpcCh7XG4gICAgICAgICAgICBkZVRhcmdldDogZGVJY29uLFxuICAgICAgICAgICAgdGV4dDogdG9vbHRpcFxuICAgICAgICB9KTtcblxuICAgICAgICBkZUljb24uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBkZUljb24uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcblxuICAgICAgICByZXR1cm4gZGVJY29uO1xuICAgIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciB1bmNhbGMgPSByZXF1aXJlKCcuL3VuY2FsYycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4vS2V5Jyk7XG52YXIgYW1ndWkgPSByZXF1aXJlKCcuLi8uLi9hbWd1aScpO1xuXG5mdW5jdGlvbiBDc3NQYXJhbWV0ZXIgKG9wdCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fbGluZUggPSAgMjE7XG5cbiAgICB0aGlzLmRlT3B0aW9ucyA9IHRoaXMuX2NyZWF0ZVBhcmFtZXRlck9wdGlvbnMoKTtcbiAgICB0aGlzLmRlS2V5bGluZSA9IGFtZ3VpLmNyZWF0ZUtleWxpbmUoe1xuICAgICAgICB0aW1lc2NhbGU6IGFtLnRpbWVsaW5lLnRpbWVzY2FsZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fb25DaGFuZ2VJbnB1dCA9IHRoaXMuX29uQ2hhbmdlSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVRpbWUgPSB0aGlzLl9vbkNoYW5nZVRpbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUtleVRpbWUgPSB0aGlzLl9vbkNoYW5nZUtleVRpbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblRvZ2dsZUtleSA9IHRoaXMuX29uVG9nZ2xlS2V5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EZWxldGVLZXkgPSB0aGlzLl9vbkRlbGV0ZUtleS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKCF0aGlzLl9ub0Jhc2VLZXlWYWx1ZUlucHV0KSB7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBhbWd1aS5jcmVhdGVLZXlWYWx1ZUlucHV0KHtcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5kZU9wdGlvbnMsXG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5fb25DaGFuZ2VJbnB1dCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5fbGluZUhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2lucHV0LnN0eWxlLmZsZXggPSAxO1xuICAgIH1cblxuICAgIHRoaXMuX2J0blRvZ2dsZUtleSA9IGFtZ3VpLmNyZWF0ZUljb25CdG4oe1xuICAgICAgICBpY29uOiAna2V5JyxcbiAgICAgICAgaGVpZ2h0OiAyMSxcbiAgICAgICAgcGFyZW50OiB0aGlzLmRlT3B0aW9ucyxcbiAgICAgICAgb25DbGljazogdGhpcy5fb25Ub2dnbGVLZXksXG4gICAgfSk7XG4gICAgdGhpcy5fcmVmcmVzaEJ0blRvZ2dsZUtleSgpO1xuXG4gICAgYW0udGltZWxpbmUub24oJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZVRpbWUpO1xuXG4gICAgaWYgKG9wdCkge1xuICAgICAgICB0aGlzLnVzZVNhdmUob3B0KTtcbiAgICB9XG59XG5cbmluaGVyaXRzKENzc1BhcmFtZXRlciwgRXZlbnRFbWl0dGVyKTtcbnZhciBwID0gQ3NzUGFyYW1ldGVyLnByb3RvdHlwZTtcblxuXG5cblxuXG5cblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCAnaGVpZ2h0Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUg7XG4gICAgfVxufSk7XG5cblxuXG5cblxucC5nZXRTYXZlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNhdmUgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAga2V5czogW10sXG4gICAgfTtcblxuICAgIHRoaXMuX2tleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgc2F2ZS5rZXlzLnB1c2goa2V5LmdldFNhdmUoKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2F2ZTtcbn07XG5cbnAudXNlU2F2ZSA9IGZ1bmN0aW9uKHNhdmUpIHtcblxuICAgIHRoaXMubmFtZSA9IHNhdmUubmFtZTtcblxuICAgIGlmIChzYXZlLmtleXMpIHtcblxuICAgICAgICBzYXZlLmtleXMuZm9yRWFjaCh0aGlzLmFkZEtleSwgdGhpcyk7XG4gICAgfVxufTtcblxucC5nZXRTY3JpcHRLZXlzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIHRoaXMuX2tleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgdmFyIGsgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IGtleS50aW1lIC8gYW0udGltZWxpbmUubGVuZ3RoLFxuICAgICAgICB9O1xuXG4gICAgICAgIGtbdGhpcy5uYW1lXSA9IHRoaXMuZ2V0VmFsdWUoa2V5LnRpbWUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGtleS5lYXNlICYmIGtleS5lYXNlICE9PSAnbGluZWFyJykge1xuXG4gICAgICAgICAgIGsuZWFzaW5nID0ga2V5LmVhc2U7IFxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKGspO1xuICAgIH0sIHRoaXMpO1xuXG4gICAga2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnAuZ2V0VmFsdWUgPSBmdW5jdGlvbiAodGltZSkge1xuXG4gICAgaWYgKCFfLmlzTnVtYmVyKHRpbWUpKSB7XG4gICAgICAgIHRpbWUgPSBhbS50aW1lbGluZS5jdXJyVGltZTtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlLCBhZnRlciwgc2FtZTtcblxuICAgIHRoaXMuX2tleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgaWYgKGtleS50aW1lID09PSB0aW1lKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgc2FtZSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkudGltZSA8IHRpbWUgJiYgKCFiZWZvcmUgfHwgYmVmb3JlLnRpbWUgPCBrZXkudGltZSkpIHtcbiAgICAgICAgXG4gICAgICAgICAgICBiZWZvcmUgPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5LnRpbWUgPiB0aW1lICYmICghYWZ0ZXIgfHwgYWZ0ZXIudGltZSA+IGtleS50aW1lKSkge1xuICAgICAgICBcbiAgICAgICAgICAgIGFmdGVyID0ga2V5O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2FtZSkge1xuXG4gICAgICAgIHJldHVybiBzYW1lLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgYmVmb3JlKSB7XG5cbiAgICAgICAgICAgIHZhciBwID0gKHRpbWUgLSBiZWZvcmUudGltZSkgLyAoYWZ0ZXIudGltZSAtIGJlZm9yZS50aW1lKSwgXG4gICAgICAgICAgICAgICAgYXYgPSB1bmNhbGMoYWZ0ZXIudmFsdWUpLCBidiA9IHVuY2FsYyhiZWZvcmUudmFsdWUpO1xuXG4gICAgICAgICAgICBwID0gdGhpcy5fYXBwbHlFYXNlKGJlZm9yZS5lYXNlLCBwKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGMoYXYsIGJ2LCBwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGJlZm9yZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZnRlcikge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxjKGF2LCBidiwgcCkge1xuXG4gICAgICAgIHZhciBhdnMgPSBfLmNvbXBhY3QoYXYuc3BsaXQoJyAnKSksXG4gICAgICAgICAgICBidnMgPSBfLmNvbXBhY3QoYnYuc3BsaXQoJyAnKSksXG4gICAgICAgICAgICBhdmwgPSBhdnMubGVuZ3RoLFxuICAgICAgICAgICAgYnZsID0gYnZzLmxlbmd0aCxcbiAgICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgIGlmIChhdmwgIT09IGJ2bCkge1xuXG4gICAgICAgICAgICBpZiAoYXZsIDwgYnZsKSB7XG5cbiAgICAgICAgICAgICAgICBhdnMgPSBhdnMuY29uY2F0KGJ2cy5zbGljZShhdmwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ2cyA9IGJ2cy5jb25jYXQoYXZzLnNsaWNlKGJ2bCkpO1xuICAgICAgICAgICAgfSAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgYXZzLmZvckVhY2goZnVuY3Rpb24gKGEsIGlkeCkge1xuXG4gICAgICAgICAgICByZXQucHVzaChjYWxjKGEsIGJ2c1tpZHhdKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXQuam9pbignICcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGMoYSwgYikge1xuXG4gICAgICAgICAgICByZXR1cm4gJ2NhbGMoJyArIGIgKyAnICsgKCcgKyBhICsgJyAtICcgKyBiICsgJykqJyArIHAgKyAnKSc7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5wLmFkZEtleSA9IGZ1bmN0aW9uIChvcHQsIHNraXBIaXN0b3J5KSB7XG4gICAgXG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KG9wdC50aW1lKTtcblxuICAgIGlmIChrZXkpIHtcblxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBvcHQpIHtcblxuICAgICAgICAgICAgaWYgKCFza2lwSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIGFtLmhpc3Rvcnkuc2F2ZUNoYWluKGtleSwgW3RoaXMuYWRkS2V5LCB0aGlzLCBrZXksIHRydWVdLCBbdGhpcy5hZGRLZXksIHRoaXMsIG9wdCwgdHJ1ZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXkudmFsdWUgPSBvcHQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAga2V5ID0gbmV3IEtleShfLmV4dGVuZCh7ZGVLZXlsaW5lOiB0aGlzLmRlS2V5bGluZX0sIG9wdCkpO1xuICAgICAgICBrZXkudmFsdWUgPSBvcHQudmFsdWUgfHwgdGhpcy5nZXRWYWx1ZShvcHQudGltZSk7XG5cbiAgICAgICAga2V5Lm9uKCdjaGFuZ2VUaW1lJywgdGhpcy5fb25DaGFuZ2VLZXlUaW1lKTtcbiAgICAgICAga2V5Lm9uKCdkZWxldGUnLCB0aGlzLl9vbkRlbGV0ZUtleSk7XG5cbiAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGtleSk7XG5cbiAgICAgICAgaWYgKCFza2lwSGlzdG9yeSkge1xuICAgICAgICAgICAgYW0uaGlzdG9yeS5jbG9zZUNoYWluKGtleSk7XG4gICAgICAgICAgICBhbS5oaXN0b3J5LnNhdmUoW3RoaXMucmVtb3ZlS2V5LCB0aGlzLCBvcHQudGltZSwgdHJ1ZV0sIFt0aGlzLmFkZEtleSwgdGhpcywgb3B0LCB0cnVlXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yZWZyZXNoSW5wdXQoKTtcbiAgICB0aGlzLl9yZWZyZXNoQnRuVG9nZ2xlS2V5KCk7XG5cbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuXG4gICAgcmV0dXJuIGtleTtcbn07XG5cbnAucmVtb3ZlS2V5ID0gZnVuY3Rpb24gKGtleSwgc2tpcEhpc3RvcnkpIHtcblxuICAgIGlmICh0eXBlb2Yoa2V5KSA9PT0gJ251bWJlcicpIHtcblxuICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xuICAgIH1cblxuICAgIHZhciBpZHggPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghc2tpcEhpc3RvcnkpIHtcbiAgICAgICAgYW0uaGlzdG9yeS5zYXZlKFt0aGlzLmFkZEtleSwgdGhpcywga2V5LCB0cnVlXSxcbiAgICAgICAgICAgIFt0aGlzLnJlbW92ZUtleSwgdGhpcywga2V5LCB0cnVlXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fa2V5cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIGtleS5kaXNwb3NlKCk7XG5cbiAgICBrZXkucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZUtleVRpbWUpO1xuICAgIGtleS5yZW1vdmVMaXN0ZW5lcignZGVsZXRlJywgdGhpcy5fb25EZWxldGVLZXkpO1xuXG4gICAgdGhpcy5fcmVmcmVzaEJ0blRvZ2dsZUtleSgpO1xuXG4gICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbn07XG5cbnAuZ2V0S2V5ID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuICAgIHJldHVybiB0aGlzLl9rZXlzLmZpbmQoZnVuY3Rpb24oa2V5KSB7XG5cbiAgICAgICAgcmV0dXJuIGtleS50aW1lID09PSB0aW1lO1xuICAgIH0pO1xufTtcblxucC5nZXRQcmV2S2V5ID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuICAgIHZhciByZXRLZXk7XG4gICAgXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXG4gICAgICAgIGlmIChrZXkudGltZSA8IHRpbWUgJiYgKCFyZXRLZXkgfHwgcmV0S2V5LnRpbWUgPCBrZXkudGltZSkpIHtcblxuICAgICAgICAgICAgcmV0S2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0S2V5O1xufTtcblxucC5nZXROZXh0S2V5ID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuICAgIHZhciByZXRLZXk7XG4gICAgXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXG4gICAgICAgIGlmIChrZXkudGltZSA+IHRpbWUgJiYgKCFyZXRLZXkgfHwgcmV0S2V5LnRpbWUgPiBrZXkudGltZSkpIHtcblxuICAgICAgICAgICAgcmV0S2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0S2V5O1xufTtcblxucC5nZXRLZXlUaW1lcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICB0aW1lcy5wdXNoKGtleS50aW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aW1lcztcbn07XG5cbnAuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiAhISh0aGlzLm5hbWUgJiYgdGhpcy5fa2V5cy5sZW5ndGgpO1xufTtcblxuXG5cblxuXG5cblxuXG5cbnAuX2FwcGx5RWFzZSA9IGZ1bmN0aW9uIChlYXNlLCB2YWx1ZSkge1xuXG4gICAgdmFyIHJ4ID0gL2N1YmljLWJlemllclxcKFxccyooW1xcZFxcLl0rKVxccyosXFxzKihbXFxkXFwuLV0rKVxccyosXFxzKihbXFxkXFwuXSspXFxzKixcXHMqKFtcXGRcXC4tXSspXFxzKlxcKS8sXG4gICAgICAgIG0gPSByeC5leGVjKGVhc2UpO1xuXG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHAgPSBbMCwgMCwgcGFyc2VGbG9hdChtWzFdKSwgcGFyc2VGbG9hdChtWzJdKSwgcGFyc2VGbG9hdChtWzNdKSwgcGFyc2VGbG9hdChtWzRdKSwgMSwgMV07XG5cbiAgICBjb3VudCgwKTtcbiAgICBjb3VudCgyKTtcbiAgICBjb3VudCg0KTtcbiAgICBjb3VudCgwKTtcbiAgICBjb3VudCgyKTtcbiAgICBjb3VudCgwKTtcblxuICAgIHJldHVybiBwWzFdO1xuXG5cbiAgICBmdW5jdGlvbiBjb3VudChpKSB7XG5cbiAgICAgICAgcFtpKzBdID0gcFtpKzBdICsgKHBbaSsyXSAtIHBbaSswXSkgKiB2YWx1ZTtcbiAgICAgICAgcFtpKzFdID0gcFtpKzFdICsgKHBbaSszXSAtIHBbaSsxXSkgKiB2YWx1ZTtcbiAgICB9XG59O1xuXG5cblxuXG5cblxuXG5cbnAuX29uQ2hhbmdlSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgaWYgKCdrZXknIGluIGUuZGV0YWlsKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IGUuZGV0YWlsLmtleTtcbiAgICB9XG5cbiAgICBpZiAoJ3ZhbHVlJyBpbiBlLmRldGFpbCkge1xuICAgICAgICB0aGlzLmFkZEtleSh7XG4gICAgICAgICAgICB0aW1lOiBhbS50aW1lbGluZS5jdXJyVGltZSxcbiAgICAgICAgICAgIHZhbHVlOiBlLmRldGFpbC52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xufTtcblxucC5fb25DaGFuZ2VLZXlUaW1lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbn07XG5cbnAuX29uRGVsZXRlS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuXG4gICAgdGhpcy5yZW1vdmVLZXkoa2V5KTtcbn07XG5cbnAuX29uQ2hhbmdlVGltZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX3JlZnJlc2hJbnB1dCgpO1xuICAgIHRoaXMuX3JlZnJlc2hCdG5Ub2dnbGVLZXkoKTtcbn07XG5cbnAuX29uVG9nZ2xlS2V5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGFtLnRpbWVsaW5lLmN1cnJUaW1lKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVLZXkoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkS2V5KHt0aW1lOiBhbS50aW1lbGluZS5jdXJyVGltZX0pO1xuICAgIH1cbn07XG5cblxuXG5cblxuXG5cblxuXG5wLl9yZWZyZXNoSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9pbnB1dC5zZXRLZXkodGhpcy5uYW1lKTtcbiAgICB0aGlzLl9pbnB1dC5zZXRWYWx1ZSh0aGlzLmdldFZhbHVlKCkpO1xufTtcblxucC5fcmVmcmVzaEJ0blRvZ2dsZUtleSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShhbS50aW1lbGluZS5jdXJyVGltZSk7XG4gICAgdGhpcy5fYnRuVG9nZ2xlS2V5LnN0eWxlLmNvbG9yID0ga2V5ID8gYW1ndWkuY29sb3IudGV4dCA6IGFtZ3VpLmNvbG9yLnRleHRJbmFjdGl2ZTtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5wLl9jcmVhdGVQYXJhbWV0ZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICBkZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBkZS5zdHlsZS5oZWlnaHQgPSB0aGlzLl9saW5lSCArICdweCc7XG4gICAgZGUuc3R5bGUuYmFja2dyb3VuZCA9ICdsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjMTg0RjEyIDE4JSwjMUI0NDE3IDk2JSknO1xuXG4gICAgYW1ndWkuYmluZERyb3Bkb3duKHtcbiAgICAgICAgYXNDb250ZXh0TWVudTogdHJ1ZSxcbiAgICAgICAgZGVUYXJnZXQ6IGRlLFxuICAgICAgICBkZU1lbnU6IGFtZ3VpLmNyZWF0ZURyb3Bkb3duKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7dGV4dDogJ21vdmUgdXAnLCBvblNlbGVjdDogdGhpcy5lbWl0LmJpbmQodGhpcywgJ21vdmUnLCB0aGlzLCAtMSl9LFxuICAgICAgICAgICAgICAgIHt0ZXh0OiAnbW92ZSBkb3duJywgb25TZWxlY3Q6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdtb3ZlJywgdGhpcywgMSl9LFxuICAgICAgICAgICAgICAgIHt0ZXh0OiAnZGVsZXRlJywgb25TZWxlY3Q6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdkZWxldGUnLCB0aGlzKX0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGU7XG59O1xuXG5wLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvL1RPRE9cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3NzUGFyYW1ldGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uLy4uL2FtZ3VpJyk7XG52YXIgQ3NzUGFyYW1ldGVyID0gcmVxdWlyZSgnLi9Dc3NQYXJhbWV0ZXInKTtcbnZhciBDc3NUcmFuc2Zvcm1QYXJhbWV0ZXIgPSByZXF1aXJlKCcuL0Nzc1RyYW5zZm9ybVBhcmFtZXRlcicpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4vS2V5Jyk7XG52YXIgVHJhbnNoYW5kID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNoYW5kL1RyYW5zaGFuZCcpO1xudmFyIG1zdFBsYXllciA9IHJlcXVpcmUoJy4vc2NyaXB0LnBsYXllci5tc3QnKTtcbnZhciBkaWFsb2dTZXF1T3B0aW9ucyA9IHJlcXVpcmUoJy4vZGlhbG9nU2VxdU9wdGlvbnMnKTtcblxuZnVuY3Rpb24gQ3NzU2VxdWVuY2Uob3B0KSB7XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3NlbGVjdG9ycyA9IFtdO1xuICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBbXTtcbiAgICB0aGlzLl9maWxsID0gJ2ZvcndhcmQnO1xuICAgIHRoaXMuX25hbWUgPSAndW5uYW1lZCc7XG4gICAgdGhpcy5faXRlcmF0aW9ucyA9IDE7XG5cbiAgICB0aGlzLl9iYXNlSCA9IDIxO1xuICAgIHRoaXMuX3NlbGVjdGVkRWxlbXMgPSBbXTtcbiAgICB0aGlzLl9oZWFkS2V5cyA9IFtdO1xuICAgIHRoaXMuX2lzU2hvd2luZ1BhcmFtcyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzSGlkaW5nU2VsZWN0ZWRFbGVtcyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fb25TZWxlY3RDbGljayA9IHRoaXMuX29uU2VsZWN0Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUhhbmRsZXIgPSB0aGlzLl9vbkNoYW5nZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVRpbWUgPSB0aGlzLl9vbkNoYW5nZVRpbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVBhcmFtZXRlciA9IHRoaXMuX29uQ2hhbmdlUGFyYW1ldGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EZWxldGVQYXJhbWV0ZXIgPSB0aGlzLl9vbkRlbGV0ZVBhcmFtZXRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW92ZVBhcmFtZXRlciA9IHRoaXMuX29uTW92ZVBhcmFtZXRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2hhbmdlQmxhbmtQYXJhbWV0ZXIgPSB0aGlzLl9vbkNoYW5nZUJsYW5rUGFyYW1ldGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DbGlja1RnZ2xLZXkgPSB0aGlzLl9vbkNsaWNrVGdnbEtleS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2xpY2tUZ2dsSGlkZSA9IHRoaXMuX29uQ2xpY2tUZ2dsSGlkZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2xpY2tUZ2dsU2hvd1BhcmFtcyA9IHRoaXMuX29uQ2xpY2tUZ2dsU2hvd1BhcmFtcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2xpY2tOYW1lID0gdGhpcy5fb25DbGlja05hbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZU5hbWUgPSB0aGlzLl9vbkNoYW5nZU5hbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZU5hbWUgPSB0aGlzLl9vbkNoYW5nZU5hbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUZpbGwgPSB0aGlzLl9vbkNoYW5nZUZpbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUl0ZXJhdGlvbnMgPSB0aGlzLl9vbkNoYW5nZUl0ZXJhdGlvbnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVNlbGVjdG9ycyA9IHRoaXMuX29uQ2hhbmdlU2VsZWN0b3JzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2FuaW1QbGF5ID0gdGhpcy5fYW5pbVBsYXkuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZGVPcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kZUtleXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHRoaXMuX2RlSGVhZE9wdGlub3MgPSB0aGlzLl9jcmVhdGVIZWFkT3B0aW9ucygpO1xuICAgIHRoaXMuX2RlSGVhZEtleWxpbmUgPSBhbWd1aS5jcmVhdGVLZXlsaW5lKHt9KTtcbiAgICB0aGlzLmRlS2V5cy5hcHBlbmRDaGlsZCh0aGlzLl9kZUhlYWRLZXlsaW5lKTtcblxuICAgIGFtLnRpbWVsaW5lLm9uKCdjaGFuZ2VUaW1lJywgdGhpcy5fb25DaGFuZ2VUaW1lKTtcbiAgICB0aGlzLmRlT3B0aW9ucy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uU2VsZWN0Q2xpY2spO1xuICAgIHRoaXMuZGVLZXlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25TZWxlY3RDbGljayk7XG5cbiAgICB0aGlzLl9vbkNoYW5nZUJsYW5rUGFyYW1ldGVyKCk7XG5cbiAgICBpZiAob3B0KSB7XG4gICAgICAgIHRoaXMudXNlU2F2ZShvcHQpO1xuICAgIH1cbn1cblxuaW5oZXJpdHMoQ3NzU2VxdWVuY2UsIEV2ZW50RW1pdHRlcik7XG52YXIgcCA9IENzc1NlcXVlbmNlLnByb3RvdHlwZTtcblxucC50eXBlID0gJ2Nzc19zZXF1X3R5cGUnO1xuXG5cblxuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXG4gICAgaGVpZ2h0OiB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLl9iYXNlSDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2hvd2luZ1BhcmFtcykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldCArPSBwYXJhbS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbmFtZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG5cbiAgICAgICAgICAgIGlmICh2ID09PSB0aGlzLl9uYW1lKSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2O1xuICAgICAgICAgICAgdGhpcy5fZGVOYW1lLnRleHRDb250ZW50ID0gdGhpcy5fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbGw6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAodiA9PT0gdGhpcy5fZmlsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9maWxsID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGl0ZXJhdGlvbnM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAodiA9PT0gdGhpcy5faXRlcmF0aW9ucykgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9pdGVyYXRpb25zID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVyYXRpb25zO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG5cblxuXG5wLmdldFNhdmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgc2F2ZSA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBmaWxsOiB0aGlzLmZpbGwsXG4gICAgICAgIGl0ZXJhdGlvbnM6IHRoaXMuaXRlcmF0aW9ucyxcbiAgICAgICAgc2VsZWN0b3JzOiBfLmNsb25lKHRoaXMuX3NlbGVjdG9ycyksXG4gICAgICAgIHBhcmFtZXRlcnM6IFtdLFxuICAgICAgICBpc1Nob3dpbmdQYXJhbXM6IHRoaXMuX2lzU2hvd2luZ1BhcmFtcyxcbiAgICB9O1xuXG4gICAgdGhpcy5fcGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuXG4gICAgICAgIHNhdmUucGFyYW1ldGVycy5wdXNoKHBhcmFtLmdldFNhdmUoKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2F2ZTtcbn07XG5cbnAudXNlU2F2ZSA9IGZ1bmN0aW9uIChzYXZlKSB7XG5cbiAgICBpZiAoIXNhdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbGVjdG9ycyA9IHNhdmUuc2VsZWN0b3JzIHx8IFtdO1xuXG4gICAgaWYgKCduYW1lJyBpbiBzYXZlKSB0aGlzLm5hbWUgPSBzYXZlLm5hbWU7XG4gICAgaWYgKCdmaWxsJyBpbiBzYXZlKSB0aGlzLmZpbGwgPSBzYXZlLmZpbGw7XG4gICAgaWYgKCdpdGVyYXRpb25zJyBpbiBzYXZlKSB0aGlzLml0ZXJhdGlvbnMgPSBzYXZlLml0ZXJhdGlvbnM7XG5cbiAgICBpZiAoc2F2ZS5wYXJhbWV0ZXJzKSB7XG5cbiAgICAgICAgc2F2ZS5wYXJhbWV0ZXJzLmZvckVhY2godGhpcy5hZGRQYXJhbWV0ZXIsIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbGVjdEVsZW1lbnRzKCk7XG4gICAgdGhpcy5fcmVmcmVzaEhlYWRLZXlsaW5lKCk7XG4gICAgdGhpcy5fcmVmcmVzaFRnZ2xLZXkoKTtcblxuICAgIGlmIChzYXZlLmlzU2hvd2luZ1BhcmFtcykge1xuXG4gICAgICAgIHRoaXMuX3Nob3dQYXJhbXMoKTtcbiAgICB9XG59O1xuXG5wLmdldFNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBwYXJhbUtleXMgPSBbXSwgY29kZSA9ICcnLCBvcHRpb25zLCBzZWxlY3RvcnM7XG5cbiAgICB0aGlzLl9wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG5cbiAgICAgICAgcGFyYW1LZXlzLnB1c2gocGFyYW0uZ2V0U2NyaXB0S2V5cygpKTtcbiAgICB9KTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBkaXJlY3Rpb246IFwibm9ybWFsXCIsXG4gICAgICBkdXJhdGlvbjogYW0udGltZWxpbmUubGVuZ3RoLFxuICAgICAgaXRlcmF0aW9uczogdGhpcy5pdGVyYXRpb25zLFxuICAgICAgZmlsbDogdGhpcy5maWxsLFxuICAgIH07XG5cbiAgICBzZWxlY3RvcnMgPSB0aGlzLl9zZWxlY3RvcnMuam9pbignLCcpLnJlcGxhY2UoJ1xcXFwnLCdcXFxcXFxcXCcpO1xuXG4gICAgY29kZSA9IE11c3RhY2hlLnJlbmRlcihtc3RQbGF5ZXIsIHtcbiAgICAgICAgcGFyYW1LZXlzOiBKU09OLnN0cmluZ2lmeShwYXJhbUtleXMpLFxuICAgICAgICBvcHRpb25zOiBKU09OLnN0cmluZ2lmeShvcHRpb25zKSxcbiAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnNcbiAgICB9KTtcblxuICAgIHJldHVybiBjb2RlO1xufTtcblxucC5hZGRQYXJhbWV0ZXIgPSBmdW5jdGlvbiAob3B0LCBza2lwSGlzdG9yeSkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdmFyIHBhcmFtID0gdGhpcy5fZ2V0UGFyYW1ldGVyKG9wdC5uYW1lKTtcbiAgICBcblxuICAgIGlmIChwYXJhbSkge1xuXG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgaWYgKG9wdC5uYW1lID09PSAndHJhbnNmb3JtJykge1xuXG4gICAgICAgICAgICBwYXJhbSA9IG5ldyBDc3NUcmFuc2Zvcm1QYXJhbWV0ZXIob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcGFyYW0gPSBuZXcgQ3NzUGFyYW1ldGVyKG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNraXBIaXN0b3J5KSB7XG4gICAgICAgICAgICBhbS5oaXN0b3J5LnNhdmUoW3RoaXMucmVtb3ZlUGFyYW1ldGVyLCB0aGlzLCBwYXJhbSwgdHJ1ZV0sXG4gICAgICAgICAgICAgICAgW3RoaXMuYWRkUGFyYW1ldGVyLCB0aGlzLCBwYXJhbSwgdHJ1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFyYW1ldGVycy5wdXNoKHBhcmFtKTtcbiAgICAgICAgcGFyYW0ub24oJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlUGFyYW1ldGVyKTtcbiAgICAgICAgcGFyYW0ub24oJ2RlbGV0ZScsIHRoaXMuX29uRGVsZXRlUGFyYW1ldGVyKTtcbiAgICAgICAgcGFyYW0ub24oJ21vdmUnLCB0aGlzLl9vbk1vdmVQYXJhbWV0ZXIpO1xuXG4gICAgICAgIHRoaXMuX3JlZnJlc2hQYXJhbWV0ZXJPcmRlcmluZygpO1xuICAgICAgICB0aGlzLl9tb3ZlQmxhbmtQYXJhbWV0ZXJEb3duKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlSGVpZ2h0JywgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1cbn07XG5cbnAucmVtb3ZlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHBhcmFtLCBza2lwSGlzdG9yeSkge1xuXG4gICAgaWYgKCFza2lwSGlzdG9yeSkge1xuICAgICAgICBhbS5oaXN0b3J5LnNhdmUoW3RoaXMuYWRkUGFyYW1ldGVyLCB0aGlzLCBwYXJhbSwgdHJ1ZV0sXG4gICAgICAgICAgICBbdGhpcy5yZW1vdmVQYXJhbWV0ZXIsIHRoaXMsIHBhcmFtLCB0cnVlXSk7XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IHRoaXMuX3BhcmFtZXRlcnMuaW5kZXhPZihwYXJhbSk7XG5cbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGFyYW1ldGVycy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIHBhcmFtLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZVBhcmFtZXRlcik7XG4gICAgcGFyYW0ucmVtb3ZlTGlzdGVuZXIoJ2RlbGV0ZScsIHRoaXMuX29uRGVsZXRlUGFyYW1ldGVyKTtcbiAgICBwYXJhbS5yZW1vdmVMaXN0ZW5lcignbW92ZScsIHRoaXMuX29uTW92ZVBhcmFtZXRlcik7XG5cbiAgICAkKHBhcmFtLmRlT3B0aW9ucykucmVtb3ZlKCk7XG4gICAgJChwYXJhbS5kZUtleWxpbmUpLnJlbW92ZSgpO1xufTtcblxucC5tb3ZlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHBhcmFtLCB3YXkpIHtcblxuICAgIHZhciBpZHggPSB0aGlzLl9wYXJhbWV0ZXJzLmluZGV4T2YocGFyYW0pO1xuXG4gICAgdGhpcy5fcGFyYW1ldGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICBpZHggPSBNYXRoLm1pbih0aGlzLl9wYXJhbWV0ZXJzLmxlbmd0aCwgTWF0aC5tYXgoMCwgaWR4ICsgd2F5KSk7XG4gICAgdGhpcy5fcGFyYW1ldGVycy5zcGxpY2UoaWR4LCAwLCBwYXJhbSk7XG5cbiAgICB0aGlzLl9yZWZyZXNoUGFyYW1ldGVyT3JkZXJpbmcoKTtcbn07XG5cbnAuc2VsZWN0ID0gZnVuY3Rpb24gKG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcblxuXG4gICAgaWYgKCF0aGlzLl9oYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIgPSBuZXcgVHJhbnNoYW5kKCk7XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlci5vbignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUpO1xuXG4gICAgdGhpcy5fc2VsZWN0RWxlbWVudHMoKTtcblxuICAgIGlmICh0aGlzLl9zZWxlY3RlZEVsZW1zLmxlbmd0aCkge1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzSGFuZGxlcihvcHQuZm9jdXNFbGVtIHx8IHRoaXMuX3NlbGVjdGVkRWxlbXNbMF0pO1xuICAgIH1cblxuICAgIHRoaXMuZGVIaWdobGlnaHQuc3R5bGUub3BhY2l0eSA9IDE7XG5cbiAgICB0aGlzLmVtaXQoJ3NlbGVjdCcsIHRoaXMpO1xufTtcblxucC5kZXNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5faXNTZWxlY3RlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2JsdXJIYW5kbGVyKCk7XG5cbiAgICB0aGlzLmRlSGlnaGxpZ2h0LnN0eWxlLm9wYWNpdHkgPSAwO1xuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplKTtcblxuICAgIGlmICh0aGlzLl9oYW5kbGVyKSB7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlci5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VIYW5kbGVyKTtcbiAgICB9XG59O1xuXG5wLnJlbmRlclRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuXG4gICAgaWYgKHRoaXMuX3NlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3Rpb24gPSBfLnRvQXJyYXkoYW0uZGVSb290LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3JzLmpvaW4oJywnKSkpO1xuXG4gICAgdGhpcy5fcGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuXG4gICAgICAgIHNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChkZSkge1xuXG4gICAgICAgICAgICBkZS5zdHlsZVtwYXJhbS5uYW1lXSA9IHBhcmFtLmdldFZhbHVlKHRpbWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbnAuX29uUGljayA9IGZ1bmN0aW9uIChkZSkge1xuXG4gICAgdmFyIGl0ZW1zID0gYW0uZGVSb290LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RvcnMuam9pbignLCcpKTtcblxuICAgIGlmIChpdGVtcy5pbmRleE9mKGRlKSkge1xuXG4gICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxufTtcblxucC5wbGF5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX2FuaW1QbGF5KCk7XG59O1xuXG5wLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbVBsYXlSYWZpZCk7XG59O1xuXG5wLmdldE1hZ25ldFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aW1lcyA9IFtdO1xuXG4gICAgdGhpcy5faGVhZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgdGltZXMucHVzaChrZXkudGltZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGltZXM7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5wLl9hbmltUGxheSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2FuaW1QbGF5UmFmaWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1QbGF5KTtcblxuICAgIHRoaXMucmVuZGVyVGltZShhbS50aW1lbGluZS5jdXJyVGltZSk7XG59O1xuXG5wLl9mb2N1c0hhbmRsZXIgPSBmdW5jdGlvbiAoZGUpIHtcblxuICAgIGRlID0gZGUgfHwgdGhpcy5fY3VyckhhbmRsZWREZTtcbiAgICB0aGlzLl9jdXJySGFuZGxlZERlID0gZGU7XG5cbiAgICBpZiAoIXRoaXMuX2N1cnJIYW5kbGVkRGUpIHJldHVybiB0aGlzLl9ibHVySGFuZGxlcigpO1xuXG4gICAgdmFyIHRyYW5zZm9ybVNhdmU7XG4gICAgaWYgKGRlLnN0eWxlLnRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm1TYXZlID0gZGUuc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBkZS5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICB9XG5cbiAgICB2YXIgYnIgPSBkZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGRlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVNhdmU7XG5cbiAgICB2YXIgaGFuZE9wdCA9IHtcbiAgICAgICAgdHlwZTogJ3RyYW5zZm9ybWVyJyxcbiAgICAgICAgYmFzZToge1xuICAgICAgICAgICAgeDogYnIubGVmdCxcbiAgICAgICAgICAgIHk6IGJyLnRvcCxcbiAgICAgICAgICAgIHc6IGJyLndpZHRoLFxuICAgICAgICAgICAgaDogYnIuaGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHt9XG4gICAgfTtcbiAgICB2YXIgdHJhbnNmb3JtUGFyYW0gPSB0aGlzLl9nZXRQYXJhbWV0ZXIoJ3RyYW5zZm9ybScpO1xuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW5QYXJhbSA9IHRoaXMuX2dldFBhcmFtZXRlcigndHJhbnNmb3JtLW9yaWdpbicpO1xuXG4gICAgaWYgKHRyYW5zZm9ybVBhcmFtIGluc3RhbmNlb2YgQ3NzVHJhbnNmb3JtUGFyYW1ldGVyKSB7XG5cbiAgICAgICAgXy5leHRlbmQoaGFuZE9wdC5wYXJhbXMsIHRyYW5zZm9ybVBhcmFtLmdldFJhd1ZhbHVlKCkpO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm1PcmlnaW5QYXJhbSkge1xuXG4gICAgICAgIHZhciB2YWwgPSB0cmFuc2Zvcm1PcmlnaW5QYXJhbS5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgbWF0Y2ggPSAvXFxzKihbXFxkXFwuXSspJVxccyooW1xcZFxcLl0rKSUvLmV4ZWModmFsKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGhhbmRPcHQucGFyYW1zLm94ID0gbWF0Y2hbMV0gLyAxMDA7XG4gICAgICAgICAgICBoYW5kT3B0LnBhcmFtcy5veSA9IChtYXRjaFsyXSB8fCBtYXRjaFsxXSkgLyAxMDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVyLnNldHVwKHtcbiAgICAgICAgaGFuZDogaGFuZE9wdFxuICAgIH0pO1xuICAgIHRoaXMuX2hhbmRsZXIuYWN0aXZhdGUoKTtcblxuICAgIGFtLmRlSGFuZGxlckNvbnQuYXBwZW5kQ2hpbGQodGhpcy5faGFuZGxlci5kb21FbGVtKTtcbn07XG5cbnAuX2JsdXJIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fY3VyckhhbmRsZWREZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLl9oYW5kbGVyICYmIHRoaXMuX2hhbmRsZXIuZG9tRWxlbSAmJiB0aGlzLl9oYW5kbGVyLmRvbUVsZW0ucGFyZW50Tm9kZSkge1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXIuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVyLmRvbUVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9oYW5kbGVyLmRvbUVsZW0pO1xuICAgIH1cbn07XG5cbnAuX21vdmVCbGFua1BhcmFtZXRlckRvd24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIXRoaXMuX2JsYW5rUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gdGhpcy5fcGFyYW1ldGVycy5pbmRleE9mKHRoaXMuX2JsYW5rUGFyYW1ldGVyKTtcblxuICAgIGlmIChpZHggPCB0aGlzLl9wYXJhbWV0ZXJzLmxlbmd0aCAtIDEpIHtcblxuICAgICAgICB0aGlzLm1vdmVQYXJhbWV0ZXIodGhpcy5fYmxhbmtQYXJhbWV0ZXIsICh0aGlzLl9wYXJhbWV0ZXJzLmxlbmd0aCAtIDEpIC0gaWR4KTtcbiAgICB9XG59O1xuXG5wLl9oaWRlU2VsZWN0ZWRFbGVtcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLl9pc0hpZGluZ1NlbGVjdGVkRWxlbXMpIHJldHVybjtcbiAgICB0aGlzLl9pc0hpZGluZ1NlbGVjdGVkRWxlbXMgPSB0cnVlO1xuXG4gICAgdGhpcy5fdGdnbEhpZGUuc2V0VG9nZ2xlKHRydWUpO1xuXG4gICAgdGhpcy5fc2VsZWN0ZWRFbGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChkZSkge1xuXG4gICAgICAgIGRlLl9hbVZpc2liaWxpdHlTYXZlID0gZGUuc3R5bGUudmlzaWJpbGl0eTtcbiAgICAgICAgZGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH0pO1xufTtcblxucC5fc2hvd1NlbGVjdGVkRWxlbXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIXRoaXMuX2lzSGlkaW5nU2VsZWN0ZWRFbGVtcykgcmV0dXJuO1xuICAgIHRoaXMuX2lzSGlkaW5nU2VsZWN0ZWRFbGVtcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGdnbEhpZGUuc2V0VG9nZ2xlKGZhbHNlKTtcblxuICAgIHRoaXMuX3NlbGVjdGVkRWxlbXMuZm9yRWFjaChmdW5jdGlvbiAoZGUpIHtcblxuICAgICAgICBkZS5zdHlsZS52aXNpYmlsaXR5ID0gZGUuX2FtVmlzaWJpbGl0eVNhdmU7XG4gICAgfSk7XG59O1xuXG5wLl9zaG93UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuX2lzU2hvd2luZ1BhcmFtcykgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2hvd2luZ1BhcmFtcyA9IHRydWU7XG5cbiAgICB0aGlzLl90Z2dsUGFyYW1zLnNldFRvZ2dsZSh0cnVlKTtcbiAgICB0aGlzLmVtaXQoJ2NoYW5nZUhlaWdodCcsIHRoaXMpO1xufTtcblxucC5faGlkZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5faXNTaG93aW5nUGFyYW1zKSByZXR1cm47XG4gICAgdGhpcy5faXNTaG93aW5nUGFyYW1zID0gZmFsc2U7XG5cbiAgICB0aGlzLl90Z2dsUGFyYW1zLnNldFRvZ2dsZShmYWxzZSk7XG4gICAgdGhpcy5lbWl0KCdjaGFuZ2VIZWlnaHQnLCB0aGlzKTtcbn07XG5cblxuXG5cblxuXG5cblxucC5fb25TZWxlY3RDbGljayA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuc2VsZWN0KCk7XG59O1xuXG5wLl9vbkNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbihwYXJhbXMsIHR5cGUpIHtcblxuICAgIHZhciB0aW1lID0gYW0udGltZWxpbmUuY3VyclRpbWUsIFxuICAgICAgICBwcm9wLCB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09PSAndHJhbnNmb3JtJykge1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3R4JyB8fCBuYW1lID09PSAndHknIHx8IG5hbWUgPT09ICd0eicgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAncngnIHx8IG5hbWUgPT09ICdyeScgfHwgbmFtZSA9PT0gJ3J6JyB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdzeCcgfHwgbmFtZSA9PT0gJ3N5JyB8fCBuYW1lID09PSAnc3onKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSBwYXJhbXNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICBwcm9wID0gdGhpcy5hZGRQYXJhbWV0ZXIoe25hbWU6ICd0cmFuc2Zvcm0nfSk7XG4gICAgICAgICAgICAgICAgcHJvcC5hZGRLZXkoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCdveCcgaW4gcGFyYW1zICYmICdveScgaW4gcGFyYW1zKSB7XG5cbiAgICAgICAgICAgIHByb3AgPSB0aGlzLmFkZFBhcmFtZXRlcih7bmFtZTogJ3RyYW5zZm9ybS1vcmlnaW4nfSk7XG4gICAgICAgICAgICBwcm9wLmFkZEtleSh7XG4gICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKHBhcmFtcy5veCoxMDApLnRvRml4ZWQoMikgKyAnJSAnICsgKHBhcmFtcy5veSoxMDApLnRvRml4ZWQoMikgKyAnJSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJUaW1lKHRpbWUpO1xuICAgIHRoaXMuX2ZvY3VzSGFuZGxlcigpO1xufTtcblxucC5fb25DaGFuZ2VUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuICAgIGlmICh0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyVGltZSh0aW1lKTtcbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIoKTtcbiAgICB0aGlzLl9yZWZyZXNoVGdnbEtleSgpO1xufTtcblxucC5fb25DaGFuZ2VQYXJhbWV0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnJlbmRlclRpbWUoKTtcbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIoKTtcbiAgICB0aGlzLl9yZWZyZXNoSGVhZEtleWxpbmUoKTtcbiAgICB0aGlzLl9yZWZyZXNoVGdnbEtleSgpO1xuXG4gICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbn07XG5cblxucC5fb25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIoKTtcbn07XG5cbnAuX29uRGVsZXRlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHBhcmFtKSB7XG5cbiAgICB0aGlzLnJlbW92ZVBhcmFtZXRlcihwYXJhbSk7XG59O1xuXG5wLl9vbk1vdmVQYXJhbWV0ZXIgPSBmdW5jdGlvbiAocGFyYW0sIHdheSkge1xuXG4gICAgdGhpcy5tb3ZlUGFyYW1ldGVyKHBhcmFtLCB3YXkpO1xufTtcblxucC5fb25DaGFuZ2VCbGFua1BhcmFtZXRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLl9ibGFua1BhcmFtZXRlcikge1xuXG4gICAgICAgIHRoaXMuX2JsYW5rUGFyYW1ldGVyLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZUJsYW5rUGFyYW1ldGVyKTtcbiAgICAgICAgdGhpcy5fYmxhbmtQYXJhbWV0ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fYmxhbmtQYXJhbWV0ZXIgPSB0aGlzLmFkZFBhcmFtZXRlcigpO1xuICAgIHRoaXMuX2JsYW5rUGFyYW1ldGVyLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZUJsYW5rUGFyYW1ldGVyKTtcbn07XG5cbnAuX29uQ2xpY2tUZ2dsS2V5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRpbWUgPSBhbS50aW1lbGluZS5jdXJyVGltZSxcbiAgICAgICAgYWxsSGF2ZUtleSA9IHRoaXMuX2lzQWxsUGFyYW1zSGF2ZUtleSh0aW1lKSxcbiAgICAgICAgZmxhZyA9IGFtLmhpc3Rvcnkuc3RhcnRGbGFnKCk7XG5cbiAgICB0aGlzLl9wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG5cbiAgICAgICAgaWYgKHBhcmFtLmlzVmFsaWQoKSkge1xuXG4gICAgICAgICAgICBpZiAoYWxsSGF2ZUtleSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLnJlbW92ZUtleShwYXJhbS5nZXRLZXkodGltZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uYWRkS2V5KHt0aW1lOiB0aW1lfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3JlZnJlc2hUZ2dsS2V5KCk7XG5cbiAgICBhbS5oaXN0b3J5LmVuZEZsYWcoZmxhZyk7XG59O1xuXG5wLl9vbkNsaWNrVGdnbFNob3dQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNTaG93aW5nUGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2hpZGVQYXJhbXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3Nob3dQYXJhbXMoKTtcbiAgICB9XG59O1xuXG5wLl9vbkNsaWNrVGdnbEhpZGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNIaWRpbmdTZWxlY3RlZEVsZW1zKSB7XG4gICAgICAgIHRoaXMuX3Nob3dTZWxlY3RlZEVsZW1zKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9oaWRlU2VsZWN0ZWRFbGVtcygpO1xuICAgIH1cbn07XG5cbnAuX29uQ2xpY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZGlhbG9nU2VxdU9wdGlvbnMuc2hvdyh7XG4gICAgICAgIG5hbWU6IHRoaXMuX25hbWUsXG4gICAgICAgIHNlbGVjdG9yczogdGhpcy5fc2VsZWN0b3JzLFxuICAgICAgICBmaWxsOiB0aGlzLmZpbGwsXG4gICAgICAgIGl0ZXJhdGlvbnM6IHRoaXMuaXRlcmF0aW9ucyxcbiAgICAgICAgb25DaGFuZ2VOYW1lOiB0aGlzLl9vbkNoYW5nZU5hbWUsXG4gICAgICAgIG9uQ2hhbmdlRmlsbDogdGhpcy5fb25DaGFuZ2VGaWxsLFxuICAgICAgICBvbkNoYW5nZUl0ZXJhdGlvbnM6IHRoaXMuX29uQ2hhbmdlSXRlcmF0aW9ucyxcbiAgICAgICAgb25DaGFuZ2VTZWxlY3RvcnM6IHRoaXMuX29uQ2hhbmdlU2VsZWN0b3JzXG4gICAgfSk7XG59O1xuXG5wLl9vbkNoYW5nZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbn07XG5cbnAuX29uQ2hhbmdlRmlsbCA9IGZ1bmN0aW9uIChmaWxsKSB7XG5cbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xufTtcblxucC5fb25DaGFuZ2VJdGVyYXRpb25zID0gZnVuY3Rpb24gKGl0YXJhdGlvbnMpIHtcblxuICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0YXJhdGlvbnM7XG59O1xuXG5wLl9vbkNoYW5nZVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcblxuICAgIHRoaXMuX3NlbGVjdG9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3NlbGVjdG9ycyA9IHRoaXMuX3NlbGVjdG9ycy5jb25jYXQoc2VsZWN0b3JzKTtcblxuICAgIHRoaXMuX3NlbGVjdEVsZW1lbnRzKCk7XG5cbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRFbGVtcy5pbmRleE9mKHRoaXMuX2N1cnJIYW5kbGVkRGUpID09PSAtMSkge1xuXG4gICAgICAgIHRoaXMuX2N1cnJIYW5kbGVkRGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZm9jdXNIYW5kbGVyKHRoaXMuX2N1cnJIYW5kbGVkRGUgfHwgdGhpcy5fc2VsZWN0ZWRFbGVtc1swXSk7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnAuX2lzQWxsUGFyYW1zSGF2ZUtleSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVycy5ldmVyeShmdW5jdGlvbiAocGFyYW0pIHtcblxuICAgICAgICByZXR1cm4gcGFyYW0uZ2V0S2V5KHRpbWUpIHx8ICFwYXJhbS5pc1ZhbGlkKCk7XG4gICAgfSk7XG59O1xuXG5wLl9nZXRQYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlcnMuZmluZChmdW5jdGlvbihwYXJhbSkge1xuXG4gICAgICAgIHJldHVybiBwYXJhbS5uYW1lID09PSBuYW1lO1xuICAgIH0pO1xufTtcblxucC5fcmVmcmVzaFRnZ2xLZXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl90Z2dsS2V5LnNldFRvZ2dsZSggdGhpcy5faXNBbGxQYXJhbXNIYXZlS2V5KGFtLnRpbWVsaW5lLmN1cnJUaW1lKSk7XG59O1xuXG5cbnAuX3JlZnJlc2hIZWFkS2V5bGluZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aW1lcyA9IFtdLCBvbGRLZXlzID0gdGhpcy5faGVhZEtleXMuc3BsaWNlKDApO1xuXG4gICAgdGhpcy5fcGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuXG4gICAgICAgIHRpbWVzID0gdGltZXMuY29uY2F0KHBhcmFtLmdldEtleVRpbWVzKCkpO1xuICAgIH0pO1xuXG4gICAgdGltZXMgPSBfLnVuaXEodGltZXMpO1xuXG4gICAgdGltZXMuZm9yRWFjaChmdW5jdGlvbiAodGltZSkge1xuXG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzLnBvcCgpIHx8IG5ldyBLZXkoe1xuICAgICAgICAgICAgZGVLZXlsaW5lOiB0aGlzLl9kZUhlYWRLZXlsaW5lLFxuICAgICAgICAgICAgZWFzZTogJ25vbmUnLFxuICAgICAgICAgICAgY29sb3I6ICcjMDYzNTAxJ1xuICAgICAgICB9KTtcblxuICAgICAgICBrZXkuZG9tRWxlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnOy8vaGFjayEgdW50aWwgZmluaXNoIHRoZSBjb250cm9sIHdpdGggaGVhZCBrZXlzXG5cbiAgICAgICAga2V5LnRpbWUgPSB0aW1lO1xuXG4gICAgICAgIHRoaXMuX2hlYWRLZXlzLnB1c2goa2V5KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIF8uaW52b2tlKF8uZGlmZmVyZW5jZShvbGRLZXlzLCB0aGlzLl9oZWFkS2V5cyksICdkaXNwb3NlJyk7XG59O1xuXG5wLl9yZWZyZXNoUGFyYW1ldGVyT3JkZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG5cbiAgICAgICAgdGhpcy5kZU9wdGlvbnMuYXBwZW5kQ2hpbGQocGFyYW0uZGVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5kZUtleXMuYXBwZW5kQ2hpbGQocGFyYW0uZGVLZXlsaW5lKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxucC5fY3JlYXRlSGVhZE9wdGlvbnMgPSBmdW5jdGlvbiAoKXtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBkZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBkZS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIGRlLnN0eWxlLmhlaWdodCA9IHRoaXMuX2Jhc2VIICsgJ3B4JztcbiAgICBkZS5zdHlsZS5iYWNrZ3JvdW5kID0gJ2xpbmVhci1ncmFkaWVudCh0byBib3R0b20sICMwNjM1MDEgMTglLCMwNjQxMDAgOTYlKSc7XG4gICAgdGhpcy5kZU9wdGlvbnMuYXBwZW5kQ2hpbGQoZGUpO1xuXG4gICAgdGhpcy5kZUhpZ2hsaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZGVIaWdobGlnaHQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIHRoaXMuZGVIaWdobGlnaHQuc3R5bGUud2lkdGggPSAnMnB4JztcbiAgICB0aGlzLmRlSGlnaGxpZ2h0LnN0eWxlLmhlaWdodCA9IHRoaXMuX2Jhc2VIICsgJ3B4JztcbiAgICB0aGlzLmRlSGlnaGxpZ2h0LnN0eWxlLmJhY2tncm91bmQgPSAnZ29sZCc7XG4gICAgdGhpcy5kZUhpZ2hsaWdodC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICBkZS5hcHBlbmRDaGlsZCh0aGlzLmRlSGlnaGxpZ2h0KTtcblxuICAgIHRoaXMuX3RnZ2xQYXJhbXMgPSBhbWd1aS5jcmVhdGVUb2dnbGVJY29uQnRuKHtcbiAgICAgICAgaWNvbk9uOiAnYW5nbGUtZG93bicsXG4gICAgICAgIGljb25PZmY6ICdhbmdsZS1yaWdodCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5fYmFzZUgsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xpY2tUZ2dsU2hvd1BhcmFtcyxcbiAgICAgICAgcGFyZW50OiBkZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fZGVOYW1lID0gYW1ndWkuY3JlYXRlTGFiZWwoe2NhcHRpb246IHRoaXMuX25hbWUsIHBhcmVudDogZGV9KTtcbiAgICB0aGlzLl9kZU5hbWUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fYmFzZUggICsgJ3B4JztcbiAgICB0aGlzLl9kZU5hbWUuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIHRoaXMuX2RlTmFtZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tOYW1lKTtcblxuICAgIHZhciBkZU5hbWVJY29uID0gYW1ndWkuY3JlYXRlSWNvbih7XG4gICAgICAgIGljb246ICdjb2cnLFxuICAgICAgICBwYXJlbnQ6IGRlXG4gICAgfSk7XG4gICAgZGVOYW1lSWNvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuX2RlTmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge2RlTmFtZUljb24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO30pO1xuICAgIHRoaXMuX2RlTmFtZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge2RlTmFtZUljb24uc3R5bGUuZGlzcGxheSA9ICdub25lJzt9KTtcblxuICAgIHZhciBzcGFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNwYWNlLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICBzcGFjZS5zdHlsZS5mbGV4ID0gJzEnO1xuICAgIHNwYWNlLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgZGUuYXBwZW5kQ2hpbGQoc3BhY2UpO1xuXG4gICAgdGhpcy5fdGdnbEhpZGUgPSBhbWd1aS5jcmVhdGVUb2dnbGVJY29uQnRuKHtcbiAgICAgICAgaWNvbk9uOiAnZXllLW9mZicsIFxuICAgICAgICBpY29uT2ZmOiAnZXllJywgXG4gICAgICAgIGhlaWdodDogdGhpcy5fYmFzZUgsXG4gICAgICAgIGRlZmF1bHRUb2dnbGU6IGZhbHNlLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrVGdnbEhpZGUsXG4gICAgICAgIGNoYW5nZUNvbG9yOiB0cnVlLFxuICAgICAgICBwYXJlbnQ6IGRlXG4gICAgfSk7XG5cbiAgICB0aGlzLl90Z2dsS2V5ID0gYW1ndWkuY3JlYXRlVG9nZ2xlSWNvbkJ0bih7XG4gICAgICAgIGljb246ICdrZXknLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2Jhc2VILFxuICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrVGdnbEtleSxcbiAgICAgICAgY2hhbmdlQ29sb3I6IHRydWUsXG4gICAgICAgIHBhcmVudDogZGVcbiAgICB9KTtcbiAgICB0aGlzLl9yZWZyZXNoVGdnbEtleSgpO1xuXG4gICAgYW1ndWkuYmluZERyb3Bkb3duKHtcbiAgICAgICAgYXNDb250ZXh0TWVudTogdHJ1ZSxcbiAgICAgICAgZGVUYXJnZXQ6IGRlLFxuICAgICAgICBkZU1lbnU6IGFtZ3VpLmNyZWF0ZURyb3Bkb3duKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7dGV4dDogJ21vdmUgdXAnLCBvblNlbGVjdDogdGhpcy5lbWl0LmJpbmQodGhpcywgJ21vdmUnLCB0aGlzLCAtMSl9LFxuICAgICAgICAgICAgICAgIHt0ZXh0OiAnbW92ZSBkb3duJywgb25TZWxlY3Q6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdtb3ZlJywgdGhpcywgMSl9LFxuICAgICAgICAgICAgICAgIHt0ZXh0OiAnZGVsZXRlJywgb25TZWxlY3Q6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdkZWxldGUnLCB0aGlzKX0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGU7XG59O1xuXG5wLmlzT3duZWREb21FbGVtID0gZnVuY3Rpb24gKGRlKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRFbGVtcy5pbmRleE9mKGRlKSAhPT0gLTE7XG59O1xuXG5wLl9zZWxlY3RFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICB0aGlzLl9zZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblxuICAgICAgICB2YXIgaXRlbXMgPSBhbS5kZVJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGl0ZW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXRlbXMpO1xuICAgICAgICBsaXN0ID0gbGlzdC5jb25jYXQoaXRlbXMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VsZWN0ZWRFbGVtcyA9IGxpc3Q7XG59O1xuXG5wLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBhbS50aW1lbGluZS5yZW1vdmVMaXN0ZW5lcignY2hhbmdlVGltZScsIHRoaXMuX29uQ2hhbmdlVGltZSk7XG5cbiAgICAvL1RPRE9cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3NzU2VxdWVuY2U7XG5cblxuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBDc3NQYXJhbWV0ZXIgPSByZXF1aXJlKCcuL0Nzc1BhcmFtZXRlcicpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4vS2V5Jyk7XG52YXIgYW1ndWkgPSByZXF1aXJlKCcuLi8uLi9hbWd1aScpO1xuXG52YXIgQkFTRV9WQUxVRVMgPSB7XG4gICAgdHg6IDAsIHR5OiAwLCB0ejogMCxcbiAgICByeDogMCwgcnk6IDAsIHJ6OiAwLFxuICAgIHN4OiAxLCBzeTogMSwgc3o6IDEsXG4gICAgc2tld1g6IDAsIHNrZXdZOiAwLFxuICAgIHBlcnNwZWN0aXZlOiAwXG59O1xuXG52YXIgUFJFQ0lTSU9OUyA9IHsgXG4gICAgdHg6IDAsIHR5OiAwLCB0ejogMCxcbiAgICByeDogMiwgcnk6IDIsIHJ6OiAyLFxuICAgIHN4OiAyLCBzeTogMiwgc3o6IDIsXG4gICAgc2tld1g6IDIsIHNrZXdZOiAyLFxuICAgIHBlcnNwZWN0aXZlOiAwXG59O1xuXG5mdW5jdGlvbiBDc3NUcmFuc2Zvcm1QYXJhbWV0ZXIgKG9wdCkge1xuXG4gICAgdGhpcy5fbm9CYXNlS2V5VmFsdWVJbnB1dCA9IHRydWU7XG5cbiAgICB0aGlzLl9pbnB1dHMgPSB7fTtcbiAgICB0aGlzLl9pbnB1dHMzZCA9IFtdO1xuICAgIHRoaXMuX2xpbmVDb3VudCA9IDY7XG5cbiAgICBDc3NQYXJhbWV0ZXIuY2FsbCh0aGlzLCBfLmV4dGVuZCh7bmFtZTogJ3RyYW5zZm9ybSd9LCBvcHQpKTtcblxuICAgIHRoaXMuX29uVG9nZ2xlM2QgPSB0aGlzLl9vblRvZ2dsZTNkLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9jcmVhdGVUcmFuc2Zvcm1JbnB1dHMoKTtcblxuICAgIHRoaXMuX2J0blRvZ2dsZTNkID0gYW1ndWkuY3JlYXRlSWNvbkJ0bih7XG4gICAgICAgIGljb246ICdjdWJlJyxcbiAgICAgICAgaGVpZ2h0OiAyMSxcbiAgICAgICAgcGFyZW50OiB0aGlzLmRlT3B0aW9ucyxcbiAgICAgICAgb25DbGljazogdGhpcy5fb25Ub2dnbGUzZCxcbiAgICB9KTtcbiAgICB0aGlzLmRlT3B0aW9ucy5pbnNlcnRCZWZvcmUodGhpcy5fYnRuVG9nZ2xlM2QsIHRoaXMuX2J0blRvZ2dsZUtleSk7XG4gICAgXG4gICAgdGhpcy5fc2hvd2luZzNkID0gIXRoaXMuX3Nob3dpbmczZDsvL1RPRE8gZG8gdGhpcyBzb21laG93IGVsc2UhXG4gICAgdGhpcy5fc2hvd0hpZGUzZCghdGhpcy5fc2hvd2luZzNkKTtcbn1cblxuaW5oZXJpdHMoQ3NzVHJhbnNmb3JtUGFyYW1ldGVyLCBDc3NQYXJhbWV0ZXIpO1xudmFyIHAgPSBDc3NUcmFuc2Zvcm1QYXJhbWV0ZXIucHJvdG90eXBlO1xuXG5cbnAuZ2V0U2F2ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzYXZlID0gQ3NzUGFyYW1ldGVyLnByb3RvdHlwZS5nZXRTYXZlLmNhbGwodGhpcyk7XG5cbiAgICBzYXZlLnNob3dpbmczZCA9IHRoaXMuX3Nob3dpbmczZDtcblxuICAgIHJldHVybiBzYXZlO1xufTtcblxucC51c2VTYXZlID0gZnVuY3Rpb24oc2F2ZSkge1xuXG4gICAgQ3NzUGFyYW1ldGVyLnByb3RvdHlwZS51c2VTYXZlLmNhbGwodGhpcywgc2F2ZSk7XG5cbiAgICB0aGlzLl9zaG93aW5nM2QgPSAhIXNhdmUuc2hvd2luZzNkO1xufTtcblxucC5nZXRWYWx1ZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cbiAgICByZXR1cm4gY29udmVydFRyYW5zZm9ybVZhbHVlKHRoaXMuZ2V0UmF3VmFsdWUodGltZSkpO1xufTtcblxucC5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIodGltZSkpIHtcbiAgICAgICAgdGltZSA9IGFtLnRpbWVsaW5lLmN1cnJUaW1lO1xuICAgIH1cblxuICAgIHZhciBiZWZvcmUsIGFmdGVyLCBzYW1lO1xuXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICBpZiAoa2V5LnRpbWUgPT09IHRpbWUpIHtcbiAgICAgICAgXG4gICAgICAgICAgICBzYW1lID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleS50aW1lIDwgdGltZSAmJiAoIWJlZm9yZSB8fCBiZWZvcmUudGltZSA8IGtleS50aW1lKSkge1xuICAgICAgICBcbiAgICAgICAgICAgIGJlZm9yZSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkudGltZSA+IHRpbWUgJiYgKCFhZnRlciB8fCBhZnRlci50aW1lID4ga2V5LnRpbWUpKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgYWZ0ZXIgPSBrZXk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHNhbWUudmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGlmIChhZnRlciAmJiBiZWZvcmUpIHtcblxuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWQgPSB7fSxcbiAgICAgICAgICAgICAgICBwID0gKHRpbWUgLSBiZWZvcmUudGltZSkgLyAoYWZ0ZXIudGltZSAtIGJlZm9yZS50aW1lKSxcbiAgICAgICAgICAgICAgICBhdiA9IGFmdGVyLnZhbHVlLFxuICAgICAgICAgICAgICAgIGJ2ID0gYmVmb3JlLnZhbHVlO1xuXG4gICAgICAgICAgICBwID0gdGhpcy5fYXBwbHlFYXNlKGJlZm9yZS5lYXNlLCBwKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYnYpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIGF2KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZFtuYW1lXSA9IGJ2W25hbWVdICsgKGF2W25hbWVdIC0gYnZbbmFtZV0pICogcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRbbmFtZV0gPSBidltuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBfLmNsb25lKGJlZm9yZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIF8uY2xvbmUoYWZ0ZXIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF8uY2xvbmUoQkFTRV9WQUxVRVMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxucC5hZGRLZXkgPSBmdW5jdGlvbiAob3B0LCBza2lwSGlzdG9yeSkge1xuXG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KG9wdC50aW1lKTtcblxuICAgIGlmIChrZXkpIHtcblxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBvcHQpIHtcblxuICAgICAgICAgICAgaWYgKCFza2lwSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIGFtLmhpc3Rvcnkuc2F2ZUNoYWluKGtleSwgXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmFkZEtleSwgdGhpcywgXy5jbG9uZURlZXAoa2V5LmdldFNhdmUoKSksIHRydWVdLCBcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuYWRkS2V5LCB0aGlzLCBfLmNsb25lRGVlcChvcHQpLCB0cnVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGtleS52YWx1ZSA9IF8uZXh0ZW5kKGtleS52YWx1ZSwgb3B0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAga2V5ID0gbmV3IEtleShfLmV4dGVuZCh7ZGVLZXlsaW5lOiB0aGlzLmRlS2V5bGluZX0sIG9wdCkpO1xuICAgICAgICBrZXkudmFsdWUgPSBfLmV4dGVuZCh0aGlzLmdldFJhd1ZhbHVlKG9wdC50aW1lKSwgb3B0LnZhbHVlKTtcblxuICAgICAgICBrZXkub24oJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZUtleVRpbWUpO1xuICAgICAgICBrZXkub24oJ2RlbGV0ZScsIHRoaXMuX29uRGVsZXRlS2V5KTtcblxuICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcblxuICAgICAgICBpZiAoIXNraXBIaXN0b3J5KSB7XG4gICAgICAgICAgICBhbS5oaXN0b3J5LmNsb3NlQ2hhaW4oa2V5KTtcbiAgICAgICAgICAgIGFtLmhpc3Rvcnkuc2F2ZShcbiAgICAgICAgICAgICAgICBbdGhpcy5yZW1vdmVLZXksIHRoaXMsIG9wdC50aW1lLCB0cnVlXSwgXG4gICAgICAgICAgICAgICAgW3RoaXMuYWRkS2V5LCB0aGlzLCBvcHQsIHRydWVdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3JlZnJlc2hJbnB1dCgpO1xuICAgIHRoaXMuX3JlZnJlc2hCdG5Ub2dnbGVLZXkoKTtcblxuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG5cbiAgICByZXR1cm4ga2V5O1xufTtcblxucC5fcmVmcmVzaElucHV0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGlucHV0cyA9IHRoaXMuX2lucHV0cyxcbiAgICAgICAgdmFsdWVzID0gdGhpcy5nZXRSYXdWYWx1ZSgpO1xuXG4gICAgT2JqZWN0LmtleXMoaW5wdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICBpZiAoaW5wdXRzW2tleV0udmFsdWUgIT09IHZhbHVlc1trZXldKSB7XG5cbiAgICAgICAgICAgIGlucHV0c1trZXldLnZhbHVlID0gdmFsdWVzW2tleV0udG9GaXhlZChQUkVDSVNJT05TW2tleV0pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocCwgJ2hlaWdodCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIICogdGhpcy5fbGluZUNvdW50O1xuICAgIH1cbn0pO1xuXG5wLl9vbkNoYW5nZUlucHV0ID0gZnVuY3Rpb24gKGUpIHtcblxuICAgIHZhciBpbnAgPSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHZhbHVlID0ge307XG5cbiAgICB2YWx1ZVtpbnAuX2tleV0gPSBwYXJzZUZsb2F0KGlucC52YWx1ZSk7XG5cbiAgICB0aGlzLmFkZEtleSh7XG4gICAgICAgIHRpbWU6IGFtLnRpbWVsaW5lLmN1cnJUaW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfSk7XG59O1xuXG5wLl9vblRvZ2dsZTNkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fc2hvd0hpZGUzZCghdGhpcy5fc2hvd2luZzNkKTtcbn07XG5cbnAuX3Nob3dIaWRlM2QgPSBmdW5jdGlvbiAoc2hvdykge1xuXG4gICAgaWYgKHRoaXMuX3Nob3dIaWRlM2QgPT09IHNob3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3Nob3dpbmczZCA9IHNob3c7XG5cbiAgICB0aGlzLl9idG5Ub2dnbGUzZC5zdHlsZS5jb2xvciA9IHNob3cgPyBhbWd1aS5jb2xvci50ZXh0IDogYW1ndWkuY29sb3IudGV4dEluYWN0aXZlO1xuXG4gICAgdGhpcy5faW5wdXRzM2QuZm9yRWFjaChmdW5jdGlvbiAoZGUpIHtcblxuICAgICAgICBkZS5zdHlsZS52aXNpYmlsaXR5ID0gc2hvdyA/ICQoZGUpLnNob3coKSA6ICQoZGUpLmhpZGUoKTtcbiAgICB9KTtcbn07XG5cbnAuX2NyZWF0ZVRyYW5zZm9ybUlucHV0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkZU9wdGlvbnMgPSB0aGlzLmRlT3B0aW9ucyxcbiAgICAgICAgbGluZUggPSB0aGlzLl9saW5lSCxcbiAgICAgICAgaW5wdXRzID0gdGhpcy5faW5wdXRzLFxuICAgICAgICBpbnB1dHMzZCA9IHRoaXMuX2lucHV0czNkLFxuICAgICAgICBvbkNoYW5nZUlucHV0ID0gdGhpcy5fb25DaGFuZ2VJbnB1dDtcblxuICAgIGRlT3B0aW9ucy5zdHlsZS5oZWlnaHQgPSAobGluZUggKiB0aGlzLl9saW5lQ291bnQpICsgJ3B4JztcbiAgICBkZU9wdGlvbnMuc3R5bGUuZmxleFdyYXAgPSAnd3JhcCc7XG5cbiAgICB0aGlzLmRlS2V5bGluZS5zdHlsZS5oZWlnaHQgPSBsaW5lSCArICdweCc7XG4gICAgdGhpcy5kZUtleWxpbmUuc3R5bGUubWFyZ2luQm90dG9tID0gKGxpbmVIICogKHRoaXMuX2xpbmVDb3VudC0xKSkgKyAncHgnO1xuXG4gICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLnRleHRDb250ZW50ID0gJ3RyYW5zZm9ybSc7XG4gICAgbGFiZWwuc3R5bGUuZmxleCA9ICcxJztcbiAgICBsYWJlbC5zdHlsZS5oZWlnaHQgPSBsaW5lSCArICdweCc7XG4gICAgJChkZU9wdGlvbnMpLnByZXBlbmQobGFiZWwpO1xuXG4gICAgdmFyIHJvdyA9IGNyZWF0ZVJvdygpO1xuICAgIGNyZWF0ZUlucHV0KCd0eCcsICd0eCcsIHJvdyk7XG4gICAgY3JlYXRlSW5wdXQoJ3R5JywgJ3knLCByb3cpO1xuICAgIGNyZWF0ZUlucHV0KCd0eicsICd6Jywgcm93LCB0cnVlKTtcbiAgICByb3cgPSBjcmVhdGVSb3coKTtcbiAgICBjcmVhdGVJbnB1dCgncngnLCAncngnLCByb3csIHRydWUpO1xuICAgIGNyZWF0ZUlucHV0KCdyeScsICd5Jywgcm93LCB0cnVlKTtcbiAgICBjcmVhdGVJbnB1dCgncnonLCAncnonLCByb3cpO1xuICAgIHJvdyA9IGNyZWF0ZVJvdygpO1xuICAgIGNyZWF0ZUlucHV0KCdzeCcsICdzeCcsIHJvdyk7XG4gICAgY3JlYXRlSW5wdXQoJ3N5JywgJ3knLCByb3cpO1xuICAgIGNyZWF0ZUlucHV0KCdzeicsICd6Jywgcm93LCB0cnVlKTtcbiAgICByb3cgPSBjcmVhdGVSb3coKTtcbiAgICBjcmVhdGVJbnB1dCgnc2tld1gnLCAnc2tld1gnLCByb3cpO1xuICAgIGNyZWF0ZUlucHV0KCdza2V3WScsICdza2V3WScsIHJvdyk7XG4gICAgcm93ID0gY3JlYXRlUm93KHRydWUpO1xuICAgIGNyZWF0ZUlucHV0KCdwZXJzcGVjdGl2ZScsICdwZXJzcGVjdGl2ZScsIHJvdyk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3coaTNkKSB7XG5cbiAgICAgICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgIGRlLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBkZS5zdHlsZS5oZWlnaHQgPSBsaW5lSCArICdweCc7XG4gICAgICAgIC8vIGRlLnN0eWxlLmJhY2tncm91bmQgPSAnbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgIzE4NEYxMiAxOCUsIzFCNDQxNyA5NiUpJztcbiAgICAgICAgaWYgKGkzZCkge1xuICAgICAgICAgICAgaW5wdXRzM2QucHVzaChkZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVPcHRpb25zLmFwcGVuZENoaWxkKGRlKTtcbiAgICAgICAgcmV0dXJuIGRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0KGtleSwgY2FwdGlvbiwgcGFyZW50LCBpM2QpIHtcblxuICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gY2FwdGlvbjtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgICB2YXIgaW5wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wLl9rZXkgPSBrZXk7XG4gICAgICAgIGlucC50eXBlID0gJ251bWJlcic7XG4gICAgICAgIGlucC52YWx1ZSA9IEJBU0VfVkFMVUVTW2tleV07XG4gICAgICAgIGlucC5zdHlsZS5mbGV4ID0gJzEnO1xuICAgICAgICBpbnAuc3R5bGUuZm9udEZhbWlseSA9IGFtZ3VpLkZPTlRfRkFNSUxZO1xuICAgICAgICBpbnAuc3R5bGUuYmFja2dyb3VuZCA9ICdyZ2JhKDI1NSwyNTUsMjU1LC4xMiknO1xuICAgICAgICBpbnAuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICAgICAgICBpbnAuc3R5bGUubWFyZ2luID0gJzAgMCAwIDNweCc7XG4gICAgICAgIGlucC5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgICAgIGlucC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZUlucHV0KTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGlucCk7XG5cbiAgICAgICAgaWYgKGkzZCkge1xuICAgICAgICAgICAgaW5wdXRzM2QucHVzaChsYWJlbCwgaW5wKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dHNba2V5XSA9IGlucDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtVmFsdWUodikge1xuXG4gICAgdmFyIHR4ID0gJ3R4JyBpbiB2ICYmIHYudHggIT09IEJBU0VfVkFMVUVTLnR4LFxuICAgICAgICB0eSA9ICd0eScgaW4gdiAmJiB2LnR5ICE9PSBCQVNFX1ZBTFVFUy50eSxcbiAgICAgICAgdHogPSAndHonIGluIHYgJiYgdi50eiAhPT0gQkFTRV9WQUxVRVMudHosXG4gICAgICAgIHJ4ID0gJ3J4JyBpbiB2ICYmIHYucnggIT09IEJBU0VfVkFMVUVTLnJ4LFxuICAgICAgICByeSA9ICdyeScgaW4gdiAmJiB2LnJ5ICE9PSBCQVNFX1ZBTFVFUy5yeSxcbiAgICAgICAgcnogPSAncnonIGluIHYgJiYgdi5yeiAhPT0gQkFTRV9WQUxVRVMucnosXG4gICAgICAgIHN4ID0gJ3N4JyBpbiB2ICYmIHYuc3ggIT09IEJBU0VfVkFMVUVTLnN4LFxuICAgICAgICBzeSA9ICdzeScgaW4gdiAmJiB2LnN5ICE9PSBCQVNFX1ZBTFVFUy5zeSxcbiAgICAgICAgc3ogPSAnc3onIGluIHYgJiYgdi5zeiAhPT0gQkFTRV9WQUxVRVMuc3osXG4gICAgICAgIHNrZXdYID0gJ3NrZWV3WCcgaW4gdiAmJiB2LnNrZXdYICE9PSBCQVNFX1ZBTFVFUy5za2V3WCxcbiAgICAgICAgc2tld1kgPSAnc2tlZXdZJyBpbiB2ICYmIHYuc2tld1kgIT09IEJBU0VfVkFMVUVTLnNrZXdZLFxuICAgICAgICBwZXJzcGVjdGl2ZSA9ICdwZXJzcGVjdGl2ZScgaW4gdiAmJiB2LnBlcnNwZWN0aXZlICE9PSBCQVNFX1ZBTFVFUy5wZXJzcGVjdGl2ZSxcbiAgICAgICAgcmV0ID0gJyc7XG5cbiAgICBpZiAodHggJiYgdHkgJiYgdHopIHJldCArPSAndHJhbnNsYXRlM2QoJyt2LnR4KydweCwnK3YudHkrJ3B4LCcrdi50eisncHgpICc7XG4gICAgZWxzZSBpZiAodHggJiYgdHkpIHJldCArPSAndHJhbnNsYXRlKCcrdi50eCsncHgsJyt2LnR5KydweCkgJztcbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR4KSByZXQgKz0gJ3RyYW5zbGF0ZVgoJyt2LnR4KydweCkgJztcbiAgICAgICAgaWYgKHR5KSByZXQgKz0gJ3RyYW5zbGF0ZVkoJyt2LnR5KydweCkgJztcbiAgICAgICAgaWYgKHR6KSByZXQgKz0gJ3RyYW5zbGF0ZVooJyt2LnR6KydweCkgJztcbiAgICB9XG5cbiAgICAvLyBpZiAocnggJiYgcnkgJiYgcnopIHJldCArPSAncm90YXRlM2QoJyt2LnJ4KydyYWQsJyt2LnJ5KydyYWQsJyt2LnJ6KydyYWQpICc7XG4gICAgLy8gZWxzZSB7XG4gICAgICAgIGlmIChyeCkgcmV0ICs9ICdyb3RhdGVYKCcrdi5yeCsncmFkKSAnO1xuICAgICAgICBpZiAocnkpIHJldCArPSAncm90YXRlWSgnK3YucnkrJ3JhZCkgJztcbiAgICAgICAgaWYgKHJ6KSByZXQgKz0gJ3JvdGF0ZSgnK3YucnorJ3JhZCkgJztcbiAgICAvLyB9XG5cbiAgICBpZiAoc3ggJiYgc3kgJiYgc3opIHJldCArPSAnc2NhbGUzZCgnK3Yuc3grJywnK3Yuc3krJywnK3Yuc3orJykgJztcbiAgICBlbHNlIGlmIChzeCAmJiBzeSkgcmV0ICs9ICdzY2FsZSgnK3Yuc3grJywnK3Yuc3krJykgJztcbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN4KSByZXQgKz0gJ3NjYWxlWCgnK3Yuc3grJykgJztcbiAgICAgICAgaWYgKHN5KSByZXQgKz0gJ3NjYWxlWSgnK3Yuc3krJykgJztcbiAgICAgICAgaWYgKHN6KSByZXQgKz0gJ3NjYWxlWignK3Yuc3orJykgJztcbiAgICB9XG5cbiAgICBpZiAoc2tld1ggJiYgc2tld1kpIHJldCArPSAnc2tldygnK3Yuc2tld3grJ3JhZCwnK3Yuc2tld1krJ3JhZCkgJztcbiAgICBlbHNlIGlmIChza2V3WCkgcmV0ICs9ICdza2V3WCgnK3Yuc2tld1grJ3JhZCkgJztcbiAgICBlbHNlIGlmIChza2V3WSkgcmV0ICs9ICdza2V3WSgnK3Yuc2tld1krJ3JhZCkgJztcblxuICAgIGlmKHBlcnNwZWN0aXZlKSByZXQgKz0gJ3BlcnNwZWN0aXZlKCcrdi5wZXJzcGVjdGl2ZSsncHgpICc7XG4vLyBjb25zb2xlLmxvZyhyZXQpXG4gICAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDc3NUcmFuc2Zvcm1QYXJhbWV0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIGRpYWxvZ0tleU9wdGlvbnMgPSByZXF1aXJlKCcuL2RpYWxvZ0tleU9wdGlvbnMnKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uLy4uL2FtZ3VpJyk7XG5cbmZ1bmN0aW9uIEtleSAob3B0KSB7XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLl90aW1lID0gIDA7XG4gICAgdGhpcy5fdmFsdWUgPSAgJyc7XG4gICAgdGhpcy5fZWFzZSA9ICdsaW5lYXInO1xuICAgIHRoaXMuX2RlS2V5bGluZSA9IG9wdC5kZUtleWxpbmU7XG5cbiAgICB0aGlzLl9vbkNoYW5nZURlVGltZSA9IHRoaXMuX29uQ2hhbmdlRGVUaW1lLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TZWxlY3REcm9wZG93biA9IHRoaXMuX29uU2VsZWN0RHJvcGRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUVhc2UgPSB0aGlzLl9vbkNoYW5nZUVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVRhcGUgPSB0aGlzLl9vbkNoYW5nZVRhcGUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZG9tRWxlbSA9IHRoaXMuX2RlS2V5bGluZS5hZGRLZXkoe1xuICAgICAgICB0aW1lc2NhbGU6IGFtLnRpbWVsaW5lLnRpbWVzY2FsZSxcbiAgICAgICAgdGltZTogdGhpcy50aW1lLFxuICAgICAgICBlYXNlOiB0aGlzLmVhc2UsXG4gICAgICAgIGNvbG9yOiBvcHQuY29sb3JcbiAgICB9KTtcblxuICAgIHRoaXMuX2RlTWVudSA9IGFtZ3VpLmNyZWF0ZURyb3Bkb3duKHtcbiAgICAgICAgb3B0aW9uczogWydlYXNlJywgJ2RlbGV0ZSddXG4gICAgfSk7XG4gICAgdGhpcy5fZGVNZW51LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdCcsIHRoaXMuX29uU2VsZWN0RHJvcGRvd24pO1xuXG4gICAgdGhpcy5kb21FbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZURlVGltZSk7XG4gICAgYW0udGltZWxpbmUub24oJ2NoYW5nZVRhcGUnLCB0aGlzLl9vbkNoYW5nZVRhcGUpO1xuXG4gICAgYW1ndWkuYmluZERyb3Bkb3duKHtcbiAgICAgICAgZGVUYXJnZXQ6IHRoaXMuZG9tRWxlbSxcbiAgICAgICAgZGVNZW51OiB0aGlzLl9kZU1lbnUsXG4gICAgICAgIGFzQ29udGV4dE1lbnU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChvcHQpIHtcbiAgICAgICAgdGhpcy51c2VTYXZlKG9wdCk7XG4gICAgfVxufVxuXG5pbmhlcml0cyhLZXksIEV2ZW50RW1pdHRlcik7XG52YXIgcCA9IEtleS5wcm90b3R5cGU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblxuICAgIHRpbWU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2KSB8fCB0aGlzLl90aW1lID09PSB2KSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSBwYXJzZUludCh2KTtcblxuICAgICAgICAgICAgdGhpcy5kb21FbGVtLnNldFRpbWUodGhpcy5fdGltZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlYXNlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKCF2IHx8IHRoaXMuX2Vhc2UgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fZWFzZSA9IHY7XG5cbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbS5zZXRFYXNlKHYpO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZUVhc2UnLCB2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lYXNlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxucC5nZXRTYXZlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgIHRpbWU6IHRoaXMudGltZSxcbiAgICAgICAgZWFzZTogdGhpcy5lYXNlXG4gICAgfTtcbn07XG5cbnAudXNlU2F2ZSA9IGZ1bmN0aW9uIChzYXZlKSB7XG5cbiAgICB0aGlzLnZhbHVlID0gc2F2ZS52YWx1ZTtcbiAgICB0aGlzLnRpbWUgPSBzYXZlLnRpbWU7XG4gICAgdGhpcy5lYXNlID0gc2F2ZS5lYXNlO1xufTtcblxucC5fb25DaGFuZ2VEZVRpbWUgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgdGhpcy50aW1lID0gZS5kZXRhaWwudGltZTtcblxuICAgIHRoaXMuZW1pdCgnY2hhbmdlVGltZScpO1xufTtcblxucC5fb25TZWxlY3REcm9wZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgXG4gICAgdmFyIHNlbGVjdGlvbiA9IGUuZGV0YWlsLnNlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24gPT09ICdlYXNlJykge1xuXG4gICAgICAgIGRpYWxvZ0tleU9wdGlvbnMuc2hvdyh7XG4gICAgICAgICAgICBlYXNlOiB0aGlzLmVhc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZGlhbG9nS2V5T3B0aW9ucy5vbignY2hhbmdlRWFzZScsIHRoaXMuX29uQ2hhbmdlRWFzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGVjdGlvbiA9PT0gJ2RlbGV0ZScpIHtcblxuICAgICAgICB0aGlzLmVtaXQoJ2RlbGV0ZScsIHRoaXMpO1xuICAgIH1cbn07XG5cbnAuX29uQ2hhbmdlRWFzZSA9IGZ1bmN0aW9uIChlYXNlKSB7XG5cbiAgICB0aGlzLmVhc2UgPSBlYXNlO1xufTtcblxucC5fb25DaGFuZ2VUYXBlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLnNldFRpbWVzY2FsZShhbS50aW1lbGluZS50aW1lc2NhbGUpO1xufTtcblxucC5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZURlVGltZSk7XG4gICAgdGhpcy5fZGVNZW51LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdCcsIHRoaXMuX29uU2VsZWN0RHJvcGRvd24pO1xuICAgIGFtLnRpbWVsaW5lLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2VUYXBlJywgdGhpcy5fb25DaGFuZ2VUYXBlKTtcblxuICAgIHRoaXMuZG9tRWxlbS5yZW1vdmUoKTtcbiAgICBpZiAodGhpcy5fZGVNZW51LnBhcmVudE5vZGUpIHRoaXMuX2RlTWVudS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2RlTWVudSk7IFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDc3NTZXF1ZW5jZSA9IHJlcXVpcmUoJy4vQ3NzU2VxdWVuY2UnKTtcbnZhciBxc2dlbiA9IHJlcXVpcmUoJy4uLy4uL3FzZ2VuJyk7XG5cbnZhciBhbSwgaWNvbk5ldztcblxuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24gKF9hbSkge1xuXG4gICAgYW0gPSBfYW07XG5cbiAgICBhbS5yZWdpc3RlclNlcXVlbmNlVHlwZShDc3NTZXF1ZW5jZSwgQ3NzU2VxdWVuY2UucHJvdG90eXBlLnR5cGUpO1xuXG4gICAgYW0ub24oJ3NlbGVjdERvbUVsZW1lbnQnLCBvblNlbGVjdERvbUVsZW1lbnQpO1xufTtcblxuZnVuY3Rpb24gb25TZWxlY3REb21FbGVtZW50KGRlKSB7XG5cbiAgICBpZiAoIWFtLnRpbWVsaW5lLnNlcXVlbmNlcy5zb21lKHRlc3RTZXF1KSkge1xuXG4gICAgICAgIHZhciBpY29uT3B0O1xuXG4gICAgICAgIGlmIChpY29uTmV3KSB7XG5cbiAgICAgICAgICAgIGljb25PcHQgPSB7IGRlSWNvbjogaWNvbk5ldyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWNvbk9wdCA9IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGljb246ICdwbHVzLXNxdWFyZWQnLFxuICAgICAgICAgICAgICAgIGJhY2tnb3VuZDogJyMwNjM1MDEnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6ICduZXcgc2VxdWVuY2Ugd2l0aCBzZWxlY3RlZCBlbGVtJyxcblxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICBhbS50b29sYmFyLnJlbW92ZUljb24oaWNvbk5ldyk7XG4gICAgICAgICAgICAgICAgICAgIGFtLmRvbVBpY2tlci5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gcXNnZW4oYW0uc2VsZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NlbGVjdG9yOicsIHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VxdSA9IG5ldyBDc3NTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IFtzZWxlY3Rvcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBhbS50aW1lbGluZS5hZGRTZXF1ZW5jZShzZXF1KTtcblxuICAgICAgICAgICAgICAgICAgICBzZXF1LnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpY29uTmV3ID0gYW0udG9vbGJhci5hZGRJY29uKGljb25PcHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RTZXF1KHNlcXUpIHtcblxuICAgICAgICBpZiAoc2VxdSBpbnN0YW5jZW9mIENzc1NlcXVlbmNlICYmIHNlcXUuaXNPd25lZERvbUVsZW0oZGUpKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpcyBvd25lZCcsIGRlKTtcbiAgICAgICAgICAgIHNlcXUuc2VsZWN0KHtmb2N1c0VsZW06IGRlfSk7XG4gICAgICAgICAgICBhbS5kb21QaWNrZXIuaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uLy4uL2FtZ3VpJyk7XG5cbmZ1bmN0aW9uIERpYWxvZ0tleU9wdGlvbnMgKCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9vblNlbGVjdEVhc2UgPSB0aGlzLl9vblNlbGVjdEVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUVhc2UgPSB0aGlzLl9vbkNoYW5nZUVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUJlemllciA9IHRoaXMuX29uQ2hhbmdlQmV6aWVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DbGlja09rID0gdGhpcy5fb25DbGlja09rLmJpbmQodGhpcyk7IFxufVxuXG5pbmhlcml0cyhEaWFsb2dLZXlPcHRpb25zLCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBEaWFsb2dLZXlPcHRpb25zLnByb3RvdHlwZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXG4gICAgZWFzZToge1xuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2Vhc2UgPT09IHYpIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5faW5wRWFzZS52YWx1ZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9iZWl6ZXJFZGl0b3Iuc2V0VmFsdWUodik7XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlRWFzZScsIHYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vhc2U7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5wLnNob3cgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICB0aGlzLl9jcmVhdGVEaWFsb2coKTtcblxuICAgIHRoaXMuZWFzZSA9IG9wdC5lYXNlO1xuXG4gICAgdGhpcy5kb21FbGVtLnNob3dNb2RhbCgpO1xufTtcblxucC5oaWRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLmNsb3NlKCk7XG5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2hhbmdlRWFzZScpO1xufTtcblxucC5fY3JlYXRlRGlhbG9nID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuX2lzRGlhbG9nQ3JlYXRlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2lzRGlhbG9nQ3JlYXRlZCA9IHRydWU7XG5cbiAgICB0aGlzLl9jcmVhdGVDb250ZW50KCk7XG4gICAgXG4gICAgdGhpcy5kb21FbGVtID0gYW1ndWkuY3JlYXRlRGlhbG9nKHtcbiAgICAgICAgdGl0bGU6ICdLZXknLFxuICAgICAgICBjb250ZW50OiB0aGlzLl9kZUNvbnRlbnQsXG4gICAgICAgIHBhcmVudDogYW0uZGVEaWFsb2dDb250LFxuICAgICAgICBidXR0b25zOiBbJ29rJ10sXG4gICAgfSk7XG5cbiAgICB0aGlzLmRvbUVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2tfb2snLCB0aGlzLl9vbkNsaWNrT2spO1xufTtcblxucC5fY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2RlQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlQ29udGVudC5zdHlsZS53aWR0aCA9ICczMzBweCc7XG4gICAgdGhpcy5fZGVDb250ZW50LnN0eWxlLnBhZGRpbmcgPSAnMzBweCAxMnB4JztcblxuICAgIHRoaXMuX2RlTGFiZWxFYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRoaXMuX2RlTGFiZWxFYXNlLnRleHRDb250ZW50ID0gJ2Vhc2U6ICc7XG4gICAgdGhpcy5fZGVDb250ZW50LmFwcGVuZENoaWxkKHRoaXMuX2RlTGFiZWxFYXNlKTtcblxuICAgIHRoaXMuX2lucEVhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX2lucEVhc2UudHlwZSA9ICd0ZXh0JztcbiAgICB0aGlzLl9pbnBFYXNlLnZhbHVlID0gJ2xpbmVhcic7XG4gICAgdGhpcy5faW5wRWFzZS5zdHlsZS53aWR0aCA9ICcyNDVweCc7XG4gICAgdGhpcy5faW5wRWFzZS5zdHlsZS5mb250U2l6ZSA9ICcxNHB4JztcbiAgICB0aGlzLl9pbnBFYXNlLnN0eWxlLmZvbnRGYW1pbHkgPSBhbWd1aS5GT05UX0ZBTUlMWTtcbiAgICB0aGlzLl9pbnBFYXNlLnN0eWxlLmJhY2tncm91bmQgPSAnbm9uZSc7XG4gICAgdGhpcy5faW5wRWFzZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgdGhpcy5faW5wRWFzZS5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgdGhpcy5faW5wRWFzZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZUVhc2UpO1xuICAgIHRoaXMuX2RlQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl9pbnBFYXNlKTtcblxuICAgIHRoaXMuX2J0blNlbGVjdEVhc2UgPSBhbWd1aS5jcmVhdGVJY29uQnRuKHtcbiAgICAgICAgaWNvbjogJ2NoYXJ0LWJhcicsXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUnXG4gICAgfSk7XG4gICAgdGhpcy5fYnRuU2VsZWN0RWFzZS5zdHlsZS5tYXJnaW5MZWZ0ID0gJzRweCc7XG4gICAgdGhpcy5fZGVDb250ZW50LmFwcGVuZENoaWxkKHRoaXMuX2J0blNlbGVjdEVhc2UpO1xuXG4gICAgYW1ndWkuYmluZERyb3Bkb3duKHtcbiAgICAgICAgZGVUYXJnZXQ6IHRoaXMuX2J0blNlbGVjdEVhc2UsXG4gICAgICAgIGRlTWVudTogYW1ndWkuY3JlYXRlRHJvcGRvd24oe1xuICAgICAgICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZScsICdlYXNlLWluJywgJ2Vhc2Utb3V0JywgJ2Vhc2UtaW4tb3V0JywgJ3N0ZXBzKDEpJywgJ2N1YmljLWJlemllcigwLDAsMSwxKSddLFxuICAgICAgICAgICAgb25TZWxlY3Q6IHRoaXMuX29uU2VsZWN0RWFzZSxcbiAgICAgICAgfSksXG4gICAgICAgIG1lbnVQYXJlbnQ6IHRoaXMuX2RlQ29udGVudFxuICAgIH0pO1xuXG4gICAgdGhpcy5fYmVpemVyRWRpdG9yID0gYW1ndWkuY3JlYXRlQmV6aWVyRWRpdG9yKHtcbiAgICAgICAgLy8gd2lkdGg6IDMzMCxcbiAgICAgICAgLy8gaGVpZ2h0OiAzMzAsXG4gICAgICAgIHBhcmVudDogdGhpcy5fZGVDb250ZW50LFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5fb25DaGFuZ2VCZXppZXJcbiAgICB9KTtcbn07XG5cbnAuX29uQ2xpY2tPayA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaGlkZSgpO1xufTtcblxucC5fb25TZWxlY3RFYXNlID0gZnVuY3Rpb24gKGUpIHtcblxuICAgIHRoaXMuZWFzZSA9IGUuZGV0YWlsLnNlbGVjdGlvbjtcbn07XG5cbnAuX29uQ2hhbmdlRWFzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZWFzZSA9IHRoaXMuX2lucEVhc2UudmFsdWU7XG59O1xuXG5wLl9vbkNoYW5nZUJlemllciA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICB0aGlzLmVhc2UgPSBlLmRldGFpbC52YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IERpYWxvZ0tleU9wdGlvbnMoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgYW1ndWkgPSByZXF1aXJlKCcuLi8uLi9hbWd1aScpO1xuXG5mdW5jdGlvbiBEaWFsb2dTZXF1T3B0aW9ucyAoKSB7XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX25hbWUgPSAnJztcbiAgICB0aGlzLl9zZWxlY3RvcnMgPSBbXTtcblxuICAgIHRoaXMuX29uQ2xpY2tPayA9IHRoaXMuX29uQ2xpY2tPay5iaW5kKHRoaXMpOyBcbiAgICB0aGlzLl9vbkNoYW5nZU5hbWUgPSB0aGlzLl9vbkNoYW5nZU5hbWUuYmluZCh0aGlzKTsgXG4gICAgdGhpcy5fb25TZWxlY3RGaWxsID0gdGhpcy5fb25TZWxlY3RGaWxsLmJpbmQodGhpcyk7IFxuICAgIHRoaXMuX29uQ2hhbmdlSXRlcmF0aW9ucyA9IHRoaXMuX29uQ2hhbmdlSXRlcmF0aW9ucy5iaW5kKHRoaXMpOyBcbn1cblxuaW5oZXJpdHMoRGlhbG9nU2VxdU9wdGlvbnMsIEV2ZW50RW1pdHRlcik7XG52YXIgcCA9IERpYWxvZ1NlcXVPcHRpb25zLnByb3RvdHlwZTtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblxuICAgIG5hbWU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbmFtZSA9PT0gdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9pbnBOYW1lLnZhbHVlID0gdjtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlTmFtZScsIHYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdG9yczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9ycy5zbGljZSgpLm1hcCh0aGlzLl9yZW1vdmVTZWxlY3RvciwgdGhpcyk7XG4gICAgICAgICAgICB2Lm1hcCh0aGlzLl9hZGRTZWxlY3RvciwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZVNlbGVjdG9ycycsIHRoaXMuc2VsZWN0b3JzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5wbHVjayh0aGlzLl9zZWxlY3RvcnMsICd2YWx1ZScpOyBcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaWxsOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgPT09IHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2ZpbGwgPSB2O1xuICAgICAgICAgICAgdGhpcy5fZGVGaWxsLnRleHRDb250ZW50ID0gdjtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlRmlsbCcsIHYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGl0ZXJhdGlvbnM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faXRlcmF0aW9ucyA9PT0gdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faXRlcmF0aW9ucyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9pbnBJdGVyYXRpb25zLnZhbHVlID0gdjtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlSXRlcmF0aW9ucycsIHYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVyYXRpb25zO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG5wLnNob3cgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICB0aGlzLl9jcmVhdGVEaWFsb2coKTtcblxuICAgIGlmICgnbmFtZScgaW4gb3B0KSB0aGlzLm5hbWUgPSBvcHQubmFtZTtcbiAgICBpZiAoJ2ZpbGwnIGluIG9wdCkgdGhpcy5maWxsID0gb3B0LmZpbGw7XG4gICAgaWYgKCdpdGVyYXRpb25zJyBpbiBvcHQpIHRoaXMuaXRlcmF0aW9ucyA9IG9wdC5pdGVyYXRpb25zO1xuICAgIGlmICgnc2VsZWN0b3JzJyBpbiBvcHQpIHRoaXMuc2VsZWN0b3JzID0gb3B0LnNlbGVjdG9ycztcblxuICAgIGlmICgnb25DaGFuZ2VOYW1lJyBpbiBvcHQpIHRoaXMub24oJ2NoYW5nZU5hbWUnLCBvcHQub25DaGFuZ2VOYW1lKTtcbiAgICBpZiAoJ29uQ2hhbmdlRmlsbCcgaW4gb3B0KSB0aGlzLm9uKCdjaGFuZ2VGaWxsJywgb3B0Lm9uQ2hhbmdlRmlsbCk7XG4gICAgaWYgKCdvbkNoYW5nZUl0ZXJhdGlvbnMnIGluIG9wdCkgdGhpcy5vbignY2hhbmdlSXRlcmF0aW9ucycsIG9wdC5vbkNoYW5nZUl0ZXJhdGlvbnMpO1xuICAgIGlmICgnb25DaGFuZ2VTZWxlY3RvcnMnIGluIG9wdCkgdGhpcy5vbignY2hhbmdlU2VsZWN0b3JzJywgb3B0Lm9uQ2hhbmdlU2VsZWN0b3JzKTtcblxuICAgIHRoaXMuZG9tRWxlbS5zaG93TW9kYWwoKTtcbn07XG5cbnAuaGlkZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZG9tRWxlbS5jbG9zZSgpO1xuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2NoYW5nZU5hbWUnKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2hhbmdlRmlsbCcpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjaGFuZ2VJdGVyYXRpb25zJyk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2NoYW5nZVNlbGVjdG9ycycpO1xufTtcblxucC5fY3JlYXRlRGlhbG9nID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuX2lzRGlhbG9nQ3JlYXRlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2lzRGlhbG9nQ3JlYXRlZCA9IHRydWU7XG5cbiAgICB0aGlzLl9jcmVhdGVDb250ZW50KCk7XG4gICAgXG4gICAgdGhpcy5kb21FbGVtID0gYW1ndWkuY3JlYXRlRGlhbG9nKHtcbiAgICAgICAgdGl0bGU6ICdTZXF1ZW5jZScsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuX2RlQ29udGVudCxcbiAgICAgICAgcGFyZW50OiBhbS5kZURpYWxvZ0NvbnQsXG4gICAgICAgIGJ1dHRvbnM6IFsnb2snXSxcbiAgICB9KTtcblxuICAgIHRoaXMuZG9tRWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGlja19vaycsIHRoaXMuX29uQ2xpY2tPayk7XG59O1xuXG5wLl9vbkNsaWNrT2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmhpZGUoKTtcbn07XG5cbnAuX29uQ2hhbmdlTmFtZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMubmFtZSA9IHRoaXMuX2lucE5hbWUudmFsdWU7XG59O1xuXG5wLl9vblNlbGVjdEZpbGwgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgdGhpcy5maWxsID0gZS5kZXRhaWwuc2VsZWN0aW9uO1xufTtcblxucC5fb25DaGFuZ2VJdGVyYXRpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5pdGVyYXRpb25zID0gcGFyc2VJbnQodGhpcy5faW5wSXRlcmF0aW9ucy52YWx1ZSk7XG59O1xuXG5cbnAuX2NyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9kZUNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kZUNvbnRlbnQuc3R5bGUud2lkdGggPSAnMzMwcHgnO1xuICAgIHRoaXMuX2RlQ29udGVudC5zdHlsZS5wYWRkaW5nID0gJzMwcHggMTJweCc7XG5cbiAgICBhbWd1aS5jcmVhdGVMYWJlbCh7XG4gICAgICAgIGNhcHRpb246ICdOYW1lOiAnLFxuICAgICAgICBmb250U2l6ZTogJzE4cHgnLFxuICAgICAgICAvLyBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlQ29udGVudFxuICAgIH0pO1xuXG4gICAgdGhpcy5faW5wTmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5faW5wTmFtZS50eXBlID0gJ3RleHQnO1xuICAgIHRoaXMuX2lucE5hbWUudmFsdWUgPSB0aGlzLm5hbWU7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS53aWR0aCA9ICcyNDVweCc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5mb250U2l6ZSA9ICcxNHB4JztcbiAgICB0aGlzLl9pbnBOYW1lLnN0eWxlLmZvbnRGYW1pbHkgPSBhbWd1aS5GT05UX0ZBTUlMWTtcbiAgICB0aGlzLl9pbnBOYW1lLnN0eWxlLmJhY2tncm91bmQgPSAnbm9uZSc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMTJweCc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgdGhpcy5faW5wTmFtZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZU5hbWUpO1xuICAgIHRoaXMuX2RlQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl9pbnBOYW1lKTtcblxuICAgIGFtZ3VpLmNyZWF0ZUxhYmVsKHtcbiAgICAgICAgY2FwdGlvbjogJ1NlbGVjdG9ycycsXG4gICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHBhcmVudDogdGhpcy5fZGVDb250ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kZVNlbGVjdG9yQ29udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlU2VsZWN0b3JDb250LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuX2RlQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl9kZVNlbGVjdG9yQ29udCk7XG5cbiAgICBhbWd1aS5jcmVhdGVJY29uQnRuKHtcbiAgICAgICAgaWNvbjogJ3BsdXMnLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgb25DbGljazogdGhpcy5fYWRkU2VsZWN0b3IuYmluZCh0aGlzLCAnJyksXG4gICAgICAgIHBhcmVudDogdGhpcy5fZGVDb250ZW50XG4gICAgfSk7XG5cbiAgICBhbWd1aS5jcmVhdGVJY29uQnRuKHtcbiAgICAgICAgaWNvbjogJ2NvZGUnLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge2FtLmRpYWxvZ3MuZmVhdHVyZURvZXNudEV4aXN0LnNob3coKTt9LFxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlQ29udGVudCxcbiAgICAgICAgdG9vbHRpcDogJ3NlbGVjdCBmcm9tIG9wdGlvbnMnXG4gICAgfSk7XG5cbiAgICBhbWd1aS5jcmVhdGVMaW5lYnJlYWsoe1xuICAgICAgICBwYXJlbnQ6dGhpcy5fZGVDb250ZW50XG4gICAgfSk7XG5cbiAgICBhbWd1aS5jcmVhdGVMYWJlbCh7XG4gICAgICAgIGNhcHRpb246ICdGaWxsIG1vZGU6ICcsXG4gICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgIHBhcmVudDogdGhpcy5fZGVDb250ZW50XG4gICAgfSk7XG4gICAgdGhpcy5fZGVGaWxsID0gYW1ndWkuY3JlYXRlTGFiZWwoe1xuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlQ29udGVudFxuICAgIH0pO1xuICAgIGFtZ3VpLmJpbmREcm9wZG93bih7XG4gICAgICAgIGRlVGFyZ2V0OiB0aGlzLl9kZUZpbGwsXG4gICAgICAgIGRlTWVudTogYW1ndWkuY3JlYXRlRHJvcGRvd24oe1xuICAgICAgICAgICAgb3B0aW9uczogWydub25lJywgJ2ZvcndhcmRzJywgJ2JhY2t3YXJkcycsICdib3RoJ10sXG4gICAgICAgICAgICBvblNlbGVjdDogdGhpcy5fb25TZWxlY3RGaWxsLFxuICAgICAgICB9KSxcbiAgICAgICAgbWVudVBhcmVudDogdGhpcy5fZGVDb250ZW50LFxuICAgIH0pO1xuXG4gICAgYW1ndWkuY3JlYXRlTGluZWJyZWFrKHtcbiAgICAgICAgcGFyZW50OiB0aGlzLl9kZUNvbnRlbnRcbiAgICB9KTtcblxuICAgIGFtZ3VpLmNyZWF0ZUxhYmVsKHtcbiAgICAgICAgZm9udFNpemU6ICcxOHB4JyxcbiAgICAgICAgY2FwdGlvbjogJ0l0ZXJhdGlvbnM6ICcsXG4gICAgICAgIHBhcmVudDogdGhpcy5fZGVDb250ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLnR5cGUgPSAnbnVtYmVyJztcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLnN0ZXAgPSAxO1xuICAgIHRoaXMuX2lucEl0ZXJhdGlvbnMubWluID0gMDtcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLm1heCA9IDk5OTk5OTk5OTk5OTtcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLnN0eWxlLmZvbnRTaXplID0gJzE0cHgnO1xuICAgIHRoaXMuX2lucEl0ZXJhdGlvbnMuc3R5bGUuZm9udEZhbWlseSA9IGFtZ3VpLkZPTlRfRkFNSUxZO1xuICAgIHRoaXMuX2lucEl0ZXJhdGlvbnMuc3R5bGUuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcxMnB4JztcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLnN0eWxlLmNvbG9yID0gYW1ndWkuY29sb3IudGV4dDtcbiAgICB0aGlzLl9pbnBJdGVyYXRpb25zLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlSXRlcmF0aW9ucyk7XG4gICAgdGhpcy5fZGVDb250ZW50LmFwcGVuZENoaWxkKHRoaXMuX2lucEl0ZXJhdGlvbnMpO1xufTtcblxucC5fYWRkU2VsZWN0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgdmFyIHNlbGVjdG9yID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfTtcbiAgICB0aGlzLl9zZWxlY3RvcnMucHVzaChzZWxlY3Rvcik7XG5cbiAgICB2YXIgaGVpZ2h0ID0gMjM7XG5cbiAgICBzZWxlY3Rvci5kb21FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2VsZWN0b3IuZG9tRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIHNlbGVjdG9yLmRvbUVsZW0uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBzZWxlY3Rvci5kb21FbGVtLnN0eWxlLnBhZGRpbmdMZWZ0ID0gJzJweCc7XG4gICAgc2VsZWN0b3IuZG9tRWxlbS5zdHlsZS5tYXJnaW4gPSAnMXB4IDAnO1xuICAgIHNlbGVjdG9yLmRvbUVsZW0uc3R5bGUuYmFja2dyb3VuZCA9IGFtZ3VpLmNvbG9yLmJnMjtcbiAgICB0aGlzLl9kZVNlbGVjdG9yQ29udC5hcHBlbmRDaGlsZChzZWxlY3Rvci5kb21FbGVtKTtcblxuICAgIHZhciBpbnAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlucC50eXBlID0gJ3RleHQnO1xuICAgIGlucC52YWx1ZSA9IHZhbHVlO1xuICAgIGlucC5wbGFjZWhvbGRlciA9ICdzZWxlY3Rvcic7XG4gICAgaW5wLnN0eWxlLndpZHRoID0gJzI0NXB4JztcbiAgICBpbnAuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBpbnAuc3R5bGUuZm9udFNpemUgPSAnMTRweCc7XG4gICAgaW5wLnN0eWxlLmZvbnRGYW1pbHkgPSBhbWd1aS5GT05UX0ZBTUlMWTtcbiAgICBpbnAuc3R5bGUuZmxleCA9ICcxJztcbiAgICBpbnAuc3R5bGUuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICBpbnAuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICAgIGlucC5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgc2VsZWN0b3IuZG9tRWxlbS5hcHBlbmRDaGlsZChpbnApO1xuXG4gICAgaW5wLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBzZWxlY3Rvci52YWx1ZSA9IGlucC52YWx1ZTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZVNlbGVjdG9ycycsIHRoaXMuc2VsZWN0b3JzKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdmFyIGJ0bkRlbCA9IGFtZ3VpLmNyZWF0ZUljb25CdG4oe1xuICAgICAgICBpY29uOiAnY2FuY2VsJyxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBvbkNsaWNrOnRoaXMuX3JlbW92ZVNlbGVjdG9yLmJpbmQodGhpcywgc2VsZWN0b3IpLFxuICAgICAgICBwYXJlbnQ6IHNlbGVjdG9yLmRvbUVsZW1cbiAgICB9KTtcbiAgICBidG5EZWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgc2VsZWN0b3IuZG9tRWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBidG5EZWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9KTtcbiAgICBzZWxlY3Rvci5kb21FbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJ0bkRlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfSk7XG59O1xuXG5wLl9yZW1vdmVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXG4gICAgdGhpcy5fc2VsZWN0b3JzLnNwbGljZSh0aGlzLl9zZWxlY3RvcnMuaW5kZXhPZihzZWxlY3RvciksIDEpO1xuXG4gICAgc2VsZWN0b3IuZG9tRWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGVjdG9yLmRvbUVsZW0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlhbG9nU2VxdU9wdGlvbnMoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJmdW5jdGlvbiAoKSB7XFxuXFxuICAgIHZhciBwbGF5ZXIsXFxuICAgICAgICBhbmltYXRpb24sXFxuICAgICAgICBpc0luaXRlZCA9IGZhbHNlLFxcbiAgICAgICAgYW5pbWF0aW9ucyA9IFtdLFxcbiAgICAgICAgcGFyYW1LZXlzID0ge3t7cGFyYW1LZXlzfX19LFxcbiAgICAgICAgb3B0aW9ucyA9IHt7e29wdGlvbnN9fX0sXFxuICAgICAgICBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3t7e3NlbGVjdG9yc319fScpO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtS2V5cy5sZW5ndGg7ICsraikge1xcblxcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChuZXcgQW5pbWF0aW9uKGVsZW1zW2ldLCBwYXJhbUtleXNbal0sIG9wdGlvbnMpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uR3JvdXAoYW5pbWF0aW9ucyk7XFxuXFxuICAgIHJldHVybiB7XFxuXFxuICAgICAgICBwbGF5OiBmdW5jdGlvbiAoKSB7XFxuXFxuICAgICAgICAgICAgaWYgKCFpc0luaXRlZCkge1xcblxcbiAgICAgICAgICAgICAgICBwbGF5ZXIgPSBkb2N1bWVudC50aW1lbGluZS5wbGF5KGFuaW1hdGlvbik7XFxuICAgICAgICAgICAgICAgIGlzSW5pdGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XFxuXFxuICAgICAgICAgICAgaWYgKCFwbGF5ZXIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBzZWVrOiBmdW5jdGlvbiAodGltZSkge1xcblxcbiAgICAgICAgICAgIGlmICghcGxheWVyKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcGxheWVyLmN1cnJlbnRUaW1lID0gdGltZTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG59XCI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByeCA9IC9eY2FsY1xcKCguKj8pXFwpJC87XG4gICAgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuY2FsYyAodmFsdWUpIHtcblxuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmRleE9mKCdjYWxjKCcpICE9PSAtMSkge1xuXG4gICAgICAgIHZhciBtID0gcnguZXhlYyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtID8gJyggJyArIG1bMV0gKyAnICknIDogdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgYW1ndWkgPSByZXF1aXJlKCcuLi8uLi9hbWd1aScpO1xuXG5mdW5jdGlvbiBJbnRlcnZhbChvcHQpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fbGluZUggPSAgMjE7XG4gICAgdGhpcy5fc3RhcnQgPSAwO1xuICAgIHRoaXMuX2VuZCA9IGFtLnRpbWVsaW5lLmxlbmd0aDtcblxuICAgIHRoaXMuX29uRHJhZ1Jlc2l6ZSA9IHRoaXMuX29uRHJhZ1Jlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRmluaXNoUmVzaXplID0gdGhpcy5fb25GaW5pc2hSZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdNb3ZlID0gdGhpcy5fb25EcmFnTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2hhbmdlVGltZSA9IHRoaXMuX29uQ2hhbmdlVGltZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fY3JlYXRlRG9tRWxlbSgpO1xuICAgIHRoaXMuX3JlZnJlc2hEb21FbGVtKCk7XG5cbiAgICBhbS50aW1lbGluZS5vbignY2hhbmdlVGltZScsIHRoaXMuX29uQ2hhbmdlVGltZSk7XG5cbiAgICBpZiAob3B0KSB7XG4gICAgICAgIHRoaXMudXNlU2F2ZShvcHQpO1xuICAgIH1cbn1cblxuaW5oZXJpdHMoSW50ZXJ2YWwsIEV2ZW50RW1pdHRlcik7XG52YXIgcCA9IEludGVydmFsLnByb3RvdHlwZTtcblxuXG5cblxuXG5cblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblxuICAgIHN0YXJ0OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgdiA9IHBhcnNlSW50KHYpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhcnQgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSB2O1xuXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoRG9tRWxlbSgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbmQ6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICB2ID0gcGFyc2VJbnQodik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmQgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fZW5kID0gdjtcblxuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaERvbUVsZW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmQ7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cblxuXG5cblxucC5nZXRTYXZlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNhdmUgPSB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICBlbmQ6IHRoaXMuZW5kLFxuICAgIH07XG5cbiAgICByZXR1cm4gc2F2ZTtcbn07XG5cbnAudXNlU2F2ZSA9IGZ1bmN0aW9uKHNhdmUpIHtcblxuICAgIGlmICgnc3RhcnQnIGluIHNhdmUpIHRoaXMuc3RhcnQgPSBzYXZlLnN0YXJ0O1xuICAgIGlmICgnZW5kJyBpbiBzYXZlKSB0aGlzLmVuZCA9IHNhdmUuZW5kO1xufTtcblxucC5zaG93TmVpZ2hib3VycyA9IGZ1bmN0aW9uIChuZWlnaGJvdXJzKSB7XG5cbiAgICB0aGlzLl9uZWlnaGJvdXJJbnRlcnZhbHMgPSBuZWlnaGJvdXJzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxucC5fbmV4dEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX19uZWlnaGJvdXJJbnRlcnZhbCh0cnVlKTtcbn07XG5cbnAuX3ByZXZJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLl9fbmVpZ2hib3VySW50ZXJ2YWwoZmFsc2UpO1xufTtcblxucC5fX25laWdoYm91ckludGVydmFsID0gZnVuY3Rpb24gKGZvcndhcmQpIHtcblxuICAgIHZhciBwb3MsIG5laWdoYm91cjtcblxuICAgIHRoaXMuX25laWdoYm91ckludGVydmFscy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXG4gICAgICAgIHZhciBuZXh0ID0gZm9yd2FyZCA/IGludGVydmFsLnN0YXJ0IDogaW50ZXJ2YWwuZW5kO1xuXG4gICAgICAgIGlmIChpbnRlcnZhbCAhPT0gdGhpcyAmJiBcbiAgICAgICAgICAgIChmb3J3YXJkID8gbmV4dCA+IHRoaXMuZW5kIDogbmV4dCA8IHRoaXMuc3RhcnQpICYmXG4gICAgICAgICAgICAocG9zID09PSB1bmRlZmluZWQgfHwgKGZvcndhcmQgPT09IChwb3MgPiBuZXh0KSkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgbmVpZ2hib3VyID0gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiBuZWlnaGJvdXI7XG59O1xuXG5wLl9yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmVtaXQoJ3JlbW92ZScsIHRoaXMpO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxucC5fb25DaGFuZ2VUaW1lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fcmVmcmVzaERvbUVsZW0oKTtcbn07XG5cbnAuX29uRHJhZ1Jlc2l6ZSA9IGZ1bmN0aW9uIChtZCwgbXgpIHtcblxuICAgIHZhciBuZWlnaGJvdXIsIFxuICAgICAgICB0aW1lUG9zID0gYW0udGltZWxpbmUuc2NyZWVuWFRvVGltZShteCk7XG5cbiAgICBpZiAobWQuc2lkZSA9PT0gJ2xlZnQnKSB7XG5cbiAgICAgICAgbmVpZ2hib3VyID0gdGhpcy5fcHJldkludGVydmFsKCk7XG5cbiAgICAgICAgaWYgKG5laWdoYm91ciAmJiB0aW1lUG9zIDwgbmVpZ2hib3VyLmVuZCkge1xuXG4gICAgICAgICAgICB0aW1lUG9zID0gbmVpZ2hib3VyLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aW1lUG9zO1xuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICBuZWlnaGJvdXIgPSB0aGlzLl9uZXh0SW50ZXJ2YWwoKTtcblxuICAgICAgICBpZiAobmVpZ2hib3VyICYmIHRpbWVQb3MgPiBuZWlnaGJvdXIuc3RhcnQpIHtcblxuICAgICAgICAgICAgdGltZVBvcyA9IG5laWdoYm91ci5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW5kID0gdGltZVBvcztcbiAgICB9XG59O1xuXG5wLl9vbkZpbmlzaFJlc2l6ZSA9IGZ1bmN0aW9uIChtZCkge1xuXG4gICAgdmFyIG5laWdoYm91cjtcblxuICAgIGlmIChtZC5zaWRlID09PSAnbGVmdCcpIHtcblxuICAgICAgICBuZWlnaGJvdXIgPSB0aGlzLl9wcmV2SW50ZXJ2YWwoKTtcblxuICAgICAgICBpZiAobmVpZ2hib3VyICYmIG5laWdoYm91ci5lbmQgPT09IHRoaXMuc3RhcnQpIHtcblxuICAgICAgICAgICAgbmVpZ2hib3VyLmVuZCA9IHRoaXMuZW5kO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgbmVpZ2hib3VyID0gdGhpcy5fbmV4dEludGVydmFsKCk7XG5cbiAgICAgICAgaWYgKG5laWdoYm91ciAmJiBuZWlnaGJvdXIuc3RhcnQgPT09IHRoaXMuZW5kKSB7XG5cbiAgICAgICAgICAgIG5laWdoYm91ci5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnAuX29uRHJhZ01vdmUgPSBmdW5jdGlvbiAobWQsIG14KSB7XG5cbiAgICB2YXIgdGltZVBvcyA9IGFtLnRpbWVsaW5lLnNjcmVlblhUb1RpbWUobXgpLFxuICAgICAgICBtb3ZlID0gdGltZVBvcyAtIG1kLnRpbWVQb3MsXG4gICAgICAgIG5leHRJbnRlcnZhbCA9IHRoaXMuX25leHRJbnRlcnZhbCgpLFxuICAgICAgICBwcmV2SW50ZXJ2YWwgPSB0aGlzLl9wcmV2SW50ZXJ2YWwoKTtcblxuICAgIGlmIChuZXh0SW50ZXJ2YWwgJiYgbWQuZW5kICsgbW92ZSA+IG5leHRJbnRlcnZhbC5zdGFydCkge1xuXG4gICAgICAgIG1vdmUgPSBuZXh0SW50ZXJ2YWwuc3RhcnQgLSBtZC5lbmQ7XG4gICAgfVxuXG4gICAgaWYgKHByZXZJbnRlcnZhbCAmJiBtZC5zdGFydCArIG1vdmUgPCBwcmV2SW50ZXJ2YWwuZW5kKSB7XG5cbiAgICAgICAgbW92ZSA9IHByZXZJbnRlcnZhbC5lbmQgLSBtZC5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAobWQuc3RhcnQgKyBtb3ZlIDwgMCkge1xuXG4gICAgICAgIG1vdmUgPSAtbWQuc3RhcnQ7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IG1kLnN0YXJ0ICsgbW92ZTtcbiAgICB0aGlzLmVuZCA9IG1kLmVuZCArIG1vdmU7XG59O1xuXG5cblxuXG5cblxuXG5cbnAuX3JlZnJlc2hEb21FbGVtID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLmxlZnQgPSB0aGlzLnN0YXJ0ICogYW0udGltZWxpbmUudGltZXNjYWxlICsgJ3B4JztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUud2lkdGggPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGFtLnRpbWVsaW5lLnRpbWVzY2FsZSArICdweCc7XG59O1xuXG5cblxuXG5cblxuXG5cbnAuX2NyZWF0ZURvbUVsZW0gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBkZS5zdHlsZS5oZWlnaHQgPSB0aGlzLl9saW5lSCArICdweCc7XG4gICAgZGUuc3R5bGUuYmFja2dyb3VuZCA9ICdibHVlJztcbiAgICBkZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cbiAgICBjcmVhdGVIYW5kbGVyLmNhbGwodGhpcywgJ2xlZnQnKTtcbiAgICBjcmVhdGVIYW5kbGVyLmNhbGwodGhpcywgJ3JpZ2h0Jyk7XG5cbiAgICB0aGlzLmRvbUVsZW0gPSBkZTtcblxuICAgIGFtZ3VpLm1ha2VEcmFnZ2FibGUoe1xuICAgICAgICBkZVRhcmdldDogZGUsXG4gICAgICAgIHRoaXNBcmc6IHRoaXMsXG4gICAgICAgIG9uRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLmVuZCxcbiAgICAgICAgICAgICAgICB0aW1lUG9zOiBhbS50aW1lbGluZS5zY3JlZW5YVG9UaW1lKGUuc2NyZWVuWClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW92ZTogdGhpcy5fb25EcmFnTW92ZSxcbiAgICB9KTtcblxuICAgIGFtZ3VpLmJpbmREcm9wZG93bih7XG4gICAgICAgIGFzQ29udGV4dE1lbnU6IHRydWUsXG4gICAgICAgIGRlVGFyZ2V0OiBkZSxcbiAgICAgICAgZGVNZW51OiBhbWd1aS5jcmVhdGVEcm9wZG93bih7XG4gICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAge3RleHQ6ICdzcGxpdCBoZXJlJ30sXG4gICAgICAgICAgICAgICAge3RleHQ6ICdyZW1vdmUnfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KSxcbiAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gJ3NwbGl0IGhlcmUnKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFtLmRpYWxvZ3MuZmVhdHVyZURvZXNudEV4aXN0LnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGFuZGxlcihzaWRlKSB7XG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGFuZGxlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGhhbmRsZXIuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIGhhbmRsZXIuc3R5bGVbc2lkZV0gPSAnMHB4JztcbiAgICAgICAgaGFuZGxlci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIGhhbmRsZXIuc3R5bGUud2lkdGggPSAnM3B4JztcbiAgICAgICAgaGFuZGxlci5zdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJztcbiAgICAgICAgaGFuZGxlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICBkZS5hcHBlbmRDaGlsZChoYW5kbGVyKTtcblxuICAgICAgICBhbWd1aS5tYWtlRHJhZ2dhYmxlKHtcbiAgICAgICAgICAgIGRlVGFyZ2V0OiBoYW5kbGVyLFxuICAgICAgICAgICAgb25Eb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZTogc2lkZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Nb3ZlOiB0aGlzLl9vbkRyYWdSZXNpemUsXG4gICAgICAgICAgICBvblVwOiB0aGlzLl9vbkZpbmlzaFJlc2l6ZSxcbiAgICAgICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnN0eWxlLmJhY2tncm91bmQgPSAnd2hpdGUnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuXG5cbnAuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vVE9ET1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnZhbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgZGlhbG9nU2NyaXB0RWRpdG9yID0gcmVxdWlyZSgnLi9kaWFsb2dTY3JpcHRFZGl0b3InKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uLy4uL2FtZ3VpJyk7XG52YXIgSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsJyk7XG5cbmZ1bmN0aW9uIEludGVydmFsU2NyaXB0KG9wdCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9saW5lSCA9ICAyMTtcbiAgICB0aGlzLl9zY3JpcHQgPSAgJy8qKi8nO1xuICAgIHRoaXMuX2ludGVydmFscyA9IFtdO1xuXG4gICAgdGhpcy5fb25DbGlja09wZW5TY3JpcHQgPSB0aGlzLl9vbkNsaWNrT3BlblNjcmlwdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2hhbmdlU2NyaXB0ID0gdGhpcy5fb25DaGFuZ2VTY3JpcHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlbW92ZUludGVydmFsID0gdGhpcy5fb25SZW1vdmVJbnRlcnZhbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZWxlY3RBZGRJbnRlcnZhbCA9IHRoaXMub25TZWxlY3RBZGRJbnRlcnZhbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRGJsY2xpY2tLZXlsaW5lID0gdGhpcy5fb25EYmxjbGlja0tleWxpbmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZGVPcHRpb25zID0gdGhpcy5fY3JlYXRlUGFyYW1ldGVyT3B0aW9ucygpO1xuICAgIHRoaXMuZGVLZXlsaW5lID0gdGhpcy5fY3JlYXRlQm91bmRzTGluZSgpO1xuXG4gICAgdGhpcy5fYWRkSW50ZXJ2YWwoKTtcblxuICAgIHRoaXMuZGVLZXlsaW5lLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fb25EYmxjbGlja0tleWxpbmUpO1xuXG4gICAgaWYgKG9wdCkge1xuICAgICAgICB0aGlzLnVzZVNhdmUob3B0KTtcbiAgICB9XG59XG5cbmluaGVyaXRzKEludGVydmFsU2NyaXB0LCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBJbnRlcnZhbFNjcmlwdC5wcm90b3R5cGU7XG5cblxuXG5cblxuXG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cbiAgICBoZWlnaHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lSDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2NyaXB0OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgdiA9IHYgfHwgJyc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zY3JpcHQgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fc2NyaXB0ID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHQ7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5cblxuXG5wLmdldFNhdmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgc2F2ZSA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBzY3JpcHQ6IEpTT04uc3RyaW5naWZ5KHRoaXMuc2NyaXB0KS5zbGljZSgxLCAtMSkucmVwbGFjZSgvJy9nLCAnXFxcXFxcJycpLFxuICAgICAgICBpbnRlcnZhbHM6IFtdLFxuICAgIH07XG5cbiAgICB0aGlzLl9pbnRlcnZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblxuICAgICAgICBzYXZlLmludGVydmFscy5wdXNoKGludGVydmFsLmdldFNhdmUoKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2F2ZTtcbn07XG5cbnAudXNlU2F2ZSA9IGZ1bmN0aW9uKHNhdmUpIHtcblxuICAgIGlmICgnbmFtZScgaW4gc2F2ZSkgdGhpcy5uYW1lID0gc2F2ZS5uYW1lO1xuICAgIGlmICgnc2NyaXB0JyBpbiBzYXZlKSB0aGlzLnNjcmlwdCA9IHNhdmUuc2NyaXB0O1xuICAgIGlmICgnaW50ZXJ2YWxzJyBpbiBzYXZlKSB7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuX2ludGVydmFscy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhdmUuaW50ZXJ2YWxzLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsU2F2ZSkge1xuXG4gICAgICAgICAgICB0aGlzLl9hZGRJbnRlcnZhbChpbnRlcnZhbFNhdmUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5wLmlzSW5zaWRlQm91bmRzID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuICAgIHJldHVybiB0aGlzLl9pbnRlcnZhbHMuc29tZShmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblxuICAgICAgICBpZiAoaW50ZXJ2YWwuc3RhcnQgPD0gdGltZSAmJiBpbnRlcnZhbC5lbmQgPj0gdGltZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxucC5ydW5TY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAobmV3IEZ1bmN0aW9uKHRoaXMuc2NyaXB0KSkoKTsvL1RPRE8gaGFjayEhIVxufTtcblxucC5lZGl0U2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZGlhbG9nU2NyaXB0RWRpdG9yLnNob3coe1xuXG4gICAgICAgIHNjcmlwdDogdGhpcy5zY3JpcHQsXG4gICAgICAgIG9uQ2hhbmdlU2NyaXB0OiBmdW5jdGlvbiAoc2NyaXB0KSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cblxuXG5cblxuXG5cblxucC5fYWRkSW50ZXJ2YWwgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICB2YXIgaW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwob3B0KTtcblxuICAgIGludGVydmFsLnNob3dOZWlnaGJvdXJzKHRoaXMuX2ludGVydmFscyk7XG4gICAgaW50ZXJ2YWwub24oJ3JlbW92ZScsIHRoaXMuX29uUmVtb3ZlSW50ZXJ2YWwpO1xuXG4gICAgdGhpcy5kZUtleWxpbmUuYXBwZW5kQ2hpbGQoaW50ZXJ2YWwuZG9tRWxlbSk7XG4gICAgdGhpcy5faW50ZXJ2YWxzLnB1c2goaW50ZXJ2YWwpO1xufTtcblxucC5fcmVtb3ZlSW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblxuICAgIHZhciBpZHggPSB0aGlzLl9pbnRlcnZhbHMuaW5kZXhPZihpbnRlcnZhbCk7XG5cbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW50ZXJ2YWxzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgaW50ZXJ2YWwuZG9tRWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGludGVydmFsLmRvbUVsZW0pO1xuICAgIGludGVydmFsLnJlbW92ZUxpc3RlbmVyKCdyZW1vdmUnLCB0aGlzLl9vblJlbW92ZUludGVydmFsKTtcbiAgICBpbnRlcnZhbC5kaXNwb3NlKCk7XG59O1xuXG5cblxuXG5cblxuXG5cbnAuX29uRGVsZXRlS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuXG4gICAgdGhpcy5yZW1vdmVLZXkoa2V5KTtcbn07XG5cbnAuX29uQ2xpY2tPcGVuU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZGlhbG9nU2NyaXB0RWRpdG9yLnNob3coe1xuICAgICAgICBzY3JpcHQ6IHRoaXMuc2NyaXB0LFxuICAgICAgICBvbkNoYW5nZVNjcmlwdDogdGhpcy5fb25DaGFuZ2VTY3JpcHQsXG4gICAgfSk7XG59O1xuXG5wLl9vbkNoYW5nZVNjcmlwdCA9IGZ1bmN0aW9uIChzY3JpcHQpIHtcblxuICAgIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xufTtcblxucC5fb25SZW1vdmVJbnRlcnZhbCA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXG4gICAgdGhpcy5fcmVtb3ZlSW50ZXJ2YWwoaW50ZXJ2YWwpO1xufTtcblxucC5fb25EYmxjbGlja0tleWxpbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmVkaXRTY3JpcHQoKTtcbn07XG5cbnAub25TZWxlY3RBZGRJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aW1lID0gYW0udGltZWxpbmUuc2NyZWVuWFRvVGltZShhbS5tb3VzZS5zY3JlZW5YKSxcbiAgICAgICAgbmV4dFN0YXJ0ID0gdGltZSAtIDUwMCwgXG4gICAgICAgIHByZXZFbmQgPSB0aW1lICsgNTAwO1xuXG4gICAgaWYgKHRoaXMuaXNJbnNpZGVCb3VuZHModGltZSkpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW50ZXJ2YWxzLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsKSB7XG5cbiAgICAgICAgaWYgKGludGVydmFsLmVuZCA8IHRpbWUgJiYgKCFwcmV2RW5kIHx8IHByZXZFbmQgPCBpbnRlcnZhbC5lbmQpKSB7XG5cbiAgICAgICAgICAgIHByZXZFbmQgPSBpbnRlcnZhbC5lbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZXJ2YWwuc3RhcnQgPiB0aW1lICYmICghbmV4dFN0YXJ0IHx8IG5leHRTdGFydCA+IGludGVydmFsLnN0YXJ0KSkge1xuXG4gICAgICAgICAgICBuZXh0U3RhcnQgPSBpbnRlcnZhbC5zdGFydDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fYWRkSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogdGltZSAtIE1hdGgubWluKDUwMCwgKHByZXZFbmQgLSB0aW1lKSAqIDAuOCwgdGltZSksXG4gICAgICAgIGVuZDogdGltZSArIE1hdGgubWluKDUwMCwgKHRpbWUgLSBuZXh0U3RhcnQpICogMC44KSxcbiAgICB9KTtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxucC5fY3JlYXRlQm91bmRzTGluZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIGRlLnN0eWxlLmhlaWdodCA9IHRoaXMuX2xpbmVIICsgJ3B4JztcbiAgICBkZS5zdHlsZS5iYWNrZ3JvdW5kID0gJ2dyZXknO1xuICAgIGRlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblxuICAgIGFtZ3VpLmJpbmREcm9wZG93bih7XG4gICAgICAgIGFzQ29udGV4dE1lbnU6IHRydWUsXG4gICAgICAgIGRlVGFyZ2V0OiBkZSxcbiAgICAgICAgZGVNZW51OiBhbWd1aS5jcmVhdGVEcm9wZG93bih7XG4gICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAge3RleHQ6ICdhZGQgaW50ZXJ2YWwnLCBvblNlbGVjdDogdGhpcy5vblNlbGVjdEFkZEludGVydmFsfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRlO1xufTtcblxuXG5wLl9jcmVhdGVQYXJhbWV0ZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICBkZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBkZS5zdHlsZS5oZWlnaHQgPSB0aGlzLl9saW5lSCArICdweCc7XG4gICAgZGUuc3R5bGUuYmFja2dyb3VuZCA9ICdsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCBibHVlIDE4JSxkYXJrYmx1ZSA5NiUpJztcblxuICAgIHZhciBzcGFjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNwYWNlLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICBzcGFjZS5zdHlsZS5mbGV4ID0gJzEnO1xuICAgIHNwYWNlLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgZGUuYXBwZW5kQ2hpbGQoc3BhY2UpO1xuXG4gICAgdGhpcy5fYnRuT3BlblNjcmlwdCA9IGFtZ3VpLmNyZWF0ZUljb25CdG4oe1xuICAgICAgICBpY29uOiAnY29kZScsXG4gICAgICAgIGhlaWdodDogdGhpcy5fYmFzZUgsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xpY2tPcGVuU2NyaXB0LFxuICAgICAgICBwYXJlbnQ6IGRlXG4gICAgfSk7XG5cbiAgICAvLyB0aGlzLl9idG5FZGl0ID0gYW1ndWkuY3JlYXRlSWNvbkJ0bih7XG4gICAgLy8gICAgIGljb246ICd3cmVuY2gnLFxuICAgIC8vICAgICBoZWlnaHQ6IHRoaXMuX2Jhc2VILFxuICAgIC8vICAgICBwYXJlbnQ6IGRlXG4gICAgLy8gfSk7XG5cbiAgICAvLyBhbWd1aS5iaW5kRHJvcGRvd24oe1xuICAgIC8vICAgICBkZVRhcmdldDogdGhpcy5fYnRuRWRpdCxcbiAgICAvLyAgICAgZGVNZW51OiBhbWd1aS5jcmVhdGVEcm9wZG93bih7XG4gICAgLy8gICAgICAgICBvcHRpb25zOiBbXG4gICAgLy8gICAgICAgICAgICAge3RleHQ6ICdtZXJnZSd9LFxuICAgIC8vICAgICAgICAgICAgIHt0ZXh0OiAnc3BsaXQnfSxcbiAgICAvLyAgICAgICAgICAgICB7dGV4dDogJ2VuZCBoZXJlJ30sXG4gICAgLy8gICAgICAgICAgICAge3RleHQ6ICdzdGFydCBoZXJlJ30sXG4gICAgLy8gICAgICAgICAgICAge3RleHQ6ICdhZGQnLCBpY29uOiAncGx1cyd9LFxuICAgIC8vICAgICAgICAgICAgIHt0ZXh0OiAncmVtb3ZlJywgaWNvbjogJ21pbnVzJ30sXG4gICAgLy8gICAgICAgICBdXG4gICAgLy8gICAgIH0pLFxuICAgIC8vICAgICBvblNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICAgICAgYW0uZGlhbG9ncy5mZWF0dXJlRG9lc250RXhpc3Quc2hvdygpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfSk7XG5cbiAgICBhbWd1aS5iaW5kRHJvcGRvd24oe1xuICAgICAgICBhc0NvbnRleHRNZW51OiB0cnVlLFxuICAgICAgICBkZVRhcmdldDogZGUsXG4gICAgICAgIGRlTWVudTogYW1ndWkuY3JlYXRlRHJvcGRvd24oe1xuICAgICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgICAgIHt0ZXh0OiAnbW92ZSB1cCcsIG9uU2VsZWN0OiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnbW92ZScsIHRoaXMsIC0xKX0sXG4gICAgICAgICAgICAgICAge3RleHQ6ICdtb3ZlIGRvd24nLCBvblNlbGVjdDogdGhpcy5lbWl0LmJpbmQodGhpcywgJ21vdmUnLCB0aGlzLCAxKX0sXG4gICAgICAgICAgICAgICAge3RleHQ6ICdkZWxldGUnLCBvblNlbGVjdDogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2RlbGV0ZScsIHRoaXMpfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIHJldHVybiBkZTtcbn07XG5cbnAuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vVE9ET1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnZhbFNjcmlwdDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgYW1ndWkgPSByZXF1aXJlKCcuLi8uLi9hbWd1aScpO1xudmFyIEludGVydmFsU2NyaXB0ID0gcmVxdWlyZSgnLi9JbnRlcnZhbFNjcmlwdCcpO1xudmFyIE1vbWVudFNjcmlwdCA9IHJlcXVpcmUoJy4vTW9tZW50U2NyaXB0Jyk7XG52YXIgbXN0UGxheWVyID0gcmVxdWlyZSgnLi9zY3JpcHQucGxheWVyLm1zdCcpO1xudmFyIGRpYWxvZ1NlcXVPcHRpb25zID0gcmVxdWlyZSgnLi9kaWFsb2dTZXF1T3B0aW9ucycpO1xuXG5mdW5jdGlvbiBKc1NlcXVlbmNlKG9wdCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9pbnRlcnZhbFNjcmlwdHMgPSBbXTtcbiAgICB0aGlzLl9tb21lbnRTY3JpcHRzID0gW107XG4gICAgdGhpcy5fYmFzZUggPSAyMTtcbiAgICB0aGlzLl9pc1Nob3dpbmdJbnRlcnZhbFNjcmlwcyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzSGlkaW5nU2VsZWN0ZWRFbGVtcyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fb25TZWxlY3RDbGljayA9IHRoaXMuX29uU2VsZWN0Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVRpbWUgPSB0aGlzLl9vbkNoYW5nZVRpbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUludGVydmFsU2NyaXB0ID0gdGhpcy5fb25DaGFuZ2VJbnRlcnZhbFNjcmlwdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRGVsZXRlSW50ZXJ2YWxTY3JpcHQgPSB0aGlzLl9vbkRlbGV0ZUludGVydmFsU2NyaXB0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3ZlSW50ZXJ2YWxTY3JpcHQgPSB0aGlzLl9vbk1vdmVJbnRlcnZhbFNjcmlwdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2xpY2tBZGRJbnRlcnZhbFNjcmlwdCA9IHRoaXMuX29uQ2xpY2tBZGRJbnRlcnZhbFNjcmlwdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2xpY2tUZ2dsU2hvd0ludGVydmFsU2NyaXB0cyA9IHRoaXMuX29uQ2xpY2tUZ2dsU2hvd0ludGVydmFsU2NyaXB0cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2xpY2tUZ2dsTW9tZW50U2NyaXB0ID0gdGhpcy5fb25DbGlja1RnZ2xNb21lbnRTY3JpcHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNsaWNrRWRpdE1vbWVudFNjcmlwdCA9IHRoaXMuX29uQ2xpY2tFZGl0TW9tZW50U2NyaXB0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DbGlja05hbWUgPSB0aGlzLl9vbkNsaWNrTmFtZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2hhbmdlTmFtZSA9IHRoaXMuX29uQ2hhbmdlTmFtZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2hhbmdlTmFtZSA9IHRoaXMuX29uQ2hhbmdlTmFtZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2FuaW1QbGF5ID0gdGhpcy5fYW5pbVBsYXkuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZGVPcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kZUtleXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHRoaXMuX2RlSGVhZE9wdGlub3MgPSB0aGlzLl9jcmVhdGVIZWFkT3B0aW9ucygpO1xuICAgIHRoaXMuX2RlSGVhZEtleWxpbmUgPSBhbWd1aS5jcmVhdGVLZXlsaW5lKHt9KTtcbiAgICB0aGlzLmRlS2V5cy5hcHBlbmRDaGlsZCh0aGlzLl9kZUhlYWRLZXlsaW5lKTtcblxuICAgIGFtLnRpbWVsaW5lLm9uKCdjaGFuZ2VUaW1lJywgdGhpcy5fb25DaGFuZ2VUaW1lKTtcbiAgICB0aGlzLmRlT3B0aW9ucy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uU2VsZWN0Q2xpY2spO1xuICAgIHRoaXMuZGVLZXlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25TZWxlY3RDbGljayk7XG5cbiAgICBpZiAob3B0KSB7XG4gICAgICAgIHRoaXMudXNlU2F2ZShvcHQpO1xuICAgIH1cbn1cblxuaW5oZXJpdHMoSnNTZXF1ZW5jZSwgRXZlbnRFbWl0dGVyKTtcbnZhciBwID0gSnNTZXF1ZW5jZS5wcm90b3R5cGU7XG5cbnAudHlwZSA9ICdqc19zZXF1X3R5cGUnO1xuXG5cblxuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXG4gICAgaGVpZ2h0OiB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLl9iYXNlSDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2hvd2luZ0ludGVydmFsU2NyaXBzKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcnZhbFNjcmlwdHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWxTY3JpcHQpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXQgKz0gaW50ZXJ2YWxTY3JpcHQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5hbWU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAodiA9PT0gdGhpcy5fbmFtZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gdiB8fCAndW5uYW1lZCc7XG4gICAgICAgICAgICB0aGlzLl9kZU5hbWUudGV4dENvbnRlbnQgPSB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5cblxuXG5cbnAuZ2V0U2F2ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzYXZlID0ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIGludGVydmFsU2NyaXB0czogW10sXG4gICAgICAgIG1vbWVudFNjcmlwdHM6IFtdLFxuICAgICAgICBpc1Nob3dpbmdJbnRlcnZhbFNjcmlwdHM6IHRoaXMuX2lzU2hvd2luZ0ludGVydmFsU2NyaXBzLFxuICAgIH07XG5cbiAgICB0aGlzLl9pbnRlcnZhbFNjcmlwdHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWxTY3JpcHQpIHtcblxuICAgICAgICBzYXZlLmludGVydmFsU2NyaXB0cy5wdXNoKGludGVydmFsU2NyaXB0LmdldFNhdmUoKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9tb21lbnRTY3JpcHRzLmZvckVhY2goZnVuY3Rpb24gKG1vbWVudFNjcmlwdCkge1xuXG4gICAgICAgIHNhdmUubW9tZW50U2NyaXB0cy5wdXNoKG1vbWVudFNjcmlwdC5nZXRTYXZlKCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNhdmU7XG59O1xuXG5wLnVzZVNhdmUgPSBmdW5jdGlvbiAoc2F2ZSkge1xuXG4gICAgaWYgKCFzYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zZWxlY3RvcnMgPSBzYXZlLnNlbGVjdG9ycyB8fCBbXTtcblxuICAgIGlmICgnbmFtZScgaW4gc2F2ZSkgdGhpcy5uYW1lID0gc2F2ZS5uYW1lO1xuXG4gICAgaWYgKHNhdmUuaW50ZXJ2YWxTY3JpcHRzKSB7XG5cbiAgICAgICAgc2F2ZS5pbnRlcnZhbFNjcmlwdHMuZm9yRWFjaCh0aGlzLmFkZEludGVydmFsU2NyaXB0LCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoc2F2ZS5tb21lbnRTY3JpcHRzKSB7XG5cbiAgICAgICAgc2F2ZS5tb21lbnRTY3JpcHRzLmZvckVhY2godGhpcy5hZGRNb21lbnRTY3JpcHQsIHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChzYXZlLmlzU2hvd2luZ0ludGVydmFsU2NyaXB0cykge1xuXG4gICAgICAgIHRoaXMuX3Nob3dJbnRlcnZhbFNjcmlwdHMoKTtcbiAgICB9XG59O1xuXG5wLmdldFNjcmlwdCA9IGZ1bmN0aW9uICgpIHsvL1RPRE9cblxuICAgIHZhciBtb21lbnRTY3JpcHRzID0gW10sIGludGVydmFsU2NyaXB0cyA9IFtdO1xuXG4gICAgdGhpcy5faW50ZXJ2YWxTY3JpcHRzLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsU2NyaXB0KSB7XG5cbiAgICB9KTtcblxuICAgIHZhciBjb2RlID0gTXVzdGFjaGUucmVuZGVyKG1zdFBsYXllciwge1xuICAgICAgICBtb21lbnRTY3JpcHRzOiBKU09OLnN0cmluZ2lmeShtb21lbnRTY3JpcHRzKSxcbiAgICAgICAgaW50ZXJ2YWxTY3JpcHRzOiBKU09OLnN0cmluZ2lmeShpbnRlcnZhbFNjcmlwdHMpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gJ2Z1bmN0aW9uICgpIHsvKlRPRE8qL30nO1xufTtcblxucC5hZGRJbnRlcnZhbFNjcmlwdCA9IGZ1bmN0aW9uIChvcHQsIHNraXBIaXN0b3J5KSB7XG5cbiAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICB2YXIgaW50ZXJ2YWxTY3JpcHQgPSBuZXcgSW50ZXJ2YWxTY3JpcHQob3B0KTtcblxuICAgIGlmICghc2tpcEhpc3RvcnkpIHtcbiAgICAgICAgYW0uaGlzdG9yeS5zYXZlKFt0aGlzLl9yZW1vdmVJbnRlcnZhbFNjcmlwdCwgdGhpcywgaW50ZXJ2YWxTY3JpcHQsIHRydWVdLFxuICAgICAgICAgICAgW3RoaXMuYWRkSW50ZXJ2YWxTY3JpcHQsIHRoaXMsIG9wdCwgdHJ1ZV0pO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9pbnRlcnZhbFNjcmlwdHMucHVzaChpbnRlcnZhbFNjcmlwdCk7XG4gICAgaW50ZXJ2YWxTY3JpcHQub24oJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlSW50ZXJ2YWxTY3JpcHQpO1xuICAgIGludGVydmFsU2NyaXB0Lm9uKCdkZWxldGUnLCB0aGlzLl9vbkRlbGV0ZUludGVydmFsU2NyaXB0KTtcbiAgICBpbnRlcnZhbFNjcmlwdC5vbignbW92ZScsIHRoaXMuX29uTW92ZUludGVydmFsU2NyaXB0KTtcblxuICAgIHRoaXMuX3JlZnJlc2hJbnRlcnZhbFNjcmlwdE9yZGVyaW5nKCk7XG4gICAgdGhpcy5lbWl0KCdjaGFuZ2VIZWlnaHQnLCB0aGlzKTtcblxuICAgIHJldHVybiBpbnRlcnZhbFNjcmlwdDtcbn07XG5cbnAucmVtb3ZlSW50ZXJ2YWxTY3JpcHQgPSBmdW5jdGlvbiAoaW50ZXJ2YWxTY3JpcHQsIHNraXBIaXN0b3J5KSB7XG5cbiAgICBpZiAoIXNraXBIaXN0b3J5KSB7XG4gICAgICAgIGFtLmhpc3Rvcnkuc2F2ZShbdGhpcy5hZGRJbnRlcnZhbFNjcmlwdCwgdGhpcywgaW50ZXJ2YWxTY3JpcHQsIHRydWVdLFxuICAgICAgICAgICAgW3RoaXMucmVtb3ZlSW50ZXJ2YWxTY3JpcHQsIHRoaXMsIGludGVydmFsU2NyaXB0LCB0cnVlXSk7XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IHRoaXMuX2ludGVydmFsU2NyaXB0cy5pbmRleE9mKGludGVydmFsU2NyaXB0KTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnRlcnZhbFNjcmlwdHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICBpbnRlcnZhbFNjcmlwdC5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VJbnRlcnZhbFNjcmlwdCk7XG4gICAgaW50ZXJ2YWxTY3JpcHQucmVtb3ZlTGlzdGVuZXIoJ2RlbGV0ZScsIHRoaXMuX29uRGVsZXRlSW50ZXJ2YWxTY3JpcHQpO1xuICAgIGludGVydmFsU2NyaXB0LnJlbW92ZUxpc3RlbmVyKCdtb3ZlJywgdGhpcy5fb25Nb3ZlSW50ZXJ2YWxTY3JpcHQpO1xuXG4gICAgJChpbnRlcnZhbFNjcmlwdC5kZU9wdGlvbnMpLnJlbW92ZSgpO1xuICAgICQoaW50ZXJ2YWxTY3JpcHQuZGVLZXlsaW5lKS5yZW1vdmUoKTtcbn07XG5cbnAubW92ZUludGVydmFsU2NyaXB0ID0gZnVuY3Rpb24gKGludGVydmFsU2NyaXB0LCB3YXkpIHtcblxuICAgIHZhciBpZHggPSB0aGlzLl9pbnRlcnZhbFNjcmlwdHMuaW5kZXhPZihpbnRlcnZhbFNjcmlwdCk7XG5cbiAgICB0aGlzLl9pbnRlcnZhbFNjcmlwdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgaWR4ID0gTWF0aC5taW4odGhpcy5faW50ZXJ2YWxTY3JpcHRzLmxlbmd0aCwgTWF0aC5tYXgoMCwgaWR4ICsgd2F5KSk7XG4gICAgdGhpcy5faW50ZXJ2YWxTY3JpcHRzLnNwbGljZShpZHgsIDAsIGludGVydmFsU2NyaXB0KTtcblxuICAgIHRoaXMuX3JlZnJlc2hJbnRlcnZhbFNjcmlwdE9yZGVyaW5nKCk7XG59O1xuXG5cbnAuYWRkTW9tZW50U2NyaXB0ID0gZnVuY3Rpb24gKG9wdCwgc2tpcEhpc3RvcnkpIHtcbiAgICBcbiAgICB2YXIgbXMgPSB0aGlzLmdldE1vbWVudFNjcmlwdChvcHQudGltZSk7XG5cbiAgICBpZiAobXMpIHtcblxuICAgICAgICBpZiAoJ3NjcmlwdCcgaW4gb3B0KSB7XG5cbiAgICAgICAgICAgIGlmICghc2tpcEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhbS5oaXN0b3J5LnNhdmVDaGFpbihtcywgW3RoaXMuYWRkTW9tZW50U2NyaXB0LCB0aGlzLCBtcywgdHJ1ZV0sIFt0aGlzLmFkZE1vbWVudFNjcmlwdCwgdGhpcywgb3B0LCB0cnVlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1zLnNjcmlwdCA9IG9wdC5zY3JpcHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgbXMgPSBuZXcgTW9tZW50U2NyaXB0KF8uZXh0ZW5kKHtkZUtleWxpbmU6IHRoaXMuX2RlSGVhZEtleWxpbmV9LCBvcHQpKTtcblxuICAgICAgICAvLyBtcy5vbignY2hhbmdlVGltZScsIHRoaXMuX29uQ2hhbmdlS2V5VGltZSk7Ly9UT0RPXG4gICAgICAgIC8vIG1zLm9uKCdkZWxldGUnLCB0aGlzLl9vbkRlbGV0ZUtleSk7Ly9UT0RPXG5cbiAgICAgICAgdGhpcy5fbW9tZW50U2NyaXB0cy5wdXNoKG1zKTtcblxuICAgICAgICBpZiAoIXNraXBIaXN0b3J5KSB7XG4gICAgICAgICAgICBhbS5oaXN0b3J5LmNsb3NlQ2hhaW4obXMpO1xuICAgICAgICAgICAgYW0uaGlzdG9yeS5zYXZlKFt0aGlzLnJlbW92ZU1vbWVudFNjcmlwdCwgdGhpcywgb3B0LnRpbWUsIHRydWVdLCBbdGhpcy5hZGRNb21lbnRTY3JpcHQsIHRoaXMsIG9wdCwgdHJ1ZV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVmcmVzaFRnZ2xNb21lbnRTY3JpcHQoKTtcblxuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG5cbiAgICByZXR1cm4gbXM7XG59O1xuXG5wLnJlbW92ZU1vbWVudFNjcmlwdCA9IGZ1bmN0aW9uIChtcywgc2tpcEhpc3RvcnkpIHtcblxuICAgIGlmICh0eXBlb2YobXMpID09PSAnbnVtYmVyJykge1xuXG4gICAgICAgIG1zID0gdGhpcy5nZXRNb21lbnRTY3JpcHQobXMpO1xuICAgIH1cblxuICAgIHZhciBpZHggPSB0aGlzLl9tb21lbnRTY3JpcHRzLmluZGV4T2YobXMpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFza2lwSGlzdG9yeSkge1xuICAgICAgICBhbS5oaXN0b3J5LnNhdmUoW3RoaXMuYWRkTW9tZW50U2NyaXB0LCB0aGlzLCBtcywgdHJ1ZV0sXG4gICAgICAgICAgICBbdGhpcy5yZW1vdmVNb21lbnRTY3JpcHQsIHRoaXMsIG1zLCB0cnVlXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9tZW50U2NyaXB0cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIG1zLmRpc3Bvc2UoKTtcblxuICAgIC8vIG1zLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2VUaW1lJywgdGhpcy5fb25DaGFuZ2VLZXlUaW1lKTsvL1RPRE9cbiAgICAvLyBtcy5yZW1vdmVMaXN0ZW5lcignZGVsZXRlJywgdGhpcy5fb25EZWxldGVLZXkpOy8vVE9ET1xuXG4gICAgdGhpcy5fcmVmcmVzaFRnZ2xNb21lbnRTY3JpcHQoKTtcblxuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG5wLmdldE1vbWVudFNjcmlwdCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fbW9tZW50U2NyaXB0cy5maW5kKGZ1bmN0aW9uKG1zKSB7XG5cbiAgICAgICAgcmV0dXJuIG1zLnRpbWUgPT09IHRpbWU7XG4gICAgfSk7XG59O1xuXG5cbnAuc2VsZWN0ID0gZnVuY3Rpb24gKG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX2lzU2VsZWN0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9pc1NlbGVjdGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVIaWdobGlnaHQuc3R5bGUub3BhY2l0eSA9IDE7XG5cbiAgICB0aGlzLmVtaXQoJ3NlbGVjdCcsIHRoaXMpO1xufTtcblxucC5kZXNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5faXNTZWxlY3RlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZGVIaWdobGlnaHQuc3R5bGUub3BhY2l0eSA9IDA7XG59O1xuXG5wLnJlbmRlclRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuXG4gICAgLy9UT0RPXG59O1xuXG5wLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fYW5pbVBsYXkoKTtcbn07XG5cbnAucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltUGxheVJhZmlkKTtcbn07XG5cbnAuZ2V0TWFnbmV0UG9pbnRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRpbWVzID0gW107XG5cbiAgICB0aGlzLl9tb21lbnRTY3JpcHRzLmZvckVhY2goZnVuY3Rpb24gKG1vbWVudFNjcmlwdCkge1xuXG4gICAgICAgIHRpbWVzLnB1c2gobW9tZW50U2NyaXB0LnRpbWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRpbWVzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxucC5fYW5pbVBsYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9hbmltUGxheVJhZmlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltUGxheSk7XG4gICAgXG4gICAgdmFyIGN1cnJUaW1lID0gYW0udGltZWxpbmUuY3VyclRpbWUsIFxuICAgICAgICBwcmV2VGltZSA9IHRoaXMucHJldlJlbmRlclRpbWU7XG5cbiAgICB0aGlzLl9tb21lbnRTY3JpcHRzLmZvckVhY2goZnVuY3Rpb24gKG1vbWVudFNjcmlwdCkge1xuXG4gICAgICAgIGlmIChtb21lbnRTY3JpcHQudGltZSA+IHByZXZUaW1lICYmIG1vbWVudFNjcmlwdC50aW1lIDw9IGN1cnJUaW1lKSB7XG5cbiAgICAgICAgICAgIG1vbWVudFNjcmlwdC5ydW5TY3JpcHQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW50ZXJ2YWxTY3JpcHRzLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsU2NyaXB0KSB7XG5cbiAgICAgICAgaWYgKGludGVydmFsU2NyaXB0LmlzSW5zaWRlQm91bmRzKGN1cnJUaW1lKSkge1xuXG4gICAgICAgICAgICBpbnRlcnZhbFNjcmlwdC5ydW5TY3JpcHQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wcmV2UmVuZGVyVGltZSA9IGN1cnJUaW1lO1xufTtcblxucC5fc2hvd0ludGVydmFsU2NyaXB0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLl9pc1Nob3dpbmdJbnRlcnZhbFNjcmlwcykgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2hvd2luZ0ludGVydmFsU2NyaXBzID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RnZ2xTaG93SW50ZXJ2YWxTY3JpcHRzLnNldFRvZ2dsZSh0cnVlKTtcbiAgICB0aGlzLmVtaXQoJ2NoYW5nZUhlaWdodCcsIHRoaXMpO1xufTtcblxucC5faGlkZUludGVydmFsU2NyaXB0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5faXNTaG93aW5nSW50ZXJ2YWxTY3JpcHMpIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3dpbmdJbnRlcnZhbFNjcmlwcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGdnbFNob3dJbnRlcnZhbFNjcmlwdHMuc2V0VG9nZ2xlKGZhbHNlKTtcbiAgICB0aGlzLmVtaXQoJ2NoYW5nZUhlaWdodCcsIHRoaXMpO1xufTtcblxuXG5cblxuXG5cblxuXG5wLl9vblNlbGVjdENsaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5zZWxlY3QoKTtcbn07XG5cbnAuX29uQ2hhbmdlVGltZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZnJlc2hUZ2dsTW9tZW50U2NyaXB0KCk7XG59O1xuXG5wLl9vbkNoYW5nZUludGVydmFsU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5yZW5kZXJUaW1lKCk7XG5cbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xufTtcblxucC5fb25EZWxldGVJbnRlcnZhbFNjcmlwdCA9IGZ1bmN0aW9uIChpbnRlcnZhbFNjcmlwdCkge1xuXG4gICAgdGhpcy5yZW1vdmVJbnRlcnZhbFNjcmlwdChpbnRlcnZhbFNjcmlwdCk7XG59O1xuXG5wLl9vbk1vdmVJbnRlcnZhbFNjcmlwdCA9IGZ1bmN0aW9uIChpbnRlcnZhbFNjcmlwdCwgd2F5KSB7XG5cbiAgICB0aGlzLm1vdmVJbnRlcnZhbFNjcmlwdChpbnRlcnZhbFNjcmlwdCwgd2F5KTtcbn07XG5cbnAuX29uQ2xpY2tUZ2dsTW9tZW50U2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRpbWUgPSBhbS50aW1lbGluZS5jdXJyVGltZSxcbiAgICAgICAgbW9tZW50U2NyaXB0ID0gdGhpcy5nZXRNb21lbnRTY3JpcHQodGltZSk7XG4gICAgXG4gICAgaWYgKG1vbWVudFNjcmlwdCkge1xuXG4gICAgICAgIHRoaXMucmVtb3ZlTW9tZW50U2NyaXB0KG1vbWVudFNjcmlwdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFkZE1vbWVudFNjcmlwdCh7dGltZTogdGltZX0pO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZnJlc2hUZ2dsTW9tZW50U2NyaXB0KCk7XG59O1xuXG5wLl9vbkNsaWNrRWRpdE1vbWVudFNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtb21lbnRTY3JpcHQgPSB0aGlzLmdldE1vbWVudFNjcmlwdChhbS50aW1lbGluZS5jdXJyVGltZSk7XG5cbiAgICBpZiAobW9tZW50U2NyaXB0KSB7XG5cbiAgICAgICAgbW9tZW50U2NyaXB0LmVkaXRTY3JpcHQoKTtcbiAgICB9XG59O1xuXG5wLl9vbkNsaWNrVGdnbFNob3dJbnRlcnZhbFNjcmlwdHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNTaG93aW5nSW50ZXJ2YWxTY3JpcHMpIHtcbiAgICAgICAgdGhpcy5faGlkZUludGVydmFsU2NyaXB0cyAgICgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2hvd0ludGVydmFsU2NyaXB0cygpO1xuICAgIH1cbn07XG5cbnAuX29uQ2xpY2tBZGRJbnRlcnZhbFNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuYWRkSW50ZXJ2YWxTY3JpcHQoKTtcbn07XG5cbnAuX29uQ2xpY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZGlhbG9nU2VxdU9wdGlvbnMuc2hvdyh7XG4gICAgICAgIG5hbWU6IHRoaXMuX25hbWUsXG4gICAgICAgIG9uQ2hhbmdlTmFtZTogdGhpcy5fb25DaGFuZ2VOYW1lLFxuICAgIH0pO1xufTtcblxucC5fb25DaGFuZ2VOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5wLl9yZWZyZXNoVGdnbE1vbWVudFNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtb21lbnRTY3JpcHQgPSB0aGlzLmdldE1vbWVudFNjcmlwdChhbS50aW1lbGluZS5jdXJyVGltZSk7XG5cbiAgICB0aGlzLl90Z2dsTW9tZW50U2NyaXB0LnNldFRvZ2dsZSghIW1vbWVudFNjcmlwdCk7XG4gICAgdGhpcy5fdGdnbEVkaXRNb21lbnRTY3JpcHQuc2V0VG9nZ2xlKCEhbW9tZW50U2NyaXB0KTtcbn07XG5cbnAuX3JlZnJlc2hJbnRlcnZhbFNjcmlwdE9yZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5faW50ZXJ2YWxTY3JpcHRzLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsU2NyaXB0KSB7XG5cbiAgICAgICAgdGhpcy5kZU9wdGlvbnMuYXBwZW5kQ2hpbGQoaW50ZXJ2YWxTY3JpcHQuZGVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5kZUtleXMuYXBwZW5kQ2hpbGQoaW50ZXJ2YWxTY3JpcHQuZGVLZXlsaW5lKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxucC5fY3JlYXRlSGVhZE9wdGlvbnMgPSBmdW5jdGlvbiAoKXtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBkZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBkZS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIGRlLnN0eWxlLmhlaWdodCA9IHRoaXMuX2Jhc2VIICsgJ3B4JztcbiAgICBkZS5zdHlsZS5iYWNrZ3JvdW5kID0gJ2xpbmVhci1ncmFkaWVudCh0byBib3R0b20sIGJsdWUgMTglLGRhcmtibHVlIDk2JSknO1xuICAgIHRoaXMuZGVPcHRpb25zLmFwcGVuZENoaWxkKGRlKTtcblxuICAgIHRoaXMuZGVIaWdobGlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRlSGlnaGxpZ2h0LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB0aGlzLmRlSGlnaGxpZ2h0LnN0eWxlLndpZHRoID0gJzJweCc7XG4gICAgdGhpcy5kZUhpZ2hsaWdodC5zdHlsZS5oZWlnaHQgPSB0aGlzLl9iYXNlSCArICdweCc7XG4gICAgdGhpcy5kZUhpZ2hsaWdodC5zdHlsZS5iYWNrZ3JvdW5kID0gJ2dvbGQnO1xuICAgIHRoaXMuZGVIaWdobGlnaHQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgZGUuYXBwZW5kQ2hpbGQodGhpcy5kZUhpZ2hsaWdodCk7XG5cbiAgICB0aGlzLl90Z2dsU2hvd0ludGVydmFsU2NyaXB0cyA9IGFtZ3VpLmNyZWF0ZVRvZ2dsZUljb25CdG4oe1xuICAgICAgICBpY29uT246ICdhbmdsZS1kb3duJyxcbiAgICAgICAgaWNvbk9mZjogJ2FuZ2xlLXJpZ2h0JyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9iYXNlSCxcbiAgICAgICAgb25DbGljazogdGhpcy5fb25DbGlja1RnZ2xTaG93SW50ZXJ2YWxTY3JpcHRzLFxuICAgICAgICBwYXJlbnQ6IGRlXG4gICAgfSk7XG5cbiAgICB0aGlzLl9kZU5hbWUgPSBhbWd1aS5jcmVhdGVMYWJlbCh7Y2FwdGlvbjogdGhpcy5fbmFtZSwgcGFyZW50OiBkZX0pO1xuICAgIHRoaXMuX2RlTmFtZS5zdHlsZS5oZWlnaHQgPSB0aGlzLl9iYXNlSCAgKyAncHgnO1xuICAgIHRoaXMuX2RlTmFtZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgdGhpcy5fZGVOYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGlja05hbWUpO1xuXG4gICAgdmFyIGRlTmFtZUljb24gPSBhbWd1aS5jcmVhdGVJY29uKHtcbiAgICAgICAgaWNvbjogJ2NvZycsXG4gICAgICAgIHBhcmVudDogZGVcbiAgICB9KTtcbiAgICBkZU5hbWVJY29uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5fZGVOYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7ZGVOYW1lSWNvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7fSk7XG4gICAgdGhpcy5fZGVOYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7ZGVOYW1lSWNvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO30pO1xuXG4gICAgdmFyIHNwYWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3BhY2Uuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIHNwYWNlLnN0eWxlLmZsZXggPSAnMSc7XG4gICAgc3BhY2Uuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICBkZS5hcHBlbmRDaGlsZChzcGFjZSk7XG5cbiAgICB0aGlzLl9idG5BZGRJbnRlcnZhbFNjcmlwdCA9IGFtZ3VpLmNyZWF0ZUljb25CdG4oe1xuICAgICAgICBpY29uOiAncGx1cycsXG4gICAgICAgIGhlaWdodDogdGhpcy5fYmFzZUgsXG4gICAgICAgIGRlZmF1bHRUb2dnbGU6IGZhbHNlLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrQWRkSW50ZXJ2YWxTY3JpcHQsXG4gICAgICAgIHBhcmVudDogZGVcbiAgICB9KTtcblxuICAgIHRoaXMuX3RnZ2xFZGl0TW9tZW50U2NyaXB0ID0gYW1ndWkuY3JlYXRlVG9nZ2xlSWNvbkJ0bih7XG4gICAgICAgIGljb246ICdjb2RlJyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9iYXNlSCxcbiAgICAgICAgb25DbGljazogdGhpcy5fb25DbGlja0VkaXRNb21lbnRTY3JpcHQsXG4gICAgICAgIGNoYW5nZUNvbG9yOiB0cnVlLFxuICAgICAgICBwYXJlbnQ6IGRlXG4gICAgfSk7XG5cbiAgICB0aGlzLl90Z2dsTW9tZW50U2NyaXB0ID0gYW1ndWkuY3JlYXRlVG9nZ2xlSWNvbkJ0bih7XG4gICAgICAgIGljb25PbjogJ2NpcmNsZScsXG4gICAgICAgIGljb25PZmY6ICdjaXJjbGUtZW1wdHknLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2Jhc2VILFxuICAgICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrVGdnbE1vbWVudFNjcmlwdCxcbiAgICAgICAgY2hhbmdlQ29sb3I6IHRydWUsXG4gICAgICAgIHBhcmVudDogZGVcbiAgICB9KTtcbiAgICB0aGlzLl9yZWZyZXNoVGdnbE1vbWVudFNjcmlwdCgpO1xuXG4gICAgYW1ndWkuYmluZERyb3Bkb3duKHtcbiAgICAgICAgYXNDb250ZXh0TWVudTogdHJ1ZSxcbiAgICAgICAgZGVUYXJnZXQ6IGRlLFxuICAgICAgICBkZU1lbnU6IGFtZ3VpLmNyZWF0ZURyb3Bkb3duKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7dGV4dDogJ21vdmUgdXAnLCBvblNlbGVjdDogdGhpcy5lbWl0LmJpbmQodGhpcywgJ21vdmUnLCB0aGlzLCAtMSl9LFxuICAgICAgICAgICAgICAgIHt0ZXh0OiAnbW92ZSBkb3duJywgb25TZWxlY3Q6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdtb3ZlJywgdGhpcywgMSl9LFxuICAgICAgICAgICAgICAgIHt0ZXh0OiAnZGVsZXRlJywgb25TZWxlY3Q6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdkZWxldGUnLCB0aGlzKX0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGU7XG59O1xuXG5wLmlzT3duZWREb21FbGVtID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxucC5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgYW0udGltZWxpbmUucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZVRpbWUpO1xuXG4gICAgLy9UT0RPXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzU2VxdWVuY2U7XG5cblxuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgZGlhbG9nU2NyaXB0RWRpdG9yID0gcmVxdWlyZSgnLi9kaWFsb2dTY3JpcHRFZGl0b3InKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uLy4uL2FtZ3VpJyk7XG5cbmZ1bmN0aW9uIE1vbWVudFNjcmlwdChvcHQpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuX3RpbWUgPSAgMDtcbiAgICB0aGlzLl9zY3JpcHQgPSAgJyc7XG4gICAgdGhpcy5fZGVLZXlsaW5lID0gb3B0LmRlS2V5bGluZTtcblxuICAgIHRoaXMuX29uQ2hhbmdlRGVUaW1lID0gdGhpcy5fb25DaGFuZ2VEZVRpbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNlbGVjdERyb3Bkb3duID0gdGhpcy5fb25TZWxlY3REcm9wZG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2hhbmdlVGFwZSA9IHRoaXMuX29uQ2hhbmdlVGFwZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRGJsY2xpY2tLZXkgPSB0aGlzLl9vbkRibGNsaWNrS2V5LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmRvbUVsZW0gPSB0aGlzLl9kZUtleWxpbmUuYWRkS2V5KHtcbiAgICAgICAgdGltZXNjYWxlOiBhbS50aW1lbGluZS50aW1lc2NhbGUsXG4gICAgICAgIHRpbWU6IHRoaXMudGltZSxcbiAgICAgICAgZWFzZTogJ25vbmUnXG4gICAgfSk7XG5cblxuICAgIHRoaXMuX2RlTWVudSA9IGFtZ3VpLmNyZWF0ZURyb3Bkb3duKHtcbiAgICAgICAgb3B0aW9uczogWydzY3JpcHQnLCAnZGVsZXRlJ11cbiAgICB9KTtcbiAgICB0aGlzLl9kZU1lbnUuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0JywgdGhpcy5fb25TZWxlY3REcm9wZG93bik7XG5cbiAgICB0aGlzLmRvbUVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlVGltZScsIHRoaXMuX29uQ2hhbmdlRGVUaW1lKTtcbiAgICBhbS50aW1lbGluZS5vbignY2hhbmdlVGFwZScsIHRoaXMuX29uQ2hhbmdlVGFwZSk7XG5cbiAgICBhbWd1aS5iaW5kRHJvcGRvd24oe1xuICAgICAgICBkZVRhcmdldDogdGhpcy5kb21FbGVtLFxuICAgICAgICBkZU1lbnU6IHRoaXMuX2RlTWVudSxcbiAgICAgICAgYXNDb250ZXh0TWVudTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5kb21FbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fb25EYmxjbGlja0tleSk7XG5cbiAgICBpZiAob3B0KSB7XG4gICAgICAgIHRoaXMudXNlU2F2ZShvcHQpO1xuICAgIH1cbn1cblxuaW5oZXJpdHMoTW9tZW50U2NyaXB0LCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBNb21lbnRTY3JpcHQucHJvdG90eXBlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cbiAgICB0aW1lOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikgfHwgdGhpcy5fdGltZSA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdjtcblxuICAgICAgICAgICAgdGhpcy5kb21FbGVtLnNldFRpbWUodGhpcy5fdGltZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2NyaXB0OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjcmlwdCA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9zY3JpcHQgPSB2O1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbnAuZ2V0U2F2ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNjcmlwdDogSlNPTi5zdHJpbmdpZnkodGhpcy5zY3JpcHQpLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC8nL2csICdcXFxcXFwnJyksXG4gICAgICAgIHRpbWU6IHRoaXMudGltZSxcbiAgICB9O1xufTtcblxucC51c2VTYXZlID0gZnVuY3Rpb24gKHNhdmUpIHtcblxuICAgIGlmICgnc2NyaXB0JyBpbiBzYXZlKSB0aGlzLnNjcmlwdCA9IHNhdmUuc2NyaXB0O1xuICAgIGlmICgndGltZScgaW4gc2F2ZSkgdGhpcy50aW1lID0gc2F2ZS50aW1lO1xufTtcblxucC5ydW5TY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAobmV3IEZ1bmN0aW9uKHRoaXMuc2NyaXB0KSkoKTsvL1RPRE8gaGFjayEhIVxufTtcblxucC5lZGl0U2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZGlhbG9nU2NyaXB0RWRpdG9yLnNob3coe1xuXG4gICAgICAgIHNjcmlwdDogdGhpcy5zY3JpcHQsXG4gICAgICAgIG9uQ2hhbmdlU2NyaXB0OiBmdW5jdGlvbiAoc2NyaXB0KSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cblxuXG5cblxucC5fb25DaGFuZ2VEZVRpbWUgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgdGhpcy50aW1lID0gZS5kZXRhaWwudGltZTtcblxuICAgIHRoaXMuZW1pdCgnY2hhbmdlVGltZScpO1xufTtcblxucC5fb25TZWxlY3REcm9wZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgXG4gICAgdmFyIHNlbGVjdGlvbiA9IGUuZGV0YWlsLnNlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24gPT09ICdkZWxldGUnKSB7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdkZWxldGUnLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZWN0aW9uID09PSAnZWRpdCBzY3JpcHQnKSB7XG5cbiAgICAgICAgdGhpcy5lZGl0U2NyaXB0KCk7XG4gICAgfVxufTtcblxucC5fb25DaGFuZ2VUYXBlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLnNldFRpbWVzY2FsZShhbS50aW1lbGluZS50aW1lc2NhbGUpO1xufTtcblxucC5fb25EYmxjbGlja0tleSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZWRpdFNjcmlwdCgpO1xufTtcblxuXG5cblxucC5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZURlVGltZSk7XG4gICAgdGhpcy5fZGVNZW51LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdCcsIHRoaXMuX29uU2VsZWN0RHJvcGRvd24pO1xuICAgIGFtLnRpbWVsaW5lLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2VUYXBlJywgdGhpcy5fb25DaGFuZ2VUYXBlKTtcblxuICAgIHRoaXMuZG9tRWxlbS5yZW1vdmUoKTtcbiAgICBpZiAodGhpcy5fZGVNZW51LnBhcmVudE5vZGUpIHRoaXMuX2RlTWVudS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2RlTWVudSk7IFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb21lbnRTY3JpcHQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIGFtZ3VpID0gcmVxdWlyZSgnLi4vLi4vYW1ndWknKTtcblxuZnVuY3Rpb24gRGlhbG9nU2NyaXB0RWRpdG9yICgpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fbmFtZSA9ICcnO1xuICAgIHRoaXMuX3NlbGVjdG9ycyA9IFtdO1xuXG4gICAgdGhpcy5fb25DbGlja09rID0gdGhpcy5fb25DbGlja09rLmJpbmQodGhpcyk7IFxuICAgIHRoaXMuX29uQ2hhbmdlU2NyaXB0ID0gdGhpcy5fb25DaGFuZ2VTY3JpcHQuYmluZCh0aGlzKTtcbn1cblxuaW5oZXJpdHMoRGlhbG9nU2NyaXB0RWRpdG9yLCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBEaWFsb2dTY3JpcHRFZGl0b3IucHJvdG90eXBlO1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXG4gICAgc2NyaXB0OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgdiA9IHYgfHwgJyc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zY3JpcHQgPT09IHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NjcmlwdCA9IHY7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jbSAmJiB0aGlzLl9jbS5nZXRWYWx1ZSgpICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5fY20uc2V0VmFsdWUodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZVNjcmlwdCcsIHYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5wLnNob3cgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICB0aGlzLl9jcmVhdGVEaWFsb2coKTtcblxuICAgIGlmICgnc2NyaXB0JyBpbiBvcHQpIHRoaXMuc2NyaXB0ID0gb3B0LnNjcmlwdDtcblxuICAgIHRoaXMuZG9tRWxlbS5zaG93TW9kYWwoKTtcblxuICAgIGlmICh0aGlzLl9jbSkge1xuICAgICAgICB0aGlzLl9jbS5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgaWYgKCdvbkNoYW5nZVNjcmlwdCcgaW4gb3B0KSB0aGlzLm9uKCdjaGFuZ2VTY3JpcHQnLCBvcHQub25DaGFuZ2VTY3JpcHQpO1xufTtcblxucC5oaWRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtLmNsb3NlKCk7XG5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2hhbmdlU2NyaXB0Jyk7XG59O1xuXG5wLl9jcmVhdGVEaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNEaWFsb2dDcmVhdGVkKSByZXR1cm47XG4gICAgdGhpcy5faXNEaWFsb2dDcmVhdGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnQoKTtcbiAgICBcbiAgICB0aGlzLmRvbUVsZW0gPSBhbWd1aS5jcmVhdGVEaWFsb2coe1xuICAgICAgICB0aXRsZTogJ1NjcmlwdCcsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuX2RlQ29udGVudCxcbiAgICAgICAgcGFyZW50OiBhbS5kZURpYWxvZ0NvbnQsXG4gICAgICAgIGJ1dHRvbnM6IFsnb2snXSxcbiAgICB9KTtcblxuICAgIHRoaXMuZG9tRWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGlja19vaycsIHRoaXMuX29uQ2xpY2tPayk7XG59O1xuXG5wLl9vbkNsaWNrT2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmhpZGUoKTtcbn07XG5cbnAuX29uQ2hhbmdlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5zY3JpcHQgPSB0aGlzLl9jbS5nZXRWYWx1ZSgpO1xufTtcblxuXG5wLl9jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fZGVDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVDb250ZW50LnN0eWxlLndpZHRoID0gJzQ4MHB4JztcbiAgICB0aGlzLl9kZUNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gJzMzMHB4JztcbiAgICB0aGlzLl9kZUNvbnRlbnQuc3R5bGUucGFkZGluZyA9ICczMHB4IDEycHgnO1xuXG4gICAgdGhpcy5fdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHRoaXMuX2RlQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl90ZXh0YXJlYSk7XG5cbiAgICBhbWd1aS5jYWxsT25BZGRlZCh0aGlzLl90ZXh0YXJlYSwgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuX2NtID0gbmV3IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRoaXMuX3RleHRhcmVhLCB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiAncGFzdGVsLW9uLWRhcmsnLFxuICAgICAgICAgICAgbW9kZTogJ2phdmFzY3JpcHQnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fY20uc2V0VmFsdWUodGhpcy5zY3JpcHQpO1xuICAgICAgICB0aGlzLl9jbS5vbignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VTY3JpcHQpO1xuICAgIH0sIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlhbG9nU2NyaXB0RWRpdG9yKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIGFtZ3VpID0gcmVxdWlyZSgnLi4vLi4vYW1ndWknKTtcblxuZnVuY3Rpb24gRGlhbG9nU2VxdU9wdGlvbnMgKCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9uYW1lID0gJyc7XG4gICAgdGhpcy5fc2VsZWN0b3JzID0gW107XG5cbiAgICB0aGlzLl9vbkNsaWNrT2sgPSB0aGlzLl9vbkNsaWNrT2suYmluZCh0aGlzKTsgXG4gICAgdGhpcy5fb25DaGFuZ2VOYW1lID0gdGhpcy5fb25DaGFuZ2VOYW1lLmJpbmQodGhpcyk7XG59XG5cbmluaGVyaXRzKERpYWxvZ1NlcXVPcHRpb25zLCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBEaWFsb2dTZXF1T3B0aW9ucy5wcm90b3R5cGU7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cbiAgICBuYW1lOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX25hbWUgPT09IHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2O1xuICAgICAgICAgICAgdGhpcy5faW5wTmFtZS52YWx1ZSA9IHY7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZU5hbWUnLCB2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxucC5zaG93ID0gZnVuY3Rpb24gKG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdGhpcy5fY3JlYXRlRGlhbG9nKCk7XG5cbiAgICBpZiAoJ25hbWUnIGluIG9wdCkgdGhpcy5uYW1lID0gb3B0Lm5hbWU7XG5cbiAgICBpZiAoJ29uQ2hhbmdlTmFtZScgaW4gb3B0KSB0aGlzLm9uKCdjaGFuZ2VOYW1lJywgb3B0Lm9uQ2hhbmdlTmFtZSk7XG5cbiAgICB0aGlzLmRvbUVsZW0uc2hvd01vZGFsKCk7XG59O1xuXG5wLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRvbUVsZW0uY2xvc2UoKTtcblxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjaGFuZ2VOYW1lJyk7XG59O1xuXG5wLl9jcmVhdGVEaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNEaWFsb2dDcmVhdGVkKSByZXR1cm47XG4gICAgdGhpcy5faXNEaWFsb2dDcmVhdGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnQoKTtcbiAgICBcbiAgICB0aGlzLmRvbUVsZW0gPSBhbWd1aS5jcmVhdGVEaWFsb2coe1xuICAgICAgICB0aXRsZTogJ1NlcXVlbmNlJyxcbiAgICAgICAgY29udGVudDogdGhpcy5fZGVDb250ZW50LFxuICAgICAgICBwYXJlbnQ6IGFtLmRlRGlhbG9nQ29udCxcbiAgICAgICAgYnV0dG9uczogWydvayddLFxuICAgIH0pO1xuXG4gICAgdGhpcy5kb21FbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrX29rJywgdGhpcy5fb25DbGlja09rKTtcbn07XG5cbnAuX29uQ2xpY2tPayA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaGlkZSgpO1xufTtcblxucC5fb25DaGFuZ2VOYW1lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5faW5wTmFtZS52YWx1ZTtcbn07XG5cblxucC5fY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2RlQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlQ29udGVudC5zdHlsZS53aWR0aCA9ICczMzBweCc7XG4gICAgdGhpcy5fZGVDb250ZW50LnN0eWxlLnBhZGRpbmcgPSAnMzBweCAxMnB4JztcblxuICAgIGFtZ3VpLmNyZWF0ZUxhYmVsKHtcbiAgICAgICAgY2FwdGlvbjogJ05hbWUnLFxuICAgICAgICBmb250U2l6ZTogJzE4cHgnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlQ29udGVudFxuICAgIH0pO1xuXG4gICAgdGhpcy5faW5wTmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5faW5wTmFtZS50eXBlID0gJ3RleHQnO1xuICAgIHRoaXMuX2lucE5hbWUudmFsdWUgPSB0aGlzLm5hbWU7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS53aWR0aCA9ICcyNDVweCc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5mb250U2l6ZSA9ICcxNHB4JztcbiAgICB0aGlzLl9pbnBOYW1lLnN0eWxlLmZvbnRGYW1pbHkgPSBhbWd1aS5GT05UX0ZBTUlMWTtcbiAgICB0aGlzLl9pbnBOYW1lLnN0eWxlLmJhY2tncm91bmQgPSAnbm9uZSc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMTJweCc7XG4gICAgdGhpcy5faW5wTmFtZS5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgdGhpcy5faW5wTmFtZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZU5hbWUpO1xuICAgIHRoaXMuX2RlQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl9pbnBOYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IERpYWxvZ1NlcXVPcHRpb25zKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBKc1NlcXVlbmNlID0gcmVxdWlyZSgnLi9Kc1NlcXVlbmNlJyk7XG5cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGFtLnJlZ2lzdGVyU2VxdWVuY2VUeXBlKEpzU2VxdWVuY2UsIEpzU2VxdWVuY2UucHJvdG90eXBlLnR5cGUpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIgZnVuY3Rpb24gKCkge1xcblxcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gMCxcXG4gICAgICAgICAgICBwcmV2VGltZSA9IDAsXFxuICAgICAgICAgICAgc3BlZWQgPSAwO1xcbiAgICAgICAgXFxuICAgICAgICB0aGlzLnN0YXJ0U3lzdGVtVGltZSA9IDA7XFxuICAgICAgICB0aGlzLm1vbWVudEZ1bmN0aW9ucyA9IFt7e3ttb21lbnRGdW5jdGlvbnN9fX1dO1xcbiAgICAgICAgdGhpcy5pbnRlcnZhbEZ1bmN0aW9ucyA9IFt7e3tpbnRlcnZhbEZ1bmN0aW9uc319fV07XFxuXFxuICAgICAgICB0aGlzLnN0ZXAgPSBmdW5jdGlvbih0aW1lKSB7XFxuXFxuICAgICAgICAgICAgdGhpcy5zdGVwUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5zdGVwKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBwcmV2VGltZSA9IGN1cnJUaW1lO1xcbiAgICAgICAgICAgIGN1cnJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XFxuXFxuICAgICAgICAgICAgdGhpcy5tb21lbnRGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZm5EYXRhKSB7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChmbkRhdGEudGltZSA+IHByZXZUaW1lICYmIGZuRGF0YS50aW1lIDw9IGN1cnJUaW1lKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICBmbkRhdGEuZm4oKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZm5EYXRhKSB7XFxuXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5EYXRhLmJvdW5kczsgaSArPSAyKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAoZm5EYXRhLmJvdW5kc1tpXSA+IHByZXZUaW1lICYmIGZuRGF0YS5ib3VuZHNbaSsxXSA8PSBjdXJyVGltZSkge1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuRGF0YS5mbigpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICB9LmJpbmQodGhpcyk7XFxuXFxuICAgICAgICB2YXIgcmV0ID0ge307XFxuXFxuICAgICAgICByZXQucGxheSA9IGZ1bmN0aW9uICgpIHtcXG5cXG4gICAgICAgICAgICB0aGlzLnN0ZXAoKTtcXG5cXG4gICAgICAgIH0uYmluZCh0aGlzKTtcXG5cXG4gICAgICAgIHJldC5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnN0ZXBSYWZJZCk7XFxuXFxuICAgICAgICB9LmJpbmQodGhpcyk7XFxuXFxuICAgICAgICByZXQuc2VlayA9IGZ1bmN0aW9uICh0aW1lKSB7XFxuXFxuICAgICAgICAgICAgY3VyclRpbWUgPSB0aW1lO1xcbiAgICAgICAgICAgIHByZXZUaW1lID0gdGltZTtcXG5cXG4gICAgICAgIH0uYmluZCh0aGlzKTtcXG5cXG4gICAgfS5jYWxsKHt9KTtcXG59O1wiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gTW91c2UoKSB7XG5cbiAgICB0aGlzLnNjcmVlblggPSAwO1xuICAgIHRoaXMuc2NyZWVuWSA9IDA7XG5cbiAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xufVxuXG5pbmhlcml0cyhNb3VzZSwgRXZlbnRFbWl0dGVyKTtcbnZhciBwID0gTW91c2UucHJvdG90eXBlO1xuXG5wLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICB0aGlzLnNjcmVlblggPSBlLnNjcmVlblg7XG4gICAgdGhpcy5zY3JlZW5ZID0gZS5zY3JlZW5ZO1xufSBcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVhBVFRSID0gWydpZCcsICdjbGFzcycsICdzdHlsZSddO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZShkZSwgcm9vdCkge1xuXG4gICAgcm9vdCA9IHJvb3QgfHwgZG9jdW1lbnQ7XG5cbiAgICB2YXIgZGVDdXJyID0gZGUsXG4gICAgICAgIHJvb3RDdXJyID0gcm9vdCwgXG4gICAgICAgIHFzQ3VyciwgcXNQYXJlbnQgPSAnJztcblxuICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcXNDdXJyID0gZ2VuKGRlQ3Vyciwgcm9vdEN1cnIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKCFxc0N1cnIgJiYgXG4gICAgICAgICAgICBkZUN1cnIucGFyZW50Tm9kZSAhPT0gcm9vdEN1cnIgJiZcbiAgICAgICAgICAgIChkZUN1cnIgPSBkZUN1cnIucGFyZW50Tm9kZSkpO1xuXG4gICAgICAgIGlmICghcXNDdXJyKSB7XG5cbiAgICAgICAgICAgIGlmIChkZUN1cnIucGFyZW50Tm9kZSA9PT0gcm9vdEN1cnIpIHtcblxuICAgICAgICAgICAgICAgIHFzQ3VyciA9ICc+ICcgKyBkZUN1cnIudGFnTmFtZSArICc6bnRoLWNoaWxkKCcgK1xuICAgICAgICAgICAgICAgICAgICAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChyb290Q3Vyci5jaGlsZE5vZGVzLCBkZUN1cnIpICsgMSkgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vY2FuJ3QgZmluZCB1bmlxdWUgcXVlcnkgc2VsZWN0b3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHFzUGFyZW50ICs9IChxc1BhcmVudCA/ICcgJyA6ICcnKSArIHFzQ3VycjtcblxuICAgICAgICBpZiAoZGVDdXJyID09PSBkZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gcXNQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxc0N1cnIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByb290Q3VyciA9IGRlQ3VycjtcbiAgICAgICAgICAgIGRlQ3VyciA9IGRlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZW4oZGUsIHJvb3QpIHtcblxuXG4gICAgdmFyIHNpbmdsZXMsIHNlbGVjdG9ycywgbWF0Y2hlcyA9IFtdO1xuXG4gICAgc2luZ2xlcyA9IHNlbGVjdG9ycyA9IFtkZS50YWdOYW1lXS5jb25jYXQoXG4gICAgICAgIHBvc3NpYmxlSWRzKGRlKSxcbiAgICAgICAgcG9zc2libGVDbGFzc2VzKGRlLCBpKSxcbiAgICAgICAgcG9zc2libGVBdHRyaWJ1dGVzKGRlLCBpKVxuICAgICk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7ICsraSkge1xuXG4gICAgICAgIHNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXG4gICAgICAgICAgICBpZiAocm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RvcnMgPSBjb21iaW5lKHNlbGVjdG9ycywgc2luZ2xlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvc3NpYmxlSWRzKGRlKSB7XG5cbiAgICByZXR1cm4gZGUuaWQgPyBbJyMnICsgQ1NTLmVzY2FwZShkZS5pZCldIDogW107XG59XG5cbmZ1bmN0aW9uIHBvc3NpYmxlQ2xhc3NlcyhkZSwgbWF4KSB7XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGUuY2xhc3NMaXN0LCAwKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnLicgKyBDU1MuZXNjYXBlKGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NzaWJsZUF0dHJpYnV0ZXMoZGUpIHtcblxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkZS5hdHRyaWJ1dGVzLCAwKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiBFWEFUVFIuaW5kZXhPZihhdHRyLm5hbWUpID09PSAtMTtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIENTUy5lc2NhcGUoYXR0ci5uYW1lKSArIChhdHRyLnZhbHVlID8gJz1cIicrYXR0ci52YWx1ZSsnXCInOiAnJykgKyAnXSc7XG4gICAgICAgIH0pO1xufVxuXG4vLyBmdW5jdGlvbiB2YXJpYXRlKF9saXN0LCBsZW5ndGgpIHtcblxuLy8gICAgIHJldHVybiBzdGVwKF9saXN0LCAyKTtcblxuLy8gICAgIGZ1bmN0aW9uIHN0ZXAobGlzdCwgYmFjaykge1xuXG4vLyAgICAgICAgIHZhciBjb21iaW5lZCA9IGNvbWJpbmUoYXR0cmlidXRlcywgbGlzdCk7XG4vLyAgICAgICAgIHJldHVybiBsaXN0LmNvbmNhdChiYWNrID09PSAwID8gY29tYmluZWQgOiBzdGVwKGNvbWJpbmVkLCAtLWJhY2spKTtcbi8vICAgICB9XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbWJpbmUoc291cmNlQSwgc291cmNlQikge1xuXG4gICAgdmFyIGNvbWJpbmVkID0gW107XG5cbiAgICBzb3VyY2VBLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgc291cmNlQi5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAoYS5pbmRleE9mKGIpID09PSAtMSAmJiBiLmluZGV4T2YoYSkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgJyMuWzonLmluZGV4T2YoYi5jaGFyQXQoMCkpICE9PSAtMSkgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tYmluZWQucHVzaChhICsgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbWJpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uL2FtZ3VpJyk7XG52YXIgZGVjb3JUaW1lYmFyTmF2aWdhdG9yID0gcmVxdWlyZSgnLi9kZWNvclRpbWViYXJOYXZpZ2F0b3InKTtcblxuZnVuY3Rpb24gVGltZWJhcihvcHQpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdGhpcy5fc3RhcnQgPSBvcHQuc3RhcnQgfHwgMDtcbiAgICB0aGlzLl93aWR0aCA9IG9wdC53aWR0aCB8fCAwO1xuICAgIHRoaXMuX2hlaWdodCA9IG9wdC5oZWlnaHQgfHwgMjE7XG4gICAgdGhpcy5fdGltZXNjYWxlID0gb3B0LnRpbWVzY2FsZSB8fCAwO1xuICAgIHRoaXMuX2N1cnJUaW1lID0gb3B0LmN1cnJUaW1lIHx8IDA7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0Lmxlbmd0aCB8fCA2MDAwMDtcblxuICAgIHRoaXMuX21hZ25ldFBvaW50cyA9IFtdO1xuXG4gICAgdGhpcy5fb25NRG93biA9IG9uTURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1Nb3ZlID0gb25NTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTVVwID0gb25NVXAuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3N0ZXBzID0gZ2V0U3RlcHMoKTtcblxuICAgIHRoaXMuX2NyZWF0ZUJhc2UoKTtcbiAgICB0aGlzLl9jcmVhdGVQb2ludGVyKCk7XG4gICAgdGhpcy5fY3JlYXRlRW5kU2hhZG93KCk7XG5cbiAgICB0aGlzLl9yZW5kZXJUYXBlKCk7XG4vL1RPRE8gdXNlIGFtZ3VpLm1ha2VEcmFnZ2FibGUoKVxuICAgIHRoaXMuX2NhbnZhc1RhcGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25NRG93bik7XG5cbiAgICBkZWNvclRpbWViYXJOYXZpZ2F0b3IodGhpcyk7XG59XG5cbmluaGVyaXRzKFRpbWViYXIsIEV2ZW50RW1pdHRlcik7XG52YXIgcCA9IFRpbWViYXIucHJvdG90eXBlO1xubW9kdWxlLmV4cG9ydHMgPSBUaW1lYmFyO1xuXG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cbiAgICAvKiogcHgvbXMgKi9cbiAgICB0aW1lc2NhbGU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2KSB8fCB0aGlzLl90aW1lc2NhbGUgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fdGltZXNjYWxlID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMC4wMDAxLCB2KSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUYXBlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZVRhcGUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZXNjYWxlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHN0YXJ0OiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgdiA9IHBhcnNlSW50KHYpO1xuXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2KSB8fCB0aGlzLl9zdGFydCA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IE1hdGgubWluKDAsIHYpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFwZSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2VUYXBlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgfSwgXG5cbiAgICB3aWR0aDoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG5cbiAgICAgICAgICAgIHYgPSBwYXJzZUludCh2KTtcblxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikgfHwgdGhpcy5fd2lkdGggPT09IHYpIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFwZSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2VUYXBlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB9XG4gICAgfSwgXG4gICAgXG4gICAgZW5kOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKHRoaXMuX3dpZHRoIC8gdGhpcy5fdGltZXNjYWxlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgdmlzaWJsZVRpbWU6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy50aW1lc2NhbGUgPSB0aGlzLl93aWR0aCAvIHY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggLyB0aGlzLl90aW1lc2NhbGU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGN1cnJUaW1lOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgdiA9IHBhcnNlSW50KHYpO1xuXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2KSB8fCB0aGlzLl9jdXJyVGltZSA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9jdXJyVGltZSA9IHY7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hQb2ludGVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlVGltZScsIHRoaXMuX2N1cnJUaW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VyclRpbWU7XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICBcbiAgICBtYWduZXRQb2ludHM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fbWFnbmV0UG9pbnRzID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFnbmV0UG9pbnRzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxlbmd0aDoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG5cbiAgICAgICAgICAgIHYgPSBwYXJzZUludCh2KTtcblxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikgfHwgdGhpcy5fbGVuZ3RoID09PSB2KSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSB2O1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUYXBlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZVRhcGUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnAuc2NyZWVuWFRvVGltZSA9IGZ1bmN0aW9uIChzY3JlZW5YKSB7XG5cbiAgICB2YXIgbGVmdCA9IHRoaXMuX2NhbnZhc1RhcGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCxcbiAgICAgICAgbW91c2VYID0gc2NyZWVuWCAtIGxlZnQsXG4gICAgICAgIHRpbWUgPSAobW91c2VYIC8gdGhpcy53aWR0aCkgKiB0aGlzLnZpc2libGVUaW1lO1xuXG4gICAgdGltZSAtPSB0aGlzLnN0YXJ0O1xuXG4gICAgcmV0dXJuIHRpbWU7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnAuX3JlbmRlclRhcGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9zdGFydCxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoLFxuICAgICAgICB2aXNpYmxlVGltZSA9IHRoaXMudmlzaWJsZVRpbWUsXG4gICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCxcbiAgICAgICAgc2NhbGUgPSB0aGlzLnRpbWVzY2FsZSwgXG4gICAgICAgIHdpZHRoID0gdGhpcy5fd2lkdGgsXG4gICAgICAgIG1heE1hcmtlcnMgPSB3aWR0aCAvIDQsXG4gICAgICAgIHN0ZXAsIGksIHRleHQsIHRleHRXLFxuICAgICAgICBjdHggPSB0aGlzLl9jdHhUYXBlO1xuXG4gICAgdGhpcy5fY2FudmFzVGFwZS53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2NhbnZhc1RhcGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuXG4gICAgICAgIGlmICgodGhpcy52aXNpYmxlVGltZSAvIHMuc21hbGwpIDwgbWF4TWFya2VycyAmJiAoIXN0ZXAgfHwgc3RlcC5zbWFsbCA+IHMuc21hbGwpKSB7XG5cbiAgICAgICAgICAgIHN0ZXAgPSBzO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoc3RlcCkge1xuXG4gICAgICAgIGN0eC5saW53ZWlkdGggPSAwLjU7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGFtZ3VpLmNvbG9yLmJnMztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGFtZ3VpLmNvbG9yLmJnMztcbiAgICAgICAgY3R4LmZvbnQgPSB+fih0aGlzLl9oZWlnaHQgKiAwLjUpICsgJ3B4IFwiT3BlbiBTYW5zXCInO1xuXG4gICAgICAgIGZvciAoaSA9IHN0YXJ0ICUgc3RlcC5zbWFsbDsgaSA8IHZpc2libGVUaW1lOyBpICs9IHN0ZXAuc21hbGwpIHtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh+fihpICogc2NhbGUpICsgMC41LCBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh+fihpICogc2NhbGUpICsgMC41LCBoZWlnaHQgKiAwLjc1KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgZm9yIChpID0gc3RhcnQgJSBzdGVwLmJpZzsgaSA8IHZpc2libGVUaW1lOyBpICs9IHN0ZXAuYmlnKSB7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ofn4oaSAqIHNjYWxlKSArIDAuNSwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ofn4oaSAqIHNjYWxlKSArIDAuNSwgaGVpZ2h0ICogMC42Mik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGZvciAoaSA9IHN0YXJ0ICUgc3RlcC50aW1lOyBpIDwgdmlzaWJsZVRpbWU7IGkgKz0gc3RlcC50aW1lKSB7XG5cbiAgICAgICAgICAgIHRleHQgPSBzdGVwLmZvcm1hdChpIC0gc3RhcnQpO1xuICAgICAgICAgICAgdGV4dFcgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGggLyAyO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIGkgKiBzY2FsZSAtIHRleHRXLCAxMik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZnJlc2hQb2ludGVyKCk7XG5cbiAgICB2YXIgZW5kV2lkdGggPSAoKHZpc2libGVUaW1lIC0gKHN0YXJ0ICsgbGVuZ3RoKSkgKiBzY2FsZSk7XG4gICAgdGhpcy5fZGVFbmRTaGFkb3cuc3R5bGUud2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih3aWR0aCwgZW5kV2lkdGgpKSArICdweCc7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gb25NRG93bihlKSB7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB0aGlzLl9kcmFnTW9kZSA9ICd0cmFuc2xhdGUnO1xuICAgIGVsc2UgaWYgKGUuY3RybEtleSkgdGhpcy5fZHJhZ01vZGUgPSAnc2NhbGUnO1xuICAgIGVsc2UgdGhpcy5fZHJhZ01vZGUgPSAnc2Vlayc7XG5cbiAgICB0aGlzLl9tZFggPSBlLnBhZ2VYO1xuICAgIHRoaXMuX21kU3RhcnQgPSB0aGlzLl9zdGFydDtcbiAgICB0aGlzLl9tZFRpbWVzY2FsZSA9IHRoaXMuX3RpbWVzY2FsZTtcblxuICAgIHRoaXMuX29uTU1vdmUoZSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25NTW92ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1VcCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbk1VcCk7XG59XG5cbmZ1bmN0aW9uIG9uTU1vdmUoZSkge1xuXG4gICAgdmFyIG1vdmUgPSBlLnNjcmVlblggLSB0aGlzLl9tZFgsXG4gICAgICAgIHRpbWUsIG1hZ25ldFBvaW50LCBtYWduZXRQb2ludERpZmY7XG5cbiAgICBpZiAodGhpcy5fZHJhZ01vZGUgPT09ICdzZWVrJykge1xuXG4gICAgICAgIHRpbWUgPSB0aGlzLnNjcmVlblhUb1RpbWUoZS5zY3JlZW5YKTtcblxuICAgICAgICB0aGlzLl9tYWduZXRQb2ludHMuZm9yRWFjaChmdW5jdGlvbiAobXApIHtcblxuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhtcCAtIHRpbWUpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZiA8IG1hZ25ldFBvaW50RGlmZiB8fCBtYWduZXRQb2ludERpZmYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hZ25ldFBvaW50ID0gbXA7XG4gICAgICAgICAgICAgICAgbWFnbmV0UG9pbnREaWZmID0gZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoKG1hZ25ldFBvaW50RGlmZiAqIHRoaXMuX3RpbWVzY2FsZSkgPCAyKSB7XG5cbiAgICAgICAgICAgIHRpbWUgPSBtYWduZXRQb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VyclRpbWUgPSB0aW1lO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnc2VlaycpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9kcmFnTW9kZSA9PT0gJ3RyYW5zbGF0ZScpIHtcblxuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5fbWRTdGFydCArIChtb3ZlIC8gdGhpcy50aW1lc2NhbGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9kcmFnTW9kZSA9PT0gJ3NjYWxlJykge1xuXG4gICAgICAgIHRoaXMudGltZXNjYWxlID0gdGhpcy5fbWRUaW1lc2NhbGUgKyAobW92ZS8xMDAwKTtcblxuICAgICAgICB2YXIgbWRQb3MgPSAodGhpcy5fbWRTdGFydCArIHRoaXMuY3VyclRpbWUpICogdGhpcy5fbWRUaW1lc2NhbGU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtKCh0aGlzLmN1cnJUaW1lICogdGhpcy50aW1lc2NhbGUpIC0gbWRQb3MpIC8gdGhpcy50aW1lc2NhbGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvbk1VcCgpIHtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1Nb3ZlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTVVwKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uTVVwKTtcbn1cblxuXG5cblxuXG5cblxuXG5cblxucC5fcmVmcmVzaFBvaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcG9zID0gKCh0aGlzLnN0YXJ0ICsgdGhpcy5jdXJyVGltZSkgLyB0aGlzLnZpc2libGVUaW1lKSAqIHRoaXMud2lkdGg7XG5cbiAgICB0aGlzLl9kZVBvaW50ZXIuc3R5bGUubGVmdCA9IHBvcyArICdweCc7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnAuX2NyZWF0ZUJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRvbUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYW1ndWkuY29sb3IuYmcwO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cbiAgICB0aGlzLl9jYW52YXNUYXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5fY3R4VGFwZSA9IHRoaXMuX2NhbnZhc1RhcGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLl9jYW52YXNUYXBlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuZG9tRWxlbS5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXNUYXBlKTsgXG59O1xuXG5wLl9jcmVhdGVQb2ludGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJhZGl1cyA9IDUuNTtcbiAgICB0aGlzLl9kZVBvaW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kZVBvaW50ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuX2RlUG9pbnRlci5zdHlsZS5ib3R0b20gPSAyKnJhZGl1cyArICdweCc7XG4gICAgdmFyIHBvaW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb2ludGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBwb2ludGVyLnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICBwb2ludGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgcG9pbnRlci5zdHlsZS5sZWZ0ID0gLXJhZGl1cyArICdweCc7XG4gICAgcG9pbnRlci5zdHlsZS53aWR0aCA9IDIqcmFkaXVzICsgJ3B4JztcbiAgICBwb2ludGVyLnN0eWxlLmhlaWdodCA9IDIqcmFkaXVzICsgJ3B4JztcbiAgICBwb2ludGVyLnN0eWxlLmJvcmRlciA9ICdzb2xpZCByZWQgMXB4JztcbiAgICBwb2ludGVyLnN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cyArICdweCc7XG4gICAgdGhpcy5fZGVQb2ludGVyLmFwcGVuZENoaWxkKHBvaW50ZXIpOyBcbiAgICB0aGlzLmRvbUVsZW0uYXBwZW5kQ2hpbGQodGhpcy5fZGVQb2ludGVyKTsgXG59O1xuXG5wLl9jcmVhdGVFbmRTaGFkb3cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9kZUVuZFNoYWRvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlRW5kU2hhZG93LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLl9kZUVuZFNoYWRvdy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICB0aGlzLl9kZUVuZFNoYWRvdy5zdHlsZS5yaWdodCA9ICcwcHgnO1xuICAgIHRoaXMuX2RlRW5kU2hhZG93LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLl9kZUVuZFNoYWRvdy5zdHlsZS53aWR0aCA9ICcwcHgnO1xuICAgIHRoaXMuX2RlRW5kU2hhZG93LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgdGhpcy5fZGVFbmRTaGFkb3cuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoODMsODMsODMsMC43MyknO1xuICAgIHRoaXMuZG9tRWxlbS5hcHBlbmRDaGlsZCh0aGlzLl9kZUVuZFNoYWRvdyk7IFxuXG4gICAgdmFyIGhhbmRsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBoYW5kbGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBoYW5kbGVyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGhhbmRsZXIuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIGhhbmRsZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGhhbmRsZXIuc3R5bGUud2lkdGggPSAnM3B4JztcbiAgICBoYW5kbGVyLnN0eWxlLmN1cnNvciA9ICdldy1yZXNpemUnO1xuICAgIGhhbmRsZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICB0aGlzLl9kZUVuZFNoYWRvdy5hcHBlbmRDaGlsZChoYW5kbGVyKTtcblxuICAgIGFtZ3VpLm1ha2VEcmFnZ2FibGUoe1xuICAgICAgICBkZVRhcmdldDogaGFuZGxlcixcbiAgICAgICAgdGhpc0FyZzogdGhpcyxcbiAgICAgICAgb25Eb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIChtZCwgbXgpIHtcblxuICAgICAgICAgICAgdmFyIGR4ID0gbXggLSBtZC5teDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbWQubGVuZ3RoICsgKGR4IC8gdGhpcy50aW1lc2NhbGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cblxuXG5cblxuXG5cbi8vU3RlcHNcbmZ1bmN0aW9uIGdldFN0ZXBzKCkge1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgc21hbGw6IDUsIFxuICAgICAgICAgICAgYmlnOiA1MCwgXG4gICAgICAgICAgICB0aW1lOiA1MCwgXG4gICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChtcykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBtcyArICdtcyc7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzbWFsbDogMTAsIFxuICAgICAgICAgICAgYmlnOiAxMDAsIFxuICAgICAgICAgICAgdGltZTogMTAwLCBcbiAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG1zKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zICsgJ21zJztcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNtYWxsOiAxMDAsIFxuICAgICAgICAgICAgYmlnOiAxMDAwLCBcbiAgICAgICAgICAgIHRpbWU6IDEwMDAsIFxuICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gcGFyc2VJbnQobXMvNjAwMDApO1xuICAgICAgICAgICAgICAgIHZhciBzZWMgPSBwYXJzZUludChtcy8xMDAwKSAlIDYwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChtaW4gPyBtaW4rJzonK3R3byhzZWMpIDogc2VjKSArICdzJztcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNtYWxsOiA1MDAsIFxuICAgICAgICAgICAgYmlnOiA1MDAwLCBcbiAgICAgICAgICAgIHRpbWU6IDUwMDAsIFxuICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gcGFyc2VJbnQobXMvNjAwMDApO1xuICAgICAgICAgICAgICAgIHZhciBzZWMgPSBwYXJzZUludChtcy8xMDAwKSAlIDYwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChtaW4gPyBtaW4rJzonK3R3byhzZWMpIDogc2VjKSArICdzJztcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNtYWxsOiAxMDAwMCwgXG4gICAgICAgICAgICBiaWc6IDYwMDAwLCBcbiAgICAgICAgICAgIHRpbWU6IDYwMDAwLCBcbiAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IHBhcnNlSW50KG1zLzYwMDAwKSAlIDYwO1xuICAgICAgICAgICAgICAgIHZhciBob3VyID0gcGFyc2VJbnQobXMvMzYwMDAwMCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGhvdXIgPyBob3VyKyc6Jyt0d28obWluKSA6IG1pbikgKyAnbSc7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzbWFsbDogNjAwMDAsIFxuICAgICAgICAgICAgYmlnOiA1KjYwMDAwLCBcbiAgICAgICAgICAgIHRpbWU6IDUqNjAwMDAsIFxuICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gcGFyc2VJbnQobXMvNjAwMDApICUgNjA7XG4gICAgICAgICAgICAgICAgdmFyIGhvdXIgPSBwYXJzZUludChtcy8zNjAwMDAwKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoaG91ciA/IGhvdXIrJzonK3R3byhtaW4pIDogbWluKSArICdtJztcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gdHdvKG51bSkge1xuXG4gICAgICAgIHJldHVybiAoJzAwJyArIG51bSkuc3Vic3RyKC0yKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFRpbWViYXIgPSByZXF1aXJlKCcuL1RpbWViYXInKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uL2FtZ3VpJyk7XG52YXIgbWluZVNhdmUgPSByZXF1aXJlKCcuL21pbmVTYXZlJyk7XG52YXIgVWdsaWZ5SlMgPSByZXF1aXJlKCd1Z2xpZnktanMnKTtcbnZhciBtc3RTYXZlU2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQuc2F2ZS5tc3QnKTtcblxuZnVuY3Rpb24gVGltZWxpbmUob3B0KSB7XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMTAwKTtcblxuICAgIHRoaXMuX2hlYWRlckggPSAyMztcblxuICAgIHRoaXMuX29uU2VsZWN0U2VxdWVuY2UgPSB0aGlzLl9vblNlbGVjdFNlcXVlbmNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DaGFuZ2VTZXF1ZW5jZSA9IHRoaXMuX29uQ2hhbmdlU2VxdWVuY2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRlbGV0ZVNlcXVlbmNlID0gdGhpcy5fb25EZWxldGVTZXF1ZW5jZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW92ZVNlcXVlbmNlID0gdGhpcy5fb25Nb3ZlU2VxdWVuY2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVRpbWUgPSB0aGlzLl9vbkNoYW5nZVRpbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZVRhcGUgPSB0aGlzLl9vbkNoYW5nZVRhcGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbldpbmRvd1Jlc2l6ZSA9IHRoaXMuX29uV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TZWxlY3ROZXdTZXF1ID0gdGhpcy5fb25TZWxlY3ROZXdTZXF1LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ub2dnbGVQbGF5UGF1c2UgPSB0aGlzLl9vblRvZ2dsZVBsYXlQYXVzZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVGltZWJhclNlZWsgPSB0aGlzLl9vblRpbWViYXJTZWVrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DaGFuZ2VTZXF1ZW5jZUhlaWdodCA9IHRoaXMuX29uQ2hhbmdlU2VxdWVuY2VIZWlnaHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblN0YXJ0RWRpdEN1cnJUaW1lID0gdGhpcy5fb25TdGFydEVkaXRDdXJyVGltZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRmluaXNoRWRpdEN1cnJUaW1lID0gdGhpcy5fb25GaW5pc2hFZGl0Q3VyclRpbWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZUlucEN1cnJUaW1lID0gdGhpcy5fb25DaGFuZ2VJbnBDdXJyVGltZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2FuaW1QbGF5ID0gdGhpcy5fYW5pbVBsYXkuYmluZCh0aGlzKTtcbiAgICBcbiAgICB0aGlzLl90aW1lYmFyID0gbmV3IFRpbWViYXIoe1xuICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlYWRlckgsXG4gICAgICAgIHRpbWVzY2FsZTogMC4xMixcbiAgICAgICAgbGVuZ3RoOiA2MDAwXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5fY3JlYXRlQmFzZSgpO1xuICAgIHRoaXMuX2NyZWF0ZVBvaW50ZXJMaW5lKCk7XG5cblxuICAgIHRoaXMuX3JlZnJlc2hUaW1lYmFyV2lkdGgoKTtcbiAgICB0aGlzLl9yZWZyZXNoRGVDdXJyVGltZSgpO1xuXG4gICAgdGhpcy5fc2VxdWVuY2VzID0gW107XG4gICAgdGhpcy5fbWFwU2VxdWVuY2VEYXRhcyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICB0aGlzLl90aW1lYmFyLm9uKCdjaGFuZ2VUaW1lJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2NoYW5nZVRpbWUnKSk7XG4gICAgdGhpcy5fdGltZWJhci5vbignY2hhbmdlVGFwZScsIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdjaGFuZ2VUYXBlJykpO1xuICAgIHRoaXMuX3RpbWViYXIub24oJ2NoYW5nZVRpbWUnLCB0aGlzLl9vbkNoYW5nZVRpbWUpO1xuICAgIHRoaXMuX3RpbWViYXIub24oJ2NoYW5nZVRhcGUnLCB0aGlzLl9vbkNoYW5nZVRhcGUpO1xuICAgIHRoaXMuX3RpbWViYXIub24oJ3NlZWsnLCB0aGlzLl9vblRpbWViYXJTZWVrKTtcblxuICAgIGFtZ3VpLmNhbGxPbkFkZGVkKHRoaXMuZG9tRWxlbSwgdGhpcy5fcmVmcmVzaFRpbWViYXJXaWR0aCwgdGhpcyk7XG4gICAgXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplKTtcblxuICAgIGlmIChvcHQpIHtcbiAgICAgICAgdGhpcy51c2VTYXZlKG9wdCk7XG4gICAgfVxufVxuXG5pbmhlcml0cyhUaW1lbGluZSwgRXZlbnRFbWl0dGVyKTtcbnZhciBwID0gVGltZWxpbmUucHJvdG90eXBlO1xubW9kdWxlLmV4cG9ydHMgPSBUaW1lbGluZTtcblxuXG5cblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblxuICAgICdjdXJyVGltZSc6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWJhci5fY3VyclRpbWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICd0aW1lc2NhbGUnOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWViYXIudGltZXNjYWxlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAnc2VxdWVuY2VzJzoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXF1ZW5jZXM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICdsZW5ndGgnOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWViYXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnAuZ2V0U2F2ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzYXZlID0ge1xuICAgICAgICB0aW1lYmFyOiB7XG4gICAgICAgICAgICBjdXJyVGltZTogdGhpcy5fdGltZWJhci5jdXJyVGltZSxcbiAgICAgICAgICAgIHRpbWVzY2FsZTogdGhpcy5fdGltZWJhci50aW1lc2NhbGUsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMuX3RpbWViYXIubGVuZ3RoLFxuICAgICAgICB9LFxuICAgICAgICBzZXF1ZW5jZXM6IFtdXG4gICAgfTtcblxuICAgIHRoaXMuX3NlcXVlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXF1KSB7XG5cbiAgICAgICAgc2F2ZS5zZXF1ZW5jZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBzZXF1LnR5cGUsXG4gICAgICAgICAgICBkYXRhOiBzZXF1LmdldFNhdmUoKVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHNhdmUpKTtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzYXZlKTtcbn07XG5cbnAudXNlU2F2ZSA9IGZ1bmN0aW9uIChzYXZlKSB7XG5cbiAgICBzYXZlID0gbWluZVNhdmUoc2F2ZSk7XG5cbiAgICBpZiAoIXNhdmUpIHtcbiAgICAgICAgYWxlcnQoJ0NhblxcJ3QgdXNlIHRoaXMgc2F2ZScpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHNhdmUgPSBfLmV4dGVuZCh7XG4gICAgICAgIHRpbWViYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZXM6IFtdXG4gICAgfSwgc2F2ZSk7XG5cbiAgICB0aGlzLl90aW1lYmFyLmN1cnJUaW1lID0gc2F2ZS50aW1lYmFyLmN1cnJUaW1lO1xuICAgIHRoaXMuX3RpbWViYXIudGltZXNjYWxlID0gc2F2ZS50aW1lYmFyLnRpbWVzY2FsZTtcbiAgICB0aGlzLl90aW1lYmFyLmxlbmd0aCA9IHNhdmUudGltZWJhci5sZW5ndGg7XG5cbiAgICBzYXZlLnNlcXVlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXF1RGF0YSkge1xuXG4gICAgICAgIHZhciBTZXF1Q2xhc3MgPSBhbS5zZXF1ZW5jZVR5cGVzW3NlcXVEYXRhLnR5cGVdLFxuICAgICAgICAgICAgc2VxdSA9IG5ldyBTZXF1Q2xhc3Moc2VxdURhdGEuZGF0YSk7XG5cbiAgICAgICAgdGhpcy5hZGRTZXF1ZW5jZShzZXF1KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIF8uaW52b2tlKHRoaXMuX3NlcXVlbmNlcywgJ3JlbmRlclRpbWUnLCB0aGlzLmN1cnJUaW1lKTtcblxuICAgIGFtLmhpc3RvcnkuY2xlYXIoKTtcbn07XG5cbnAuZ2V0U2NyaXB0ID0gZnVuY3Rpb24gKG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdmFyIHNjcmlwdCwgcGxheWVyU2NyaXB0cyA9IFtdO1xuXG4gICAgdGhpcy5fc2VxdWVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHNlcXUpIHtcblxuICAgICAgICBwbGF5ZXJTY3JpcHRzLnB1c2goc2VxdS5nZXRTY3JpcHQoKSk7XG4gICAgfSk7XG5cbiAgICBzY3JpcHQgPSBNdXN0YWNoZS5yZW5kZXIobXN0U2F2ZVNjcmlwdCwge1xuICAgICAgICBuYW1lOiAnYW1zYXZlJyxcbiAgICAgICAgc2F2ZUpzb246IG9wdC5pbmNsdWRlU2F2ZSAmJiB0aGlzLmdldFNhdmUoKSxcbiAgICAgICAgc2VxdVBsYXllckdlbnM6IHBsYXllclNjcmlwdHMuam9pbignLFxcbicpLFxuICAgICAgICBhdXRvUGxheTogb3B0LmF1dG9QbGF5XG4gICAgfSk7XG5cbiAgICBpZiAob3B0Lm1pbmlmeSkge1xuXG4gICAgY29uc29sZS5sb2coc2NyaXB0KTtcbiAgICAgICAgc2NyaXB0ID0gbWluaWZ5KHNjcmlwdCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coc2NyaXB0KTtcblxuICAgIHJldHVybiBzY3JpcHQ7XG5cbiAgICBmdW5jdGlvbiBtaW5pZnkoY29kZSkge1xuXG4gICAgICAgIHJldHVybiBjb2RlOy8vVE9ET1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBVZ2xpZnlKUy5taW5pZnkoY29kZSwge1xuICAgICAgICAgICAgZnJvbVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgIG1hbmdsZTogZmFsc2UsXG4gICAgICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICBjb21tZW50czogL0BhbXNhdmUvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXByZXNzOiB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXJ2ZWQ6ICdKU09OX1NBVkUnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgdmFyIHRvcGxldmVsID0gbnVsbDtcbiAgICAgICAgdG9wbGV2ZWwgPSBVZ2xpZnlKUy5wYXJzZShjb2RlLCB7XG4gICAgICAgICAgICBmaWxlbmFtZTogJ3NhdmUnLFxuICAgICAgICAgICAgdG9wbGV2ZWw6IHRvcGxldmVsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRvcGxldmVsLmZpZ3VyZV9vdXRfc2NvcGUoKTtcblxuICAgICAgICB2YXIgY29tcHJlc3NvciA9IFVnbGlmeUpTLkNvbXByZXNzb3Ioe21hbmdsZTogZmFsc2V9KTtcbiAgICAgICAgdmFyIGNvbXByZXNzZWRfYXN0ID0gdG9wbGV2ZWwudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuXG4gICAgICAgIGNvbXByZXNzZWRfYXN0LmZpZ3VyZV9vdXRfc2NvcGUoKTtcbiAgICAgICAgY29tcHJlc3NlZF9hc3QuY29tcHV0ZV9jaGFyX2ZyZXF1ZW5jeSgpO1xuICAgICAgICBjb21wcmVzc2VkX2FzdC5tYW5nbGVfbmFtZXMoKTtcblxuICAgICAgICByZXR1cm4gY29tcHJlc3NlZF9hc3QucHJpbnRfdG9fc3RyaW5nKHtjb21tZW50czogJ2FsbCd9KTtcbiAgICB9IFxufTtcblxucC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBcbiAgICB3aGlsZSh0aGlzLl9zZXF1ZW5jZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVTZXF1ZW5jZSh0aGlzLl9zZXF1ZW5jZXNbMF0pO1xuICAgIH1cbn07XG5cbnAuYWRkU2VxdWVuY2UgPSBmdW5jdGlvbiAoc2VxdSwgc2tpcEhpc3RvcnkpIHtcblxuICAgIGlmICghc2tpcEhpc3RvcnkpIHtcbiAgICAgICAgYW0uaGlzdG9yeS5zYXZlKFt0aGlzLnJlbW92ZVNlcXVlbmNlLCB0aGlzLCBzZXF1LCB0cnVlXSxcbiAgICAgICAgICAgIFt0aGlzLmFkZFNlcXVlbmNlLCB0aGlzLCBzZXF1LCB0cnVlXSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX3NlcXVlbmNlcy5wdXNoKHNlcXUpO1xuXG4gICAgdGhpcy5fbWFwU2VxdWVuY2VEYXRhcy5zZXQoc2VxdSwge1xuICAgICAgICBkZUNvbnRPcHQ6IGNyZWF0ZUNvbnQoc2VxdS5kZU9wdGlvbnMsIHRoaXMuX2RlT3B0aW9uc0NvbnQpLFxuICAgICAgICBkZUNvbnRLZjogY3JlYXRlQ29udChzZXF1LmRlS2V5cywgdGhpcy5fZGVLZXlsaW5lQ29udCksXG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbkNoYW5nZVNlcXVlbmNlSGVpZ2h0KHNlcXUpO1xuXG4gICAgc2VxdS5vbignc2VsZWN0JywgdGhpcy5fb25TZWxlY3RTZXF1ZW5jZSk7XG4gICAgc2VxdS5vbignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VTZXF1ZW5jZSk7XG4gICAgc2VxdS5vbignZGVsZXRlJywgdGhpcy5fb25EZWxldGVTZXF1ZW5jZSk7XG4gICAgc2VxdS5vbignbW92ZScsIHRoaXMuX29uTW92ZVNlcXVlbmNlKTtcbiAgICBzZXF1Lm9uKCdjaGFuZ2VIZWlnaHQnLCB0aGlzLl9vbkNoYW5nZVNlcXVlbmNlSGVpZ2h0KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnQoY29udGVudCwgcGFyZW50KSB7XG5cbiAgICAgICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBkZS5zdHlsZS5oZWlnaHQgPSBzZXF1LmhlaWdodCArICdweCc7XG4gICAgICAgIGRlLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIGRlLnN0eWxlLnRyYW5zZm9ybSA9ICdoZWlnaHQgMC4xMiBlYXNlT3V0JztcbiAgICAgICAgZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkZSk7XG5cbiAgICAgICAgcmV0dXJuIGRlO1xuICAgIH1cbn07XG5cbnAucmVtb3ZlU2VxdWVuY2UgPSBmdW5jdGlvbiAoc2VxdSwgc2tpcEhpc3RvcnkpIHtcblxuICAgIGlmICghc2tpcEhpc3RvcnkpIHtcbiAgICAgICAgYW0uaGlzdG9yeS5zYXZlKFt0aGlzLmFkZFNlcXVlbmNlLCB0aGlzLCBzZXF1LCB0cnVlXSxcbiAgICAgICAgICAgIFt0aGlzLnJlbW92ZVNlcXVlbmNlLCB0aGlzLCBzZXF1LCB0cnVlXSk7XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IHRoaXMuX3NlcXVlbmNlcy5pbmRleE9mKHNlcXUpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NlcXVlbmNlcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIHZhciBzZXF1RGF0YSA9IHRoaXMuX21hcFNlcXVlbmNlRGF0YXMuZ2V0KHNlcXUpO1xuICAgICQoc2VxdURhdGEuZGVDb250T3B0KS5yZW1vdmUoKTtcbiAgICAkKHNlcXVEYXRhLmRlQ29udEtmKS5yZW1vdmUoKTtcbiAgICB0aGlzLl9tYXBTZXF1ZW5jZURhdGFzLmRlbGV0ZShzZXF1KTtcblxuICAgIHNlcXUucmVtb3ZlTGlzdGVuZXIoJ3NlbGVjdCcsIHRoaXMuX29uU2VsZWN0U2VxdWVuY2UpO1xuICAgIHNlcXUucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlU2VxdWVuY2UpO1xuICAgIHNlcXUucmVtb3ZlTGlzdGVuZXIoJ2RlbGV0ZScsIHRoaXMuX29uRGVsZXRlU2VxdWVuY2UpO1xuICAgIHNlcXUucmVtb3ZlTGlzdGVuZXIoJ21vdmUnLCB0aGlzLl9vbk1vdmVTZXF1ZW5jZSk7XG4gICAgc2VxdS5yZW1vdmVMaXN0ZW5lcignY2hhbmdlSGVpZ2h0JywgdGhpcy5fb25DaGFuZ2VTZXF1ZW5jZUhlaWdodCk7XG5cbiAgICBzZXF1LmRpc3Bvc2UoKTtcbn07XG5cbnAubW92ZVNlcXVlbmNlID0gZnVuY3Rpb24gKHNlcXUsIHdheSkge1xuXG4gICAgdmFyIGlkeCA9IHRoaXMuX3NlcXVlbmNlcy5pbmRleE9mKHNlcXUpO1xuXG4gICAgdGhpcy5fc2VxdWVuY2VzLnNwbGljZShpZHgsIDEpO1xuICAgIGlkeCA9IE1hdGgubWluKHRoaXMuX3NlcXVlbmNlcy5sZW5ndGgsIE1hdGgubWF4KDAsIGlkeCArIHdheSkpO1xuICAgIHRoaXMuX3NlcXVlbmNlcy5zcGxpY2UoaWR4LCAwLCBzZXF1KTtcblxuICAgIHRoaXMuX3JlZnJlc2hTZXF1ZW5jZU9yZGVyaW5nKCk7XG59O1xuXG5wLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNQbGF5aW5nKSByZXR1cm47XG4gICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX2J0blRvZ2dsZVBsYXkuc2V0VG9nZ2xlKHRydWUpO1xuXG4gICAgXy5pbnZva2UodGhpcy5fc2VxdWVuY2VzLCAncGxheScsIHRoaXMuY3VyclRpbWUpO1xuXG4gICAgdGhpcy5fcGxheVN0YXJ0VGltZVN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5fcGxheVN0YXJ0Q3VyclRpbWUgPSB0aGlzLmN1cnJUaW1lO1xuICAgIHRoaXMuX2FuaW1QbGF5KCk7XG59O1xuXG5wLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHJldHVybjtcbiAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J0blRvZ2dsZVBsYXkuc2V0VG9nZ2xlKGZhbHNlKTtcblxuICAgIF8uaW52b2tlKHRoaXMuX3NlcXVlbmNlcywgJ3BhdXNlJyk7XG5cbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbVBsYXlSYWZpZCk7XG59O1xuXG5wLnNjcmVlblhUb1RpbWUgPSBmdW5jdGlvbiAoc2NyZWVuWCkge1xuXG4gICAgcmV0dXJuIHRoaXMuX3RpbWViYXIuc2NyZWVuWFRvVGltZShzY3JlZW5YKTtcbn1cblxuXG5cblxuXG5cblxuXG5wLl9hbmltUGxheSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2FuaW1QbGF5UmFmaWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1QbGF5KTtcblxuICAgIHZhciB0ID0gTWF0aC5yb3VuZChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX3BsYXlTdGFydFRpbWVTdGFtcCk7XG4gICAgdGhpcy5fdGltZWJhci5jdXJyVGltZSA9ICh0aGlzLl9wbGF5U3RhcnRDdXJyVGltZSArIHQpICUgdGhpcy5fdGltZWJhci5sZW5ndGg7XG59O1xuXG5wLl9vblRpbWViYXJTZWVrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5wYXVzZSgpO1xufTtcblxucC5fb25TZWxlY3RTZXF1ZW5jZSA9IGZ1bmN0aW9uKHNlcXUpIHtcblxuICAgIGlmICh0aGlzLl9jdXJyU2VxdWVuY2UgPT09IHNlcXUpIFxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAodGhpcy5fY3VyclNlcXVlbmNlKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9jdXJyU2VxdWVuY2UuZGVzZWxlY3QoKTsgXG4gICAgfVxuXG4gICAgdGhpcy5fY3VyclNlcXVlbmNlID0gc2VxdTtcbn07XG5cbnAuX29uQ2hhbmdlU2VxdWVuY2UgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX3JlZnJlc2hNYWduZXRQb2ludHMoKTtcbn07XG5cbnAuX29uRGVsZXRlU2VxdWVuY2UgPSBmdW5jdGlvbiAoc2VxdSkge1xuXG4gICAgdGhpcy5yZW1vdmVTZXF1ZW5jZShzZXF1KTtcbn07XG5cbnAuX29uTW92ZVNlcXVlbmNlID0gZnVuY3Rpb24gKHNlcXUsIHdheSkge1xuXG4gICAgdGhpcy5tb3ZlU2VxdWVuY2Uoc2VxdSwgd2F5KTtcbn07XG5cbnAuX29uQ2hhbmdlVGltZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX3JlZnJlc2hEZVBvaW50ZXIoKTtcblxuICAgIHRoaXMuX3JlZnJlc2hEZUN1cnJUaW1lKCk7XG59O1xuXG5wLl9vbkNoYW5nZVRhcGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbGVmdCA9ICh0aGlzLl90aW1lYmFyLnN0YXJ0ICogdGhpcy50aW1lc2NhbGUpO1xuXG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udC5zdHlsZS53aWR0aCA9ICdjYWxjKDEwMCUgKyAnICsgKC1sZWZ0KSArICdweCknO1xuXG4gICAgdGhpcy5fcmVmcmVzaERlUG9pbnRlcigpO1xufTtcblxucC5fb25DaGFuZ2VTZXF1ZW5jZUhlaWdodCA9IGZ1bmN0aW9uIChzZXF1KSB7XG5cbiAgICB2YXIgaCA9IHNlcXUuaGVpZ2h0LFxuICAgICAgICBzZXF1RGF0YSA9IHRoaXMuX21hcFNlcXVlbmNlRGF0YXMuZ2V0KHNlcXUpO1xuXG4gICAgc2VxdURhdGEuZGVDb250T3B0LnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICAgIHNlcXVEYXRhLmRlQ29udEtmLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xufTtcblxucC5fb25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9yZWZyZXNoVGltZWJhcldpZHRoKCk7XG59O1xuXG5wLl9vblRvZ2dsZVBsYXlQYXVzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLl9pc1BsYXlpbmcpIHtcblxuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG59O1xuXG5wLl9vblNlbGVjdE5ld1NlcXUgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgdmFyIGFkZFNlcXUgPSBmdW5jdGlvbiAodHlwZSkge1xuXG4gICAgICAgIHZhciBTZXF1Q2xhc3MgPSBhbS5zZXF1ZW5jZVR5cGVzW3R5cGVdO1xuXG4gICAgICAgIHRoaXMuYWRkU2VxdWVuY2UobmV3IFNlcXVDbGFzcygpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBzd2l0Y2ggKGUuZGV0YWlsLnNlbGVjdGlvbikge1xuXG4gICAgICAgIGNhc2UgJ2Nzcyc6XG4gICAgICAgICAgICBhZGRTZXF1KCdjc3Nfc2VxdV90eXBlJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdqcyc6XG4gICAgICAgICAgICBhZGRTZXF1KCdqc19zZXF1X3R5cGUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhbS5kaWFsb2dzLmZlYXR1cmVEb2VzbnRFeGlzdC5zaG93KCk7XG4gICAgICAgICAgICBcbiAgICB9XG59O1xuXG5wLl9vblN0YXJ0RWRpdEN1cnJUaW1lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5faW5wQ3VyclRpbWUudmFsdWUgPSB0aGlzLmN1cnJUaW1lO1xuXG4gICAgdGhpcy5fZGVDdXJyVGltZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuX2lucEN1cnJUaW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGhpcy5faW5wQ3VyclRpbWUuZm9jdXMoKTtcbn07XG5cbnAuX29uRmluaXNoRWRpdEN1cnJUaW1lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5faW5wQ3VyclRpbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLl9kZUN1cnJUaW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xufTtcblxucC5fb25DaGFuZ2VJbnBDdXJyVGltZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX3RpbWViYXIuY3VyclRpbWUgPSB0aGlzLl9pbnBDdXJyVGltZS52YWx1ZTtcbn07XG5cblxuXG5cblxuXG5cblxucC5fcmVmcmVzaFNlcXVlbmNlT3JkZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9zZXF1ZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VxdSkge1xuXG4gICAgICAgIHZhciBzZXF1RGF0YSA9IHRoaXMuX21hcFNlcXVlbmNlRGF0YXMuZ2V0KHNlcXUpO1xuXG4gICAgICAgIHRoaXMuX2RlT3B0aW9uc0NvbnQuYXBwZW5kQ2hpbGQoc2VxdURhdGEuZGVDb250T3B0KTtcbiAgICAgICAgdGhpcy5fZGVLZXlsaW5lQ29udC5hcHBlbmRDaGlsZChzZXF1RGF0YS5kZUNvbnRLZik7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5wLl9yZWZyZXNoTWFnbmV0UG9pbnRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1hZ25ldFBvaW50cyA9IFtdO1xuXG4gICAgdGhpcy5fc2VxdWVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHNlcXUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHNlcXUuZ2V0TWFnbmV0UG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgIG1hZ25ldFBvaW50cyA9IG1hZ25ldFBvaW50cy5jb25jYXQoc2VxdS5nZXRNYWduZXRQb2ludHMoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1hZ25ldFBvaW50cyA9IF8udW5pcShtYWduZXRQb2ludHMpO1xuXG4gICAgdGhpcy5fdGltZWJhci5tYWduZXRQb2ludHMgPSBtYWduZXRQb2ludHM7XG59O1xuXG5wLl9yZWZyZXNoVGltZWJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fdGltZWJhci53aWR0aCA9IHRoaXMuX2RlUmlnaHQub2Zmc2V0V2lkdGg7XG59O1xuXG5wLl9yZWZyZXNoRGVQb2ludGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxlZnQgPSAodGhpcy5fdGltZWJhci5zdGFydCArIHRoaXMuY3VyclRpbWUpICogdGhpcy50aW1lc2NhbGU7XG4gICAgdGhpcy5fZGVQb2ludGVyTGluZS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG59O1xuXG5wLl9yZWZyZXNoRGVDdXJyVGltZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aW1lID0gdGhpcy5jdXJyVGltZSwgXG4gICAgICAgIG1pbiwgc2VjLCBtcywgc3RyICA9ICcnO1xuXG4gICAgbWluID0gfn4odGltZSAvIDYwMDAwKTtcbiAgICB0aW1lICU9IDYwMDAwO1xuICAgIHNlYyA9IH5+KHRpbWUgLyAxMDAwKTtcbiAgICB0aW1lICU9IDEwMDA7XG4gICAgbXMgPSB+fnRpbWU7XG5cbiAgICBpZiAobWluKSB7XG4gICAgICAgIHN0ciArPSBtaW4gKyAnOic7XG4gICAgICAgIHNlYyA9ICgnMDAnICsgc2VjKS5zdWJzdHIoLTIpO1xuICAgIH1cbiAgICBpZiAoc2VjKSB7XG4gICAgICAgIHN0ciArPSBzZWMgKyAnOic7XG4gICAgICAgIG1zID0gKCcwMDAnICsgbXMpLnN1YnN0cigtMyk7XG4gICAgfVxuICAgIHN0ciArPSBtcztcbiAgICB0aGlzLl9kZUN1cnJUaW1lLnRleHRDb250ZW50ID0gc3RyO1xufTtcblxuXG5cblxuXG5cblxucC5fY3JlYXRlQmFzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZG9tRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBhbWd1aS5jb2xvci5iZzA7IFxuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyBcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJzsgXG5cbiAgICB0aGlzLl9kZUxlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kZUxlZnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYW1ndWkuY29sb3IuYmcwO1xuICAgIHRoaXMuX2RlTGVmdC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIHRoaXMuX2RlTGVmdC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gJ2NvbHVtbic7XG4gICAgdGhpcy5fZGVMZWZ0LnN0eWxlLndpZHRoID0gJzMwMHB4JztcbiAgICB0aGlzLl9kZUxlZnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMuZG9tRWxlbS5hcHBlbmRDaGlsZCh0aGlzLl9kZUxlZnQpO1xuXG4gICAgdGhpcy5fY3JlYXRlU2V0dGluZ3NIZWFkKCk7XG5cbiAgICB0aGlzLl9kZURpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kZURpdmlkZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYW1ndWkuY29sb3IuYmczO1xuICAgIHRoaXMuX2RlRGl2aWRlci5zdHlsZS53aWR0aCA9ICcxcHgnO1xuICAgIHRoaXMuX2RlRGl2aWRlci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5kb21FbGVtLmFwcGVuZENoaWxkKHRoaXMuX2RlRGl2aWRlcik7XG5cbiAgICB0aGlzLl9kZVJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVSaWdodC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIHRoaXMuX2RlUmlnaHQuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdjb2x1bW4nO1xuICAgIHRoaXMuX2RlUmlnaHQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuX2RlUmlnaHQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYW1ndWkuY29sb3IuYmcwO1xuICAgIHRoaXMuX2RlUmlnaHQuc3R5bGUuZmxleCA9ICcxJztcbiAgICB0aGlzLl9kZVJpZ2h0LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLmRvbUVsZW0uYXBwZW5kQ2hpbGQodGhpcy5fZGVSaWdodCk7XG5cbiAgICB0aGlzLl90aW1lYmFyLmRvbUVsZW0uc3R5bGUuaGVpZ2h0ID0gJzIzcHgnO1xuICAgIHRoaXMuX2RlUmlnaHQuYXBwZW5kQ2hpbGQodGhpcy5fdGltZWJhci5kb21FbGVtKTtcblxuICAgIHRoaXMuX2RlS2V5bGluZUNvbnQzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udDMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuX2RlS2V5bGluZUNvbnQzLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udDMuc3R5bGUuZmxleCA9ICcxJztcbiAgICB0aGlzLl9kZUtleWxpbmVDb250My5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udDMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udDMuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB0aGlzLl9kZVJpZ2h0LmFwcGVuZENoaWxkKHRoaXMuX2RlS2V5bGluZUNvbnQzKTtcblxuICAgIHRoaXMuX2RlT3B0aW9uc0NvbnQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVPcHRpb25zQ29udDIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuX2RlT3B0aW9uc0NvbnQyLnN0eWxlLmZsZXggPSAnMSc7XG4gICAgdGhpcy5fZGVPcHRpb25zQ29udDIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5fZGVPcHRpb25zQ29udDIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMuX2RlT3B0aW9uc0NvbnQyLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgdGhpcy5fZGVMZWZ0LmFwcGVuZENoaWxkKHRoaXMuX2RlT3B0aW9uc0NvbnQyKTtcblxuICAgIHRoaXMuX2RlS2V5bGluZUNvbnQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udDIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuX2RlS2V5bGluZUNvbnQyLnN0eWxlLmZsZXggPSAnMSc7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udDMuYXBwZW5kQ2hpbGQodGhpcy5fZGVLZXlsaW5lQ29udDIpO1xuXG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlS2V5bGluZUNvbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMuX2RlS2V5bGluZUNvbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5fZGVLZXlsaW5lQ29udDIuYXBwZW5kQ2hpbGQodGhpcy5fZGVLZXlsaW5lQ29udCk7XG5cbiAgICB0aGlzLl9kZU9wdGlvbnNDb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVPcHRpb25zQ29udC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgdGhpcy5fZGVPcHRpb25zQ29udDIuYXBwZW5kQ2hpbGQodGhpcy5fZGVPcHRpb25zQ29udCk7XG5cbiAgICB0aGlzLl9kZVJhbmdlID0gYW1ndWkuY3JlYXRlUmFuZ2Uoe1xuICAgICAgICB3aWR0aDogJzZweCcsXG4gICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlS2V5bGluZUNvbnQzLFxuICAgICAgICB2ZXJ0aWNhbDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgYW1ndWkubWFrZVNjcm9sbGFibGUoe1xuICAgICAgICBkZUNvbnQ6IFt0aGlzLl9kZU9wdGlvbnNDb250MiwgdGhpcy5fZGVLZXlsaW5lQ29udDNdLFxuICAgICAgICBkZVRhcmdldDogW3RoaXMuX2RlT3B0aW9uc0NvbnQsIHRoaXMuX2RlS2V5bGluZUNvbnRdLFxuICAgICAgICBkZVJhbmdlOiB0aGlzLl9kZVJhbmdlXG4gICAgfSk7XG5cbiAgICB0aGlzLl9jcmVhdGVEaXZpZGVySGFuZGxlcigpO1xufTtcblxuXG5wLl9jcmVhdGVTZXR0aW5nc0hlYWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9kZVNldHRpbmdzSGVhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlU2V0dGluZ3NIZWFkLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdkYXJrZ3JlZXknO1xuICAgIHRoaXMuX2RlU2V0dGluZ3NIZWFkLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgdGhpcy5fZGVTZXR0aW5nc0hlYWQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5fZGVTZXR0aW5nc0hlYWQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5faGVhZGVySCArICdweCc7XG4gICAgdGhpcy5fZGVMZWZ0LmFwcGVuZENoaWxkKHRoaXMuX2RlU2V0dGluZ3NIZWFkKTtcblxuICAgIHRoaXMuX2J0bk5ld1NlcXUgPSBhbWd1aS5jcmVhdGVJY29uQnRuKHtcbiAgICAgICAgdG9vbHRpcDogJ2FkZCBuZXcgc2VxdWVuY2UnLFxuICAgICAgICBpY29uOiAncGx1cy1zcXVhcmVkJyxcbiAgICAgICAgcGFyZW50OiB0aGlzLl9kZVNldHRpbmdzSGVhZCxcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgfSk7XG5cbiAgICBhbWd1aS5iaW5kRHJvcGRvd24oe1xuICAgICAgICBkZVRhcmdldDogdGhpcy5fYnRuTmV3U2VxdSxcbiAgICAgICAgZGVNZW51OiBhbWd1aS5jcmVhdGVEcm9wZG93bih7XG4gICAgICAgICAgICBvcHRpb25zOiBbJ2NzcycsICdqcycsICdhdHRyaWJ1dGUnLCAnbWVkaWEnLCAndGltZWxpbmUnLCAndGhyZWUuanMnLCAncGl4aS5qcyddLFxuICAgICAgICAgICAgb25TZWxlY3Q6IHRoaXMuX29uU2VsZWN0TmV3U2VxdVxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgXG4gICAgdGhpcy5fYnRuVG9nZ2xlUGxheSA9IGFtZ3VpLmNyZWF0ZVRvZ2dsZUljb25CdG4oe1xuICAgICAgICB0b29sdGlwOiAncGxheS9wYXVzZSBwcmV2aWV3JyxcbiAgICAgICAgaWNvbk9uOiAncGF1c2UnLCBcbiAgICAgICAgaWNvbk9mZjogJ3BsYXknLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlU2V0dGluZ3NIZWFkLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgb25DbGljazogdGhpcy5fb25Ub2dnbGVQbGF5UGF1c2VcbiAgICB9KTtcblxuICAgIHRoaXMuX2RlQ3VyclRpbWUgPSBhbWd1aS5jcmVhdGVMYWJlbCh7XG4gICAgICAgIGNhcHRpb246ICcnLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuX2RlU2V0dGluZ3NIZWFkXG4gICAgfSk7XG4gICAgdGhpcy5fZGVDdXJyVGltZS5zdHlsZS5mbGV4ID0gJzEnO1xuICAgIHRoaXMuX2RlQ3VyclRpbWUuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB0aGlzLl9kZUN1cnJUaW1lLnN0eWxlLmZvbnRTaXplID0gJzEycHgnO1xuICAgIHRoaXMuX2RlQ3VyclRpbWUuc3R5bGUubWFyZ2luUmlnaHQgPSAnMnB4JztcbiAgICB0aGlzLl9kZUN1cnJUaW1lLnN0eWxlLmNvbG9yID0gYW1ndWkuY29sb3IuYmczO1xuICAgIHRoaXMuX2RlQ3VyclRpbWUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vblN0YXJ0RWRpdEN1cnJUaW1lKTtcblxuICAgIHRoaXMuX2lucEN1cnJUaW1lID0gYW1ndWkuY3JlYXRlSW5wdXQoe1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcGFyZW50OiB0aGlzLl9kZVNldHRpbmdzSGVhZFxuICAgIH0pO1xuICAgIHRoaXMuX2lucEN1cnJUaW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5faW5wQ3VyclRpbWUuc3R5bGUuZmxleCA9ICcxJztcbiAgICB0aGlzLl9pbnBDdXJyVGltZS5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIHRoaXMuX2lucEN1cnJUaW1lLnN0eWxlLmZvbnRTaXplID0gJzEycHgnO1xuICAgIHRoaXMuX2lucEN1cnJUaW1lLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzJweCc7XG4gICAgdGhpcy5faW5wQ3VyclRpbWUuc3R5bGUuY29sb3IgPSBhbWd1aS5jb2xvci5iZzM7XG4gICAgdGhpcy5faW5wQ3VyclRpbWUuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uRmluaXNoRWRpdEN1cnJUaW1lKTtcbiAgICB0aGlzLl9pbnBDdXJyVGltZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZUlucEN1cnJUaW1lKTtcbn07XG5cbnAuX2NyZWF0ZURpdmlkZXJIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fZGVEaXZpZGVySGFuZGxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlRGl2aWRlckhhbmRsZXIuc3R5bGUudG9wID0gdGhpcy5faGVhZGVySCArICdweCc7XG4gICAgdGhpcy5fZGVEaXZpZGVySGFuZGxlci5zdHlsZS5sZWZ0ID0gdGhpcy5fZGVMZWZ0LnN0eWxlLndpZHRoO1xuICAgIHRoaXMuX2RlRGl2aWRlckhhbmRsZXIuc3R5bGUud2lkdGggPSAnMXB4JztcbiAgICB0aGlzLl9kZURpdmlkZXJIYW5kbGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLl9kZURpdmlkZXJIYW5kbGVyLnN0eWxlLmhlaWdodCA9ICdjYWxjKDEwMCUgLSAnICsgdGhpcy5faGVhZGVySCArICdweCknO1xuICAgIHRoaXMuX2RlRGl2aWRlckhhbmRsZXIuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlWCgzKSc7XG4gICAgdGhpcy5fZGVEaXZpZGVySGFuZGxlci5zdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJztcbiAgICB0aGlzLmRvbUVsZW0uYXBwZW5kQ2hpbGQodGhpcy5fZGVEaXZpZGVySGFuZGxlcik7XG5cbiAgICBhbWd1aS5tYWtlRHJhZ2dhYmxlKHtcblxuICAgICAgICBkZVRhcmdldDogdGhpcy5fZGVEaXZpZGVySGFuZGxlcixcbiAgICAgICAgdGhpc0FyZzogdGhpcyxcbiAgICAgICAgXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKG1kLCBteCkge1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IG14IC0gdGhpcy5kb21FbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyAncHgnO1xuXG4gICAgICAgICAgICB0aGlzLl9kZUxlZnQuc3R5bGUud2lkdGggPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5fZGVEaXZpZGVySGFuZGxlci5zdHlsZS5sZWZ0ID0gbGVmdDtcblxuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFRpbWViYXJXaWR0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5wLl9jcmVhdGVQb2ludGVyTGluZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2RlUG9pbnRlckxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kZVBvaW50ZXJMaW5lLnN0eWxlLnRvcCA9IHRoaXMuX2hlYWRlckggKyAncHgnO1xuICAgIHRoaXMuX2RlUG9pbnRlckxpbmUuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICB0aGlzLl9kZVBvaW50ZXJMaW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLl9kZVBvaW50ZXJMaW5lLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgdGhpcy5fZGVQb2ludGVyTGluZS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5fZGVQb2ludGVyTGluZS5zdHlsZS5ib3JkZXJMZWZ0ID0gJzFweCBzb2xpZCByZWQnO1xuICAgIHRoaXMuX2RlUmlnaHQuYXBwZW5kQ2hpbGQodGhpcy5fZGVQb2ludGVyTGluZSk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFtZ3VpID0gcmVxdWlyZSgnLi4vYW1ndWknKTtcblxuXG5mdW5jdGlvbiBkZWNvclRpbWViYXJOYXZpZ2F0b3IgKHRpbWViYXIpIHtcblxuICAgIHZhciBkZU5hdiwgZGVMZWZ0SGFuZCwgZGVSaWdodEhhbmQsIGRyYWdNb2RlO1xuICAgIFxuICAgIGNyZWF0ZUJhc2UoKTtcbiAgICB0aW1lYmFyLmRvbUVsZW0uYXBwZW5kQ2hpbGQoZGVOYXYpO1xuXG4gICAgYW1ndWkubWFrZURyYWdnYWJsZSh7XG4gICAgICAgIGRlVGFyZ2V0OiBkZU5hdixcbiAgICAgICAgb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGRlTGVmdEhhbmQpIGRyYWdNb2RlID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIGVsc2UgaWYgKGUudGFyZ2V0ID09PSBkZVJpZ2h0SGFuZCkgZHJhZ01vZGUgPSAnZW5kJztcbiAgICAgICAgICAgIGVsc2UgZHJhZ01vZGUgPSAnbW92ZSc7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRpbWViYXIuc3RhcnQsXG4gICAgICAgICAgICAgICAgdmlzaWJsZVRpbWU6IHRpbWViYXIudmlzaWJsZVRpbWUsXG4gICAgICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lYmFyLnRpbWVzY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKG1kLCBteCkge1xuXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aW1lYmFyLndpZHRoIC8gdGltZWJhci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbW92ZSA9IChteCAtIG1kLm14KSAvIHNjYWxlLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWQuc3RhcnQgLSBtb3ZlO1xuXG4gICAgICAgICAgICBpZiAoZHJhZ01vZGUgPT09ICdtb3ZlJykge1xuXG4gICAgICAgICAgICAgICAgdGltZWJhci5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZHJhZ01vZGUgPT09ICdzdGFydCcpIHtcblxuICAgICAgICAgICAgICAgIHRpbWViYXIuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICB0aW1lYmFyLnZpc2libGVUaW1lID0gbWQudmlzaWJsZVRpbWUgLSBtb3ZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZHJhZ01vZGUgPT09ICdlbmQnKSB7XG5cbiAgICAgICAgICAgICAgICB0aW1lYmFyLnZpc2libGVUaW1lID0gbWQudmlzaWJsZVRpbWUgKyBtb3ZlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1kUG9zID0gKG1kLnN0YXJ0ICsgdGltZWJhci5jdXJyVGltZSkgKiBtZC50aW1lc2NhbGU7XG4gICAgICAgICAgICAgICAgdGltZWJhci5zdGFydCA9IC0oKHRpbWViYXIuY3VyclRpbWUgKiB0aW1lYmFyLnRpbWVzY2FsZSkgLSBtZFBvcykgLyB0aW1lYmFyLnRpbWVzY2FsZTtcbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgfSxcbiAgICAgICAgb25VcDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkcmFnTW9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9uTUxlYXZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVOYXYuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlWSgxKSc7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTGVhdmU6IG9uTUxlYXZlXG4gICAgfSk7XG5cbiAgICB0aW1lYmFyLm9uKCdjaGFuZ2VUYXBlJywgb25DaGFuZ2VUYXBlKTtcblxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2VUYXBlKCkge1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRpbWViYXIud2lkdGggLyB0aW1lYmFyLmxlbmd0aDtcblxuICAgICAgICBkZU5hdi5zdHlsZS5sZWZ0ID0gKC10aW1lYmFyLnN0YXJ0ICogc2NhbGUpICsgJ3B4JztcbiAgICAgICAgZGVOYXYuc3R5bGUud2lkdGggPSAodGltZWJhci52aXNpYmxlVGltZSAqIHNjYWxlKSArICdweCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25NTGVhdmUoKSB7XG5cbiAgICAgICAgaWYgKCFkcmFnTW9kZSkge1xuICAgICAgICAgICAgZGVOYXYuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlWSgwLjQpJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2UgKCkge1xuXG4gICAgICAgIGRlTmF2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlTmF2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZGVOYXYuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIGRlTmF2LnN0eWxlLmhlaWdodCA9ICc3cHgnO1xuICAgICAgICBkZU5hdi5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gICAgICAgIGRlTmF2LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICdjZW50ZXIgdG9wJztcbiAgICAgICAgZGVOYXYuc3R5bGUuYmFja2dyb3VuZCA9IGFtZ3VpLmNvbG9yLmJnMjtcblxuICAgICAgICBkZVJpZ2h0SGFuZCA9IGNyZWF0ZUhhbmRsZXIoJ3JpZ2h0Jyk7XG4gICAgICAgIGRlTGVmdEhhbmQgPSBjcmVhdGVIYW5kbGVyKCdsZWZ0Jyk7XG4gICAgICAgIG9uTUxlYXZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGFuZGxlcihzaWRlKSB7XG5cbiAgICAgICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZGUuc3R5bGVbc2lkZV0gPSAnMHB4JztcbiAgICAgICAgZGUuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIGRlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgZGUuc3R5bGUud2lkdGggPSAnOCUnO1xuICAgICAgICBkZS5zdHlsZS5taW5XaWR0aCA9ICcxcHgnO1xuICAgICAgICBkZS5zdHlsZS5tYXhXaWR0aCA9ICc3cHgnO1xuICAgICAgICBkZS5zdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJztcbiAgICAgICAgZGVOYXYuYXBwZW5kQ2hpbGQoZGUpO1xuXG4gICAgICAgIHJldHVybiBkZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb3JUaW1lYmFyTmF2aWdhdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbmU7XG5cbmZ1bmN0aW9uIG1pbmUoc3RyKSB7XG5cbiAgICBpZiAodHlwZW9mKHN0cikgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgcnggPSAvXFwvXFwqXFwqW1xcc1xcU10uKkBhbXNhdmVbXFxzXFxTXS4qXFwqXFwvW1xcc1xcU10uKnZhclxccy4qU0FWRUpTT05cXHMuKj0oW1xcc1xcU10uKikvLFxuICAgICAgICBtID0gcnguZXhlYyhzdHIpLFxuICAgICAgICBqc29uO1xuXG4gICAgaWYgKG0gJiYgbVsxXSkge1xuXG4gICAgICAgIGpzb24gPSBleHRyYWN0SlNPTihtWzFdKVswXTtcblxuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA1NzQ1NDYvMzYxNTI4OFxuZnVuY3Rpb24gZXh0cmFjdEpTT04oc3RyKSB7XG4gICAgdmFyIGZpcnN0T3BlbiwgZmlyc3RDbG9zZSwgY2FuZGlkYXRlO1xuICAgIGZpcnN0T3BlbiA9IHN0ci5pbmRleE9mKCd7JywgZmlyc3RPcGVuICsgMSk7XG4gICAgZG8ge1xuICAgICAgICBmaXJzdENsb3NlID0gc3RyLmxhc3RJbmRleE9mKCd9Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdmaXJzdE9wZW46ICcgKyBmaXJzdE9wZW4sICdmaXJzdENsb3NlOiAnICsgZmlyc3RDbG9zZSk7XG4gICAgICAgIGlmKGZpcnN0Q2xvc2UgPD0gZmlyc3RPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBzdHIuc3Vic3RyaW5nKGZpcnN0T3BlbiwgZmlyc3RDbG9zZSArIDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NhbmRpZGF0ZTogJyArIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBKU09OLnBhcnNlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy4uLmZvdW5kJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXMsIGZpcnN0T3BlbiwgZmlyc3RDbG9zZSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcuLi5mYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0Q2xvc2UgPSBzdHIuc3Vic3RyKDAsIGZpcnN0Q2xvc2UpLmxhc3RJbmRleE9mKCd9Jyk7XG4gICAgICAgIH0gd2hpbGUoZmlyc3RDbG9zZSA+IGZpcnN0T3Blbik7XG4gICAgICAgIGZpcnN0T3BlbiA9IHN0ci5pbmRleE9mKCd7JywgZmlyc3RPcGVuICsgMSk7XG4gICAgfSB3aGlsZShmaXJzdE9wZW4gIT09IC0xKTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IFwiOyhmdW5jdGlvbiAocm9vdCkge1xcbiAgICAndXNlIHN0cmljdCc7XFxuXFxuICAgIHt7I3NhdmVKc29ufX1cXG4gICAgLyoqQGFtc2F2ZSovXFxuICAgIHZhciBTQVZFSlNPTiA9ICd7e3tzYXZlSnNvbn19fSc7XFxuICAgIHt7L3NhdmVKc29ufX1cXG5cXG4gICAgdmFyIHNlcXVQbGF5ZXJHZW5zID0gW3t7e3NlcXVQbGF5ZXJHZW5zfX19XTtcXG5cXG4gICAgcm9vdC5hbSA9IHJvb3QuYW0gfHwge307XFxuICAgIHJvb3QuYW0ucGFnZVNjcmlwdHMgPSByb290LmFtLnBhZ2VTY3JpcHRzIHx8IHt9O1xcblxcbiAgICB2YXIgcmVnID0gcm9vdC5hbS5wYWdlU2NyaXB0cy57e25hbWV9fSA9IHtcXG4gICAgICAgIFxcbiAgICAgICAgY3JlYXRlUGxheWVyOiBmdW5jdGlvbiAob3B0KSB7XFxuXFxuICAgICAgICAgICAgdmFyIHNlcXVlbmNlUGxheWVycyA9IFtdO1xcblxcbiAgICAgICAgICAgIHNlcXVQbGF5ZXJHZW5zLmZvckVhY2goZnVuY3Rpb24gKGNyZWF0ZSkge1xcblxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZVBsYXllcnMucHVzaChjcmVhdGUob3B0KSkgICA7XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgcGxheTogY2FsbFBsYXllcnMuYmluZChudWxsLCAncGxheScpLFxcbiAgICAgICAgICAgICAgICBwYXVzZTogY2FsbFBsYXllcnMuYmluZChudWxsLCAncGF1c2UnKSxcXG4gICAgICAgICAgICAgICAgc2VlazogY2FsbFBsYXllcnMuYmluZChudWxsLCAnc2VlaycpLFxcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgZnVuY3Rpb24gY2FsbFBsYXllcnMoZm5OYW1lLCBhcmcxKSB7XFxuXFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZXF1ZW5jZVBsYXllcikge1xcblxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VQbGF5ZXJbZm5OYW1lXS5jYWxsKG51bGwsIGFyZzEpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxuICAgICAgICB7eyNzYXZlSnNvbn19XFxuICAgICAgICBzYXZlSnNvbjogU0FWRUpTT04sXFxuICAgICAgICB7ey9zYXZlSnNvbn19XFxuICAgIH07XFxuXFxuXFxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG4gICAgICAgIFxcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gcmVnO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgXFxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlZztcXG4gICAgfVxcblxcblxcbiAgICB7eyNhdXRvUGxheX19XFxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09ICdpbnRlcmFjdGl2ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XFxuXFxuICAgICAgICByZWcuY3JlYXRlUGxheWVyKCkucGxheSgpO1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcXG5cXG4gICAgICAgICAgICByZWcuY3JlYXRlUGxheWVyKCkucGxheSgpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAge3svYXV0b1BsYXl9fVxcbn0odGhpcykpO1wiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uL2FtZ3VpJyk7XG5cbmZ1bmN0aW9uIFRvb2xiYXIoKSB7XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2hlaWdodCA9IDMyO1xuICAgIHRoaXMuX2ljb25zID0gW107XG4gICAgdGhpcy5fc2VwYXJhdG9ycyA9IHt9O1xuXG4gICAgdGhpcy5kb21FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2RhcmtzbGF0ZWdyZXknO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5oZWlnaHQgPSB0aGlzLl9oZWlnaHQgKyAncHgnO1xuXG4gICAgdGhpcy5hZGRTZXBhcmF0b3IoJ2ZpcnN0Jyk7XG4gICAgdGhpcy5hZGRTZXBhcmF0b3IoJ3Rvb2xzJyk7XG4gICAgdGhpcy5hZGRTZXBhcmF0b3IoJ2hhbmRsZXInKTtcbiAgICB0aGlzLmFkZFNlcGFyYXRvcignZ2xvYmFsJyk7XG4gICAgdGhpcy5hZGRTZXBhcmF0b3IoJ3Jlc3QnKTtcbn1cblxuaW5oZXJpdHMoVG9vbGJhciwgRXZlbnRFbWl0dGVyKTtcbnZhciBwID0gVG9vbGJhci5wcm90b3R5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IFRvb2xiYXI7XG5cblxucC5hZGRJY29uID0gZnVuY3Rpb24gKG9wdCkge1xuXG4gICAgdmFyIGRlSWNvbiA9IG9wdC5kZUljb24gfHwgYW1ndWkuY3JlYXRlSWNvbkJ0bih7XG4gICAgICAgIHdpZHRoOiAzMixcbiAgICAgICAgaGVpZ2h0OiAzMixcbiAgICAgICAgZm9udFNpemU6ICczMnB4JyxcbiAgICAgICAgaWNvbjogb3B0Lmljb24sXG4gICAgICAgIG9uQ2xpY2s6IG9wdC5vbkNsaWNrXG4gICAgfSk7XG5cbiAgICBpZiAob3B0LnRvb2x0aXApIHtcbiAgICAgICAgXG4gICAgICAgIGFtZ3VpLmFkZFRvb2x0aXAoe1xuICAgICAgICAgICAgZGVUYXJnZXQ6IGRlSWNvbixcbiAgICAgICAgICAgIHRleHQ6IG9wdC50b29sdGlwLFxuICAgICAgICAgICAgc2lkZTogJ2JvdHRvbSdcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVJY29uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcblxuICAgIHRoaXMuZG9tRWxlbS5pbnNlcnRCZWZvcmUoZGVJY29uLCB0aGlzLl9zZXBhcmF0b3JzW29wdC5zZXBhcmF0b3IgfHwgJ3Jlc3QnXSk7XG5cbiAgICByZXR1cm4gZGVJY29uO1xufTtcblxucC5yZW1vdmVJY29uID0gZnVuY3Rpb24gKGRlSWNvbikge1xuXG4gICAgZGVJY29uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGVJY29uKTtcbn07XG5cbnAuYWRkU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB0aGlzLmRvbUVsZW0uYXBwZW5kQ2hpbGQoZGUpO1xuICAgIHRoaXMuX3NlcGFyYXRvcnNbbmFtZV0gPSBkZTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL2hhbmRzL1RyYW5zZm9ybWVyJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gVHJhbnNoYW5kKCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmhhbmRzID0ge307XG5cbiAgICBbVHJhbnNmb3JtZXJdLmZvckVhY2goZnVuY3Rpb24gKEhhbmQpIHtcblxuICAgICAgICB2YXIgaGFuZCA9IG5ldyBIYW5kKCk7XG5cbiAgICAgICAgaGFuZC5vbignY2hhbmdlJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2NoYW5nZScpKTtcblxuICAgICAgICB0aGlzLmhhbmRzW0hhbmQuaWRdID0gaGFuZDtcbiAgICB9LCB0aGlzKTtcbn1cblxuaW5oZXJpdHMoVHJhbnNoYW5kLCBFdmVudEVtaXR0ZXIpO1xuXG52YXIgcCA9IFRyYW5zaGFuZC5wcm90b3R5cGU7XG5cbnAuc2V0dXAgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICB2YXIgaGFuZCA9IHRoaXMuaGFuZHNbb3B0LmhhbmQudHlwZV07XG5cbiAgICBpZiAoaGFuZCkge1xuXG4gICAgICAgIGhhbmQuc2V0dXAob3B0LmhhbmQpO1xuICAgICAgICB0aGlzLmRvbUVsZW0gPSBoYW5kLmRvbUVsZW07XG4gICAgICAgIHRoaXMuX2N1cnJIYW5kID0gaGFuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93ICdVbmtub3duIGhhbmQgdHlwZTogJyArIG9wdC5oYW5kLnR5cGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihvcHQub24pID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdC5vbikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG5cbiAgICAgICAgICAgIHRoaXMub24oZXZlbnRUeXBlLCBvcHQub25bZXZlbnRUeXBlXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbnAuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5fY3VyckhhbmQpIHtcblxuICAgICAgICB0aGlzLl9jdXJySGFuZC5hY3RpdmF0ZSgpO1xuICAgIH1cbn07XG5cbnAuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLl9jdXJySGFuZCkge1xuXG4gICAgICAgIHRoaXMuX2N1cnJIYW5kLmRlYWN0aXZhdGUoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaGFuZDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIE1PVVNFU1RBVEVTID0ge1xuICAgICdtb3ZlJzogJ21vdmUnLFxuICAgICdyb3RhdGUnOiAnLXdlYmtpdC1ncmFiJyxcbiAgICAnb3JpZ2luJzogJ2Nyb3NzaGFpcicsXG4gICAgJzEwMDAnOiAnbnMtcmVzaXplJyxcbiAgICAnMTEwMCc6ICduZXN3LXJlc2l6ZScsXG4gICAgJzAxMDAnOiAnZXctcmVzaXplJyxcbiAgICAnMDExMCc6ICdud3NlLXJlc2l6ZScsXG4gICAgJzAwMTAnOiAnbnMtcmVzaXplJyxcbiAgICAnMDAxMSc6ICduZXN3LXJlc2l6ZScsXG4gICAgJzAwMDEnOiAnZXctcmVzaXplJyxcbiAgICAnMTAwMSc6ICdud3NlLXJlc2l6ZScsXG59O1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybWVyKCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9wYXJhbXMgPSB7XG4gICAgICAgIHR4OiAwLCB0eTogMCxcbiAgICAgICAgc3g6IDEsIHN5OiAxLFxuICAgICAgICByejogMCxcbiAgICAgICAgb3g6IDAuNSwgb3k6IDAuNVxuICAgIH07XG4gICAgdGhpcy5fYmFzZSA9IHt4OiAwLCB5OiAwLCB3OiAwLCBoOiAwfTtcbiAgICB0aGlzLl9wb2ludHMgPSBbe30sIHt9LCB7fSwge31dO1xuICAgIHRoaXMuX3BPcmlnaW4gPSB7fTtcbiAgICB0aGlzLl9vcmlnaW5SYWRpdXMgPSA2O1xuXG4gICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3VzZVVwID0gdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbn1cblxuVHJhbnNmb3JtZXIuaWQgPSAndHJhbnNmb3JtZXInO1xuXG5pbmhlcml0cyhUcmFuc2Zvcm1lciwgRXZlbnRFbWl0dGVyKTtcblxudmFyIHAgPSBUcmFuc2Zvcm1lci5wcm90b3R5cGU7XG5cbnAuc2V0dXAgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICBpZiAoIXRoaXMuZG9tRWxlbSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUdyYXBoaWNzKCk7XG4gICAgfVxuXG4gICAgXy5leHRlbmQodGhpcy5fcGFyYW1zLCBvcHQucGFyYW1zKTtcbiAgICBfLmV4dGVuZCh0aGlzLl9iYXNlLCBvcHQuYmFzZSk7XG4gICAgdGhpcy5fcmVmcmVzaFBvaW50cygpO1xuICAgIHRoaXMuX3JlbmRlckhhbmRsZXIoKTtcbn07XG5cbnAuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5faXNBY3RpdmF0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9pc0FjdGl2YXRlZCA9IHRydWU7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG59O1xuXG5wLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIXRoaXMuX2lzQWN0aXZhdGVkKSByZXR1cm47XG4gICAgdGhpcy5faXNBY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICBcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG59O1xuXG5wLmNyZWF0ZUdyYXBoaWNzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAvLyB0aGlzLmRvbUVsZW0uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCByZWQnO1xufTtcblxucC5fcmVmcmVzaFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBiYXNlID0gXy5jbG9uZSh0aGlzLl9iYXNlKSwgXG4gICAgICAgIHBhcmFtcyA9IHRoaXMuX3BhcmFtcyxcbiAgICAgICAgcCA9IHRoaXMuX3BvaW50cyxcbiAgICAgICAgcG8gPSB0aGlzLl9wT3JpZ2luO1xuXG4gICAgYmFzZS54ICs9IHBhcmFtcy50eDtcbiAgICBiYXNlLnkgKz0gcGFyYW1zLnR5O1xuICAgIFxuICAgIHBvLnggPSBiYXNlLnggKyAoYmFzZS53ICogcGFyYW1zLm94KTtcbiAgICBwby55ID0gYmFzZS55ICsgKGJhc2UuaCAqIHBhcmFtcy5veSk7XG5cbiAgICB2YXIgdG94ID0gYmFzZS54ICsgcGFyYW1zLm94ICogYmFzZS53LFxuICAgICAgICB0b3kgPSBiYXNlLnkgKyBwYXJhbXMub3kgKiBiYXNlLmg7XG5cbiAgICB0KHBbMF0sIGJhc2UueCwgYmFzZS55KTtcbiAgICB0KHBbMV0sIGJhc2UueCArIGJhc2UudywgYmFzZS55KTtcbiAgICB0KHBbMl0sIGJhc2UueCArIGJhc2UudywgYmFzZS55ICsgYmFzZS5oKTtcbiAgICB0KHBbM10sIGJhc2UueCwgYmFzZS55ICsgYmFzZS5oKTtcblxuICAgIGZ1bmN0aW9uIHQocCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBkeCA9ICh4IC0gdG94KSAqIHBhcmFtcy5zeCxcbiAgICAgICAgICAgIGR5ID0gKHkgLSB0b3kpICogcGFyYW1zLnN5LFxuICAgICAgICAgICAgZCA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KSxcbiAgICAgICAgICAgIHJhZCA9IE1hdGguYXRhbjIoZHksIGR4KSArIHBhcmFtcy5yejtcblxuICAgICAgICBwLnggPSB0b3ggKyAoZCAqIE1hdGguY29zKHJhZCkpO1xuICAgICAgICBwLnkgPSB0b3kgKyAoZCAqIE1hdGguc2luKHJhZCkpO1xuICAgIH1cbn07XG5cbnAuX3JlbmRlckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcCA9IHRoaXMuX3BvaW50cyxcbiAgICAgICAgcG8gPSB0aGlzLl9wT3JpZ2luLFxuICAgICAgICBjID0gdGhpcy5kb21FbGVtLFxuICAgICAgICBvciA9IHRoaXMuX29yaWdpblJhZGl1cyxcbiAgICAgICAgY3R4ID0gYy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICBtYXJnaW4gPSA3LFxuICAgICAgICBtaW5YID0gTWF0aC5taW4ocFswXS54LCBwWzFdLngsIHBbMl0ueCwgcFszXS54LCBwby54KSxcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KHBbMF0ueCwgcFsxXS54LCBwWzJdLngsIHBbM10ueCwgcG8ueCksXG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihwWzBdLnksIHBbMV0ueSwgcFsyXS55LCBwWzNdLnksIHBvLnkpLFxuICAgICAgICBtYXhZID0gTWF0aC5tYXgocFswXS55LCBwWzFdLnksIHBbMl0ueSwgcFszXS55LCBwby55KTtcblxuICAgIGMuc3R5bGUubGVmdCA9IChtaW5YIC0gbWFyZ2luKSArICdweCc7XG4gICAgYy5zdHlsZS50b3AgPSAobWluWSAtIG1hcmdpbikgKyAncHgnO1xuICAgIGMud2lkdGggPSAobWF4WCAtIG1pblgpICsgKG1hcmdpbiAqIDIpO1xuICAgIGMuaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKSArIChtYXJnaW4gKiAyKTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShtYXJnaW4gLSBtaW5YLCBtYXJnaW4gLSBtaW5ZKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhwWzBdLngsIHBbMF0ueSk7XG4gICAgY3R4LmxpbmVUbyhwWzFdLngsIHBbMV0ueSk7XG4gICAgY3R4LmxpbmVUbyhwWzJdLngsIHBbMl0ueSk7XG4gICAgY3R4LmxpbmVUbyhwWzNdLngsIHBbM10ueSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4Lm1vdmVUbyhwby54IC0gb3IsIHBvLnkpO1xuICAgIGN0eC5saW5lVG8ocG8ueCArIG9yLCBwby55KTtcbiAgICBjdHgubW92ZVRvKHBvLngsIHBvLnkgLSBvcik7XG4gICAgY3R4LmxpbmVUbyhwby54LCBwby55ICsgb3IpO1xuICAgIFxuXG4gICAgLy8gY3R4LnNoYWRvd0NvbG9yID0gJyNmMDAnO1xuICAgIC8vIGN0eC5zaGFkb3dCbHVyID0gMztcbiAgICAvLyBjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgLy8gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyM0ZjInO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufTtcblxucC5fb25EcmFnID0gZnVuY3Rpb24gKGUpIHtcblxuICAgIHZhciBwYXJhbXMgPSB0aGlzLl9wYXJhbXMsXG4gICAgICAgIGJhc2UgPSB0aGlzLl9iYXNlLFxuICAgICAgICBwT3JpZ2luID0gdGhpcy5fcE9yaWdpbixcbiAgICAgICAgbWQgPSB0aGlzLl9tZFBvcyxcbiAgICAgICAgZmluZ2VyID0gdGhpcy5fZmluZ2VyLFxuICAgICAgICBwTW91c2UgPSB7eDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFl9LFxuICAgICAgICBkeCA9IHBNb3VzZS54IC0gbWQucE1vdXNlLngsXG4gICAgICAgIGR5ID0gcE1vdXNlLnkgLSBtZC5wTW91c2UueSxcbiAgICAgICAgYWx0ID0gZS5hbHRLZXksXG4gICAgICAgIHNoaWZ0ID0gZS5zaGlmdEtleSxcbiAgICAgICAgY2hhbmdlID0ge307XG5cbiAgICBpZiAoZmluZ2VyID09PSAnb3JpZ2luJykge1xuICAgICAgICBcbiAgICAgICAgc2V0T3JpZ2luKCk7XG4gICAgfVxuICAgICAgICBcbiAgICBpZiAoZmluZ2VyID09PSAnbW92ZScpIHtcblxuICAgICAgICBzZXRUcmFuc2Zvcm0oKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbmdlci5jaGFyQXQoMCkgPT09ICcxJykge1xuXG4gICAgICAgIHNldFNjYWxlKC1NYXRoLlBJLzIsICdzeScsIC0xKTtcbiAgICB9XG5cbiAgICBpZiAoZmluZ2VyLmNoYXJBdCgxKSA9PT0gJzEnKSB7XG5cbiAgICAgICAgc2V0U2NhbGUoMCwgJ3N4JywgMSk7XG4gICAgfVxuXG4gICAgaWYgKGZpbmdlci5jaGFyQXQoMikgPT09ICcxJykge1xuXG4gICAgICAgIHNldFNjYWxlKE1hdGguUEkvMiwgJ3N5JywgMSk7XG4gICAgfVxuXG4gICAgaWYgKGZpbmdlci5jaGFyQXQoMykgPT09ICcxJykge1xuXG4gICAgICAgIHNldFNjYWxlKE1hdGguUEksICdzeCcsIC0xKTtcbiAgICB9XG5cbiAgICBpZiAoZmluZ2VyID09PSAncm90YXRlJykge1xuXG4gICAgICAgIHNldFJvdGF0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHNoaWZ0ICYmICdzeCcgaW4gY2hhbmdlICYmICdzeScgaW4gY2hhbmdlKSB7XG5cbiAgICAgICAgZml4UHJvcG9ydGlvbigpO1xuICAgIH1cblxuXG4gICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCBjaGFuZ2UsICd0cmFuc2Zvcm0nKTtcblxuXG5cblxuXG4gICAgZnVuY3Rpb24gc2V0U2NhbGUociwgc04sIHdheSkge1xuXG4gICAgICAgIHZhciByYWQgPSByICsgbWQucGFyYW1zLnJ6LFxuICAgICAgICAgICAgbWREaXN0ID0gZGlzdFRvUG9pbnRJbkFuZ2xlKG1kLnBPcmlnaW4sIG1kLnBNb3VzZSwgcmFkKSxcbiAgICAgICAgICAgIGRyYWdEaXN0ID0gZGlzdFRvUG9pbnRJbkFuZ2xlKG1kLnBPcmlnaW4sIHBNb3VzZSwgcmFkKSxcbiAgICAgICAgICAgIHNjYWxlID0gKGRyYWdEaXN0IC8gbWREaXN0KSAqIG1kLnBhcmFtc1tzTl07XG5cbiAgICAgICAgaWYgKGFsdCkge1xuICAgICAgICAgICAgdmFyIGVzID0gKHNjYWxlIC0gbWQucGFyYW1zW3NOXSkgLyAyLFxuICAgICAgICAgICAgICAgIHROID0gJ3QnICsgc04uY2hhckF0KDEpLFxuICAgICAgICAgICAgICAgIGROID0gc04uY2hhckF0KDEpID09PSAneCcgPyAndycgOiAnaCc7XG5cbiAgICAgICAgICAgIHNjYWxlIC09IGVzO1xuICAgICAgICAgICAgY2hhbmdlW3ROXSA9IHBhcmFtc1t0Tl0gPSBtZC5wYXJhbXNbdE5dICsgYmFzZVtkTl0gKiBlcy8yICogd2F5OyAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlW3NOXSA9IHBhcmFtc1tzTl0gPSBzY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhQcm9wb3J0aW9uKCkge1xuXG4gICAgICAgIHZhciBteCA9IHBNb3VzZS54IC0gcE9yaWdpbi54LFxuICAgICAgICAgICAgbXkgPSBwTW91c2UueSAtIHBPcmlnaW4ueSxcbiAgICAgICAgICAgIG1yID0gTWF0aC5hYnMocmFkRGlmZihwYXJhbXMucnosIE1hdGguYXRhbjIobXksIG14KSkpLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbCA9IG1yID4gTWF0aC5QSS80ICYmIG1yIDwgTWF0aC5QSS80ICogMyxcbiAgICAgICAgICAgIHNweCA9IHBhcmFtcy5zeCAvIG1kLnBhcmFtcy5zeCxcbiAgICAgICAgICAgIHNweSA9IHBhcmFtcy5zeSAvIG1kLnBhcmFtcy5zeTtcblxuICAgICAgICBzcHggKj0gc3B4IDwgMCA/IC0xIDogMTtcbiAgICAgICAgc3B5ICo9IHNweSA8IDAgPyAtMSA6IDE7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3AgPSBpc1ZlcnRpY2FsID8gc3B5IDogc3B4O1xuXG4gICAgICAgIGNoYW5nZS5zeCA9IHBhcmFtcy5zeCA9IG1kLnBhcmFtcy5zeCAqIHNwO1xuICAgICAgICBjaGFuZ2Uuc3kgPSBwYXJhbXMuc3kgPSBtZC5wYXJhbXMuc3kgKiBzcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSb3RhdGlvbigpIHtcblxuICAgICAgICB2YXIgbWR4ID0gbWQucE1vdXNlLnggLSBwT3JpZ2luLngsXG4gICAgICAgICAgICBtZHkgPSBtZC5wTW91c2UueSAtIHBPcmlnaW4ueSxcbiAgICAgICAgICAgIG1kciA9IE1hdGguYXRhbjIobWR5LCBtZHgpLFxuICAgICAgICAgICAgbXggPSBwTW91c2UueCAtIHBPcmlnaW4ueCxcbiAgICAgICAgICAgIG15ID0gcE1vdXNlLnkgLSBwT3JpZ2luLnksXG4gICAgICAgICAgICBtciA9IE1hdGguYXRhbjIobXksIG14KSxcbiAgICAgICAgICAgIHIgPSBtciAtIG1kcjtcblxuICAgICAgICBpZiAoc2hpZnQpIHtcblxuICAgICAgICAgICAgciA9IE1hdGguZmxvb3IociAvIChNYXRoLlBJIC8gMTIpKSAqIChNYXRoLlBJIC8gMTIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlLnJ6ID0gcGFyYW1zLnJ6ID0gbWQucGFyYW1zLnJ6ICsgcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oKSB7XG5cbiAgICAgICAgaWYgKHNoaWZ0KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkpIHtcblxuICAgICAgICAgICAgICAgIGNoYW5nZS50eCA9IHBhcmFtcy50eCA9IG1kLnBhcmFtcy50eCArIGR4O1xuICAgICAgICAgICAgICAgIGNoYW5nZS50eSA9IHBhcmFtcy50eSA9IG1kLnBhcmFtcy50eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZS50eCA9IHBhcmFtcy50eCA9IG1kLnBhcmFtcy50eDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UudHkgPSBwYXJhbXMudHkgPSBtZC5wYXJhbXMudHkgKyBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZS50eCA9IHBhcmFtcy50eCA9IG1kLnBhcmFtcy50eCArIGR4O1xuICAgICAgICAgICAgY2hhbmdlLnR5ID0gcGFyYW1zLnR5ID0gbWQucGFyYW1zLnR5ICsgZHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPcmlnaW4oKSB7XG5cbiAgICAgICAgdmFyIG14ID0gcE1vdXNlLnggLSBtZC5wT3JpZ2luLngsXG4gICAgICAgICAgICBteSA9IHBNb3VzZS55IC0gbWQucE9yaWdpbi55LFxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChteCpteCArIG15Km15KSxcbiAgICAgICAgICAgIHIgPSBNYXRoLmF0YW4yKG15LCBteCkgLSBwYXJhbXMucnosXG4gICAgICAgICAgICB4ID0gKE1hdGguY29zKHIpICogZGlzdCkgLyBwYXJhbXMuc3gsXG4gICAgICAgICAgICB5ID0gKE1hdGguc2luKHIpICogZGlzdCkgLyBwYXJhbXMuc3k7XG5cbiAgICAgICAgY2hhbmdlLm94ID0gcGFyYW1zLm94ID0gbWQucGFyYW1zLm94ICsgKHggLyBiYXNlLncpO1xuICAgICAgICBjaGFuZ2Uub3kgPSBwYXJhbXMub3kgPSBtZC5wYXJhbXMub3kgKyAoeSAvIGJhc2UuaCk7XG4gICAgICAgIGNoYW5nZS50eCA9IHBhcmFtcy50eCA9IG1kLnBhcmFtcy50eCArIChteCAtIHgpO1xuICAgICAgICBjaGFuZ2UudHkgPSBwYXJhbXMudHkgPSBtZC5wYXJhbXMudHkgKyAobXkgLSB5KTtcbiAgICB9XG59O1xuXG5wLl9zZXRGaW5nZXIgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgdmFyIGJhc2UgPSB0aGlzLl9iYXNlLFxuICAgICAgICBwYXJhbXMgPSB0aGlzLl9wYXJhbXMsXG4gICAgICAgIHAgPSB0aGlzLl9wb2ludHMsXG4gICAgICAgIHBvID0gdGhpcy5fcE9yaWdpbixcbiAgICAgICAgZGlmZiA9IDMsXG4gICAgICAgIHJEaWZmID0gMTYsXG4gICAgICAgIG14ID0gZS5jbGllbnRYLFxuICAgICAgICBteSA9IGUuY2xpZW50WSxcbiAgICAgICAgbXAgPSB7eDogbXgsIHk6IG15fSxcbiAgICAgICAgZG94ID0gcG8ueCAtIG14LFxuICAgICAgICBkb3kgPSBwby55IC0gbXksXG4gICAgICAgIGRPcmlnaW4gPSBNYXRoLnNxcnQoZG94KmRveCArIGRveSpkb3kpLFxuICAgICAgICBkVG9wID0gZGlzdFRvU2VnbWVudChtcCwgcFswXSwgcFsxXSksXG4gICAgICAgIGRMZWZ0ID0gZGlzdFRvU2VnbWVudChtcCwgcFsxXSwgcFsyXSksXG4gICAgICAgIGRCb3R0b20gPSBkaXN0VG9TZWdtZW50KG1wLCBwWzJdLCBwWzNdKSxcbiAgICAgICAgZFJpZ2h0ID0gZGlzdFRvU2VnbWVudChtcCwgcFszXSwgcFswXSksXG4gICAgICAgIHRvcCA9IGRUb3AgPCBkaWZmLFxuICAgICAgICBsZWZ0ID0gZExlZnQgPCBkaWZmLFxuICAgICAgICBib3R0b20gPSBkQm90dG9tIDwgZGlmZixcbiAgICAgICAgcmlnaHQgPSBkUmlnaHQgPCBkaWZmLFxuICAgICAgICBpbnNpZGUgPSBpc0luc2lkZShtcCwgcCksXG4gICAgICAgIGN1cnNvclNjYWxlO1xuXG4gICAgaWYgKGJhc2UudyAqIHBhcmFtcy5zeCA8IGRpZmYgKiAyICYmIGluc2lkZSkge1xuICAgICAgICBcbiAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgICAgICByaWdodCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChiYXNlLmggKiBwYXJhbXMuc3kgPCBkaWZmICogMiAmJiBpbnNpZGUpIHtcbiAgICBcbiAgICAgICAgdG9wID0gZmFsc2U7XG4gICAgICAgIGJvdHRvbSA9IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZE9yaWdpbiA8IHRoaXMuX29yaWdpblJhZGl1cykge1xuXG4gICAgICAgIHRoaXMuX2ZpbmdlciA9ICdvcmlnaW4nO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b3AgfHwgcmlnaHQgfHwgYm90dG9tIHx8IGxlZnQpIHtcblxuICAgICAgICB0aGlzLl9maW5nZXIgPSAoJzAwMCcgKyAodG9wICogMTAwMCArIGxlZnQgKiAxMDAgKyBib3R0b20gKiAxMCArIHJpZ2h0ICogMSkpLnN1YnN0cigtNCk7XG4gICAgICAgIGN1cnNvclNjYWxlID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zaWRlKSB7XG5cbiAgICAgICAgdGhpcy5fZmluZ2VyID0gJ21vdmUnO1xuICAgIH1cbiAgICBlbHNlIGlmIChkVG9wIDwgckRpZmYgfHwgZFJpZ2h0IDwgckRpZmYgfHwgZEJvdHRvbSA8IHJEaWZmIHx8IGRMZWZ0IDwgckRpZmYpIHtcblxuICAgICAgICB0aGlzLl9maW5nZXIgPSAncm90YXRlJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpbmdlciA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuX2ZpbmdlciA9PT0gJ3JvdGF0ZScpIHtcblxuICAgICAgICB0aGlzLl9jdXJzb3JGdW5jID0gdGhpcy5fZ2V0Um90YXRlQ3Vyc29yO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJzb3JTY2FsZSkge1xuXG4gICAgICAgIHRoaXMuX2N1cnNvckZ1bmMgPSB0aGlzLl9nZXRTY2FsZUN1cnNvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2N1cnNvckZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5fZmluZ2VyKSB7XG5cbiAgICAgICAgICAgIC8vIHRoaXMuZG9tRWxlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKE1PVVNFU1RBVEVTW3RoaXMuX2Zpbmdlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcy5kb21FbGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLl9zZXRDdXJzb3IoJ2F1dG8nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnAuX3NldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3IpIHtcblxuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIikuc3R5bGUuY3Vyc29yID0gY3Vyc29yOy8vaGFjayEgVE9ET1xufTtcblxucC5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgaWYgKCF0aGlzLl9pc0hhbmRsZSkge1xuICAgICAgICBcbiAgICAgICAgaWYgKGFtLmlzUGlja2FibGVEb21FbGVtKGUudGFyZ2V0KSkgeyAgICAgICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLl9zZXRGaW5nZXIoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3Vyc29yRnVuYykge1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3IodGhpcy5fY3Vyc29yRnVuYyhlLmNsaWVudFgsIGUuY2xpZW50WSkpO1xuICAgIH1cbn07XG5cbnAuX29uTW91c2VEb3duID0gZnVuY3Rpb24gKGUpIHtcblxuICAgIGlmICghdGhpcy5fZmluZ2VyIHx8ICFhbS5pc1BpY2thYmxlRG9tRWxlbShlLnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdGhpcy5faXNIYW5kbGUgPSB0cnVlO1xuXG4gICAgdGhpcy5fbWRQb3MgPSB7XG4gICAgICAgIHBNb3VzZToge3g6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZfSxcbiAgICAgICAgcGFyYW1zOiBfLmNsb25lRGVlcCh0aGlzLl9wYXJhbXMpLFxuICAgICAgICBwb2ludHM6IF8uY2xvbmVEZWVwKHRoaXMuX3BvaW50cyksXG4gICAgICAgIHBPcmlnaW46IF8uY2xvbmVEZWVwKHRoaXMuX3BPcmlnaW4pXG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uRHJhZyk7XG59O1xuXG5wLl9vbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkRyYWcpO1xuICAgIFxuICAgIHRoaXMuX2lzSGFuZGxlID0gZmFsc2U7XG59O1xuXG5cblxucC5fZ2V0Um90YXRlQ3Vyc29yID0gZnVuY3Rpb24gKG14LCBteSkge1xuXG4gICAgdmFyIHIgPSBNYXRoLmF0YW4yKG15IC0gdGhpcy5fcE9yaWdpbi55LCBteCAtIHRoaXMuX3BPcmlnaW4ueCkgLyBNYXRoLlBJICogMTgwO1xuICAgIHJldHVybiAndXJsKFxcJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiID48cGF0aCB0cmFuc2Zvcm09XCJyb3RhdGUoJytyKycsIDE2LCAxNilcIiBkPVwiTTE4LjkwNyAzLjIzOGwtNy41NC0yLjEwNHM4LjM1IDMuOSA4LjQyOCAxNS4zNjdjLjA4IDExLjc5NC03LjgwNyAxNC40OS03LjgwNyAxNC40OWw3LjM2My0xLjcyNVwiIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIyLjA1NFwiIGZpbGw9XCJub25lXCIvPjwvc3ZnPlxcJykgMTYgMTYsIGF1dG8nO1xufTtcblxucC5fZ2V0U2NhbGVDdXJzb3IgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIEZJTkdFUlMgPSBbJzAxMDAnLCAnMDExMCcsICcwMDEwJywgJzAwMTEnLCAnMDAwMScsICcxMDAxJywgJzEwMDAnLCAnMTEwMCddO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgckJhc2UgPSBGSU5HRVJTLmluZGV4T2YodGhpcy5fZmluZ2VyKSAqIDQ1O1xuXG4gICAgICAgIHZhciByID0gckJhc2UgKyAodGhpcy5fcGFyYW1zLnJ6IC8gTWF0aC5QSSAqIDE4MCk7XG4gICAgICAgIHJldHVybiAndXJsKFxcJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiPjxwYXRoIHRyYW5zZm9ybT1cInJvdGF0ZSgnK3IrJywgMTYsIDE2KVwiIGQ9XCJNMjIuNDA2IDEyLjU1Mmw1Ljg4IDQuMThIMy42NzdsNS43MjggNC4zNlwiIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIyLjI1NFwiIGZpbGw9XCJub25lXCIvPjwvc3ZnPlxcJykgMTYgMTYsIGF1dG8nO1xuICAgIH07XG59KCkpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtZXI7XG5cblxuXG5cbi8vdXRpbHMvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByYWREaWZmKHIwLCByMSkge1xuXG4gICAgcjAgJT0gTWF0aC5QSTtcbiAgICByMSAlPSBNYXRoLlBJO1xuICAgIHIwICs9IE1hdGguUEk7XG4gICAgcjEgKz0gTWF0aC5QSTtcblxuICAgIHJldHVybiByMSAtIHIwO1xufVxuXG5mdW5jdGlvbiBzcXIoeCkgeyBcbiAgICByZXR1cm4geCAqIHg7XG59XG5cbmZ1bmN0aW9uIGRpc3QyKHYsIHcpIHsgXG4gICAgcmV0dXJuIHNxcih2LnggLSB3LngpICsgc3FyKHYueSAtIHcueSk7XG59XG5cbmZ1bmN0aW9uIGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIHtcbiAgdmFyIGwyID0gZGlzdDIodiwgdyk7XG4gICAgXG4gIGlmIChsMiA9PT0gMCkgcmV0dXJuIGRpc3QyKHAsIHYpO1xuICAgIFxuICB2YXIgdCA9ICgocC54IC0gdi54KSAqICh3LnggLSB2LngpICsgKHAueSAtIHYueSkgKiAody55IC0gdi55KSkgLyBsMjtcbiAgICBcbiAgaWYgKHQgPCAwKSByZXR1cm4gZGlzdDIocCwgdik7XG4gIGlmICh0ID4gMSkgcmV0dXJuIGRpc3QyKHAsIHcpO1xuICAgIFxuICByZXR1cm4gZGlzdDIocCwgeyB4OiB2LnggKyB0ICogKHcueCAtIHYueCksIHk6IHYueSArIHQgKiAody55IC0gdi55KSB9KTtcbn1cblxuZnVuY3Rpb24gZGlzdFRvU2VnbWVudChwLCB2LCB3KSB7IFxuICAgIHJldHVybiBNYXRoLnNxcnQoZGlzdFRvU2VnbWVudFNxdWFyZWQocCwgdiwgdykpO1xufVxuXG5mdW5jdGlvbiBkaXN0VG9Qb2ludEluQW5nbGUocDAsIHAxLCByYWQpIHtcblxuICAgIHZhciBkeCA9IHAxLnggLSBwMC54LFxuICAgICAgICBkeSA9IHAxLnkgLSBwMC55LFxuICAgICAgICBkID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpLFxuICAgICAgICBtUmFkID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuXG4gICAgcmFkID0gbVJhZCAtIHJhZDtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdkeCcsIGR4LCAnZHknLCBkeSwgJ2QnLCBkLCAnbVJhZCcsIG1SYWQsICdyYWQnLCByYWQsICdyZXR1cm4nLCBNYXRoLmNvcyhyYWQpICogZClcblxuICAgIHJldHVybiBNYXRoLmNvcyhyYWQpICogZDtcblxufVxuXG5mdW5jdGlvbiBpc0luc2lkZShwb2ludCwgdnMpIHtcbiAgICAvLyByYXktY2FzdGluZyBhbGdvcml0aG0gYmFzZWQgb25cbiAgICAvLyBodHRwOi8vd3d3LmVjc2UucnBpLmVkdS9Ib21lcGFnZXMvd3JmL1Jlc2VhcmNoL1Nob3J0X05vdGVzL3BucG9seS5odG1sXG4gICAgXG4gICAgdmFyIHggPSBwb2ludC54LCB5ID0gcG9pbnQueTtcbiAgICBcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB2cy5sZW5ndGggLSAxOyBpIDwgdnMubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciB4aSA9IHZzW2ldLngsIHlpID0gdnNbaV0ueTtcbiAgICAgICAgdmFyIHhqID0gdnNbal0ueCwgeWogPSB2c1tqXS55O1xuICAgICAgICBcbiAgICAgICAgdmFyIGludGVyc2VjdCA9ICgoeWkgPiB5KSAhPT0gKHlqID4geSkpICYmXG4gICAgICAgICAgICAoeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0KSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaW5zaWRlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBXZWJTdG9yYWdlbWFuID0gcmVxdWlyZSgnLi9zdG9yYWdlcy9XZWJTdG9yYWdlbWFuJyk7XG52YXIgUGFnZVNjcmlwdCA9IHJlcXVpcmUoJy4vc3RvcmFnZXMvUGFnZVNjcmlwdCcpO1xudmFyIERvd25sb2FkID0gcmVxdWlyZSgnLi9zdG9yYWdlcy9Eb3dubG9hZCcpO1xudmFyIGRlY29yRGlhbG9nID0gcmVxdWlyZSgnLi9kZWNvckRpYWxvZycpO1xuXG5mdW5jdGlvbiBXYXJlaG91c2VlbWFuKG9wdCkge1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBkZWNvckRpYWxvZyh0aGlzKTtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHRoaXMuX3N0b3JhZ2VzID0gW107XG4gICAgdGhpcy5hZGRTdG9yYWdlKG5ldyBQYWdlU2NyaXB0KCkpO1xuICAgIHRoaXMuYWRkU3RvcmFnZShuZXcgV2ViU3RvcmFnZW1hbigpKTtcbiAgICB0aGlzLmFkZFN0b3JhZ2UobmV3IERvd25sb2FkKCkpO1xuICAgIC8vIHRoaXMuYWRkU3RvcmFnZShuZXcgQ29weSgpKTtcbiAgICB0aGlzLmFkZFN0b3JhZ2Uoe2ljb246ICdoZGQnLCB0b29sdGlwOiAnbG9jYWwgZmlsZSBzeXN0ZW0nfSk7XG4gICAgdGhpcy5hZGRTdG9yYWdlKHtpY29uOiAnZ2l0JywgdG9vbHRpcDogJ0dpdCd9KTtcbiAgICB0aGlzLmFkZFN0b3JhZ2Uoe2ljb246ICdldmVybm90ZScsIHRvb2x0aXA6ICdFdmVybm90ZSd9KTtcbiAgICB0aGlzLmFkZFN0b3JhZ2Uoe2ljb246ICdkcm9wYm94JywgdG9vbHRpcDogJ0Ryb3Bib3gnfSk7XG4gICAgdGhpcy5hZGRTdG9yYWdlKHtpY29uOiAnaGlzdG9yeScsIHRvb2x0aXA6ICdhdXRvIHNhdmUnfSk7XG5cbiAgICB0aGlzLnNlbGVjdFN0b3JhZ2UodGhpcy5fc3RvcmFnZXNbMl0pO1xufVxuXG5pbmhlcml0cyhXYXJlaG91c2VlbWFuLCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBXYXJlaG91c2VlbWFuLnByb3RvdHlwZTtcblxucC5hZGRTdG9yYWdlID0gZnVuY3Rpb24gKHN0b3JhZ2UpIHtcblxuICAgIHN0b3JhZ2UuZmVhdHVyZXMgPSBzdG9yYWdlLmZlYXR1cmVzIHx8IHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydWUsXG4gICAgfTtcblxuICAgIHRoaXMuX3N0b3JhZ2VzLnB1c2goc3RvcmFnZSk7XG4gICAgdGhpcy5lbWl0KCdjaGFuZ2VTdG9yYWdlcycpO1xufTtcblxucC5zZWxlY3RTdG9yYWdlID0gZnVuY3Rpb24gKHN0b3JhZ2UpIHtcblxuICAgIGlmICh0aGlzLl9jdXJyU3RvcmFnZSA9PT0gc3RvcmFnZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY3VyclN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgaWYgKHN0b3JhZ2UuZmVhdHVyZXMucGxhY2Vob2xkZXIpIHtcblxuICAgICAgICBhbS5kaWFsb2dzLmZlYXR1cmVEb2VzbnRFeGlzdC5zaG93KCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdjaGFuZ2VDdXJyU3RvcmFnZScpO1xufTtcblxucC5zYXZlID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEsIHBhdGgpIHtcblxuICAgIHJldHVybiB0aGlzLl9jdXJyU3RvcmFnZS5zYXZlKG5hbWUsIGRhdGEsIHBhdGgpO1xufTtcblxucC5sb2FkID0gZnVuY3Rpb24gKG5hbWUsIHBhdGggICApIHtcblxuICAgIHJldHVybiB0aGlzLl9jdXJyU3RvcmFnZS5sb2FkKG5hbWUsIHBhdGgpO1xufTtcblxucC5ta2RpciA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fY3VyclN0b3JhZ2UubWtkaXIocGF0aCk7XG59O1xuXG5wLmRpciA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fY3VyclN0b3JhZ2UuZGlyKHBhdGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXYXJlaG91c2VlbWFuO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbWd1aSA9IHJlcXVpcmUoJy4uL2FtZ3VpJyk7XG5cbmZ1bmN0aW9uIGRlY29yRGlhbG9nKHdobSkge1xuXG4gICAgdmFyIGRpYWxvZywgZGVSb290LCBkZUxlZnQsIGRlSGVhZCwgZGVCcmVhZGNydW1icywgaW5wTmFtZSwgXG4gICAgICAgIGRlU3RvcmFnZVNlbGVjdG9yLCBkZURpcmVjdG9yeSwgYnRuTmV3Rm9sZGVyLCBpc0luaXRlZCwgZGVPcHRpb25zLFxuICAgICAgICBzZWxlY3RlZFBhdGggPSAnJywgc2VsZWN0ZWROYW1lID0gJycsIHNlbGVjdGVkRGF0YSA9ICcnLFxuICAgICAgICBvcGVuT3B0aW9ucyA9IHt9LCBtb2RlO1xuXG5cblxuICAgIHdobS5zaG93U2F2ZURpYWxvZyA9IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIGluaXQoKTtcblxuICAgICAgICBvcGVuT3B0aW9ucyA9IG9wdDtcbiAgICAgICAgbW9kZSA9ICdzYXZlJztcblxuICAgICAgICBzZWxlY3RlZE5hbWUgPSBvcHQubmFtZSB8fCAnJztcbiAgICAgICAgc2VsZWN0ZWREYXRhID0gb3B0LmRhdGEgfHwgJyc7XG4gICAgICAgIHNlbGVjdGVkUGF0aCA9IG9wdC5wYXRoIHx8ICcnO1xuXG4gICAgICAgIGlucE5hbWUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgZGlhbG9nLnNldFRpdGxlKCdTYXZlJyk7XG4gICAgICAgIGRpYWxvZy5zZXRCdXR0b25zKFsnc2F2ZScsICdjbG9zZSddKTtcbiAgICAgICAgZGVTdG9yYWdlU2VsZWN0b3IucmVmcmVzaCgpO1xuICAgICAgICByZWZyZXNoKCk7XG4gICAgICAgIGRpYWxvZy5zaG93TW9kYWwoKTtcbiAgICB9O1xuXG4gICAgd2htLnNob3dPcGVuRGlhbG9nID0gZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgIG9wZW5PcHRpb25zID0gb3B0O1xuICAgICAgICBtb2RlID0gJ29wZW4nO1xuXG4gICAgICAgIHNlbGVjdGVkTmFtZSA9IG9wdC5uYW1lIHx8ICcnO1xuICAgICAgICBzZWxlY3RlZFBhdGggPSBvcHQucGF0aCB8fCAnJztcblxuICAgICAgICBpbnBOYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgZGlhbG9nLnNldFRpdGxlKCdPcGVuJyk7XG4gICAgICAgIGRpYWxvZy5zZXRCdXR0b25zKFsnb3BlbicsICdjbG9zZSddKTtcbiAgICAgICAgZGVTdG9yYWdlU2VsZWN0b3IucmVmcmVzaCgpO1xuICAgICAgICByZWZyZXNoKCk7XG4gICAgICAgIGRpYWxvZy5zaG93TW9kYWwoKTtcbiAgICB9O1xuXG4gICAgd2htLnNldFNhdmVPdGlvbnMgPSBmdW5jdGlvbiAob3B0KSB7XG5cbiAgICAgICAgZGVPcHRpb25zLnNldE9wdGlvbnMob3B0KTtcbiAgICB9O1xuXG4gICAgd2htLmdldFNhdmVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiBkZU9wdGlvbnMuZ2V0T3B0aW9ucygpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmZWF0dXJlKG5hbWUpIHtcblxuICAgICAgICByZXR1cm4gd2htLl9jdXJyU3RvcmFnZS5mZWF0dXJlcyAmJlxuICAgICAgICAgICAgd2htLl9jdXJyU3RvcmFnZS5mZWF0dXJlc1tuYW1lXTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlQ3VyclN0b3JhZ2UoKSB7XG5cbiAgICAgICAgcmVmcmVzaCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZnJlc2goKSB7XG5cbiAgICAgICAgZGVCcmVhZGNydW1icy5yZWZyZXNoKCk7XG4gICAgICAgIGRlRGlyZWN0b3J5LnJlZnJlc2goKTtcbiAgICAgICAgZGVTdG9yYWdlU2VsZWN0b3IucmVmcmVzaFNlbGVjdGlvbigpO1xuICAgICAgICBpbnBOYW1lLnJlZnJlc2goKTtcblxuICAgICAgICBzaG93SGlkZShkZURpcmVjdG9yeSwgZmVhdHVyZSgnYnJvd3NlJykpO1xuICAgICAgICBzaG93SGlkZShkZUJyZWFkY3J1bWJzLCBmZWF0dXJlKCdicm93c2UnKSk7XG4gICAgICAgIHNob3dIaWRlKGJ0bk5ld0ZvbGRlciwgZmVhdHVyZSgnbWtkaXInKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2hvd0hpZGUoZGUsIHNob3cpIHtcblxuICAgICAgICAgICAgZGUuc3R5bGUuZGlzcGxheSA9IHNob3cgPyAnYmxvY2snIHx8IGRlLmJhc2VEaXNwbGF5IDogJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0ICgpIHtcblxuICAgICAgICBpZiAoaXNJbml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpc0luaXRlZCA9IHRydWU7XG5cbiAgICAgICAgY3JlYXRlRGlhbG9nKCk7XG4gICAgICAgIGNyZWF0ZVN0b3JhZ2VTZWxlY3RvcigpO1xuICAgICAgICBjcmVhdGVCcmVhZGNydW1icygpO1xuICAgICAgICBjcmVhdGVCdG5OZXdGb2xkZXIoKTtcbiAgICAgICAgY3JlYXRlQnRuU2V0dGluZ3MoKTtcbiAgICAgICAgY3JlYXRlTmFtZUlucHV0KCk7XG4gICAgICAgIGNyZWF0ZURpcmVjdG9yeSgpO1xuICAgICAgICBjcmVhdGVPcHRpb25zKCk7XG5cbiAgICAgICAgd2htLm9uKCdjaGFuZ2VDdXJyU3RvcmFnZScsIG9uQ2hhbmdlQ3VyclN0b3JhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU2F2ZSgpIHtcblxuICAgICAgICB2YXIgc2F2ZSA9IG9wZW5PcHRpb25zLmdldFNhdmUoKSxcbiAgICAgICAgICAgIG5hbWUgPSBzZWxlY3RlZE5hbWUgfHwgJ2FuaW0uYW0uanMnO1xuXG4gICAgICAgIHdobS5zYXZlKG5hbWUsIHNhdmUsIHNlbGVjdGVkUGF0aCk7XG5cbiAgICAgICAgb25DbG9zZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3BlbigpIHtcblxuICAgICAgICB2YXIgc2F2ZSA9IHdobS5sb2FkKHNlbGVjdGVkTmFtZSwgc2VsZWN0ZWRQYXRoKTtcblxuICAgICAgICBpZiAob3Blbk9wdGlvbnMub25PcGVuKSB7XG5cbiAgICAgICAgICAgIG9wZW5PcHRpb25zLm9uT3BlbihzYXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsb3NlKCkge1xuXG4gICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgIH1cblxuXG5cblxuXG5cblxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEaWFsb2cgKCkge1xuXG4gICAgICAgIGRlUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkZVJvb3Quc3R5bGUud2lkdGggPSAnNzAwcHgnO1xuICAgICAgICBkZVJvb3Quc3R5bGUuaGVpZ2h0ID0gJzQwMHB4JztcbiAgICAgICAgZGVSb290LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgIGRlUm9vdC5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XG5cbiAgICAgICAgZGVMZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlTGVmdC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIGRlTGVmdC5zdHlsZS5mbGV4ID0gJzEnO1xuICAgICAgICBkZUxlZnQuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgZGVMZWZ0LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcbiAgICAgICAgZGVSb290LmFwcGVuZENoaWxkKGRlTGVmdCk7XG5cbiAgICAgICAgZGVIZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlSGVhZC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgZGVIZWFkLnN0eWxlLmhlaWdodCA9ICcyMXB4JztcbiAgICAgICAgZGVIZWFkLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgIGRlTGVmdC5hcHBlbmRDaGlsZChkZUhlYWQpO1xuXG4gICAgICAgIGRpYWxvZyA9IGFtZ3VpLmNyZWF0ZURpYWxvZyh7XG4gICAgICAgICAgICBjb250ZW50OiBkZVJvb3QsXG4gICAgICAgICAgICBwYXJlbnQ6IGFtLmRlRGlhbG9nQ29udFxuICAgICAgICB9KTtcblxuICAgICAgICBkaWFsb2cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2tfc2F2ZScsIG9uU2F2ZSk7XG4gICAgICAgIGRpYWxvZy5hZGRFdmVudExpc3RlbmVyKCdjbGlja19vcGVuJywgb25PcGVuKTtcbiAgICAgICAgZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrX2Nsb3NlJywgb25DbG9zZSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCcmVhZGNydW1icygpIHtcblxuICAgICAgICBkZUJyZWFkY3J1bWJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlQnJlYWRjcnVtYnMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICBkZUJyZWFkY3J1bWJzLnN0eWxlLmZsZXggPSAnMSc7XG4gICAgICAgIGRlSGVhZC5hcHBlbmRDaGlsZChkZUJyZWFkY3J1bWJzKTtcblxuICAgICAgICBkZUJyZWFkY3J1bWJzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jcmFtYlZhbHVlKSB7XG5cbiAgICAgICAgICAgICAgICB3aG0uY2QodGhpcy5jcmFtYlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVCcmVhZGNydW1icy5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgY3J1bWJzID0gc2VsZWN0ZWRQYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG5cbiAgICAgICAgICAgIGRlQnJlYWRjcnVtYnMuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNyZWF0ZUNydW1iKCh3aG0uX2N1cnJTdG9yYWdlLnJvb3ROYW1lIHx8ICdyb290JykgKyAnOi8vJywgdmFsdWUpO1xuXG4gICAgICAgICAgICBjcnVtYnMuZm9yRWFjaChmdW5jdGlvbiAoY3J1bWJOYW1lKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjcnVtYk5hbWUgKyAnLyc7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ3J1bWIoY3J1bWJOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY3JlYXRlU2xhc2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNsYXNoKCkge1xuXG4gICAgICAgICAgICB2YXIgZGVTbGFzaCA9IGNyZWF0ZUxpKCcgLyAnKTtcbiAgICAgICAgICAgIGRlU2xhc2guc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICAgICAgcmV0dXJuIGRlU2xhc2g7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDcnVtYihjb250ZW50LCB2YWx1ZSkge1xuXG4gICAgICAgICAgICB2YXIgZGVDaHJ1bWIgPSBjcmVhdGVMaShjb250ZW50KTtcbiAgICAgICAgICAgIGRlQ2hydW1iLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICBkZUNocnVtYi5jcnVtYlZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBkZUNocnVtYjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTGkoY29udGVudCkge1xuXG4gICAgICAgICAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBsaS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGRlQnJlYWRjcnVtYnMuYXBwZW5kQ2hpbGQobGkpO1xuXG4gICAgICAgICAgICByZXR1cm4gbGk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQnRuU2V0dGluZ3MoKSB7XG5cbiAgICAgICAgYnRuTmV3Rm9sZGVyID0gYW1ndWkuY3JlYXRlSWNvbkJ0bih7XG4gICAgICAgICAgICBwYXJlbnQ6IGRlSGVhZCxcbiAgICAgICAgICAgIGljb246ICd3cmVuY2gnLFxuICAgICAgICAgICAgd2lkdGg6IDIxLFxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlT3B0aW9ucy50b2dnbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJ0bk5ld0ZvbGRlcigpIHtcblxuICAgICAgICBidG5OZXdGb2xkZXIgPSBhbWd1aS5jcmVhdGVJY29uQnRuKHtcbiAgICAgICAgICAgIHBhcmVudDogZGVIZWFkLFxuICAgICAgICAgICAgaWNvbjogJ2ZvbGRlci1hZGQnLFxuICAgICAgICAgICAgd2lkdGg6IDIxXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5hbWVJbnB1dCgpIHtcblxuICAgICAgICBpbnBOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wTmFtZS50eXBlID0gJ3RleHQnO1xuICAgICAgICBpbnBOYW1lLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBpbnBOYW1lLnN0eWxlLmhlaWdodCA9ICcyMXB4JztcbiAgICAgICAgaW5wTmFtZS5zdHlsZS5iYWNrZ3JvdW5kID0gJ25vbmUnO1xuICAgICAgICBpbnBOYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgaW5wTmFtZS5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgICAgIGlucE5hbWUuc3R5bGUuZm9udFNpemUgPSBhbWd1aS5GT05UX1NJWkU7XG4gICAgICAgIGlucE5hbWUuc3R5bGUuZm9udEZhbWlseSA9IGFtZ3VpLkZPTlRfRkFNSUxZO1xuICAgICAgICBpbnBOYW1lLnBsYWNlaG9sZGVyID0gJ0ZpbGUgbmFtZSc7XG4gICAgICAgIGRlTGVmdC5hcHBlbmRDaGlsZChpbnBOYW1lKTtcblxuICAgICAgICBpbnBOYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgc2VsZWN0ZWROYW1lID0gaW5wTmFtZS52YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW5wTmFtZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAoaW5wTmFtZS52YWx1ZSAhPT0gc2VsZWN0ZWROYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBpbnBOYW1lLnZhbHVlID0gc2VsZWN0ZWROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGlyZWN0b3J5KCkge1xuXG4gICAgICAgIGRlRGlyZWN0b3J5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlRGlyZWN0b3J5LnN0eWxlLmxpc3RTdHlsZSA9ICdub25lJztcbiAgICAgICAgZGVEaXJlY3Rvcnkuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICBkZURpcmVjdG9yeS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgZGVEaXJlY3Rvcnkuc3R5bGUuZmxleCA9ICcxJztcbiAgICAgICAgZGVMZWZ0LmFwcGVuZENoaWxkKGRlRGlyZWN0b3J5KTtcblxuICAgICAgICBkZURpcmVjdG9yeS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZURpcmVjdG9yeS5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgaWYgKCFmZWF0dXJlKCdicm93c2UnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpc3QgPSB3aG0uZGlyKCk7XG5cbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXG4gICAgICAgICAgICAgICAgY3JlYXRlSXRlbShpdGVtLm5hbWUsIGl0ZW0udHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZW0obmFtZSwgdHlwZSkge1xuXG4gICAgICAgICAgICB2YXIgZGVJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkZUl0ZW0uX3ZhbHVlID0gbmFtZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYW1ndWkuY3JlYXRlSWNvbih7XG4gICAgICAgICAgICAgICAgaWNvbjogdHlwZSA9PT0gJ2ZvbGRlcicgPyAnZm9sZGVyLWVtcHR5JyA6ICdkb2MnLFxuICAgICAgICAgICAgICAgIHBhcmVudDogZGVJdGVtLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGRlTmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGRlTmFtZS50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICBkZUl0ZW0uYXBwZW5kQ2hpbGQoZGVOYW1lKTtcblxuICAgICAgICAgICAgZGVEaXJlY3RvcnkuYXBwZW5kQ2hpbGQoZGVJdGVtKTtcblxuICAgICAgICAgICAgZGVJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljayk7XG4gICAgICAgICAgICBkZUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBvbkNsaWNrKTtcbiAgICAgICAgICAgIGRlSXRlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBvbk1PdmVyKTtcbiAgICAgICAgICAgIGRlSXRlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG9uTU91dCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZUl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2VsZWN0ZWROYW1lID0gdGhpcy5fdmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdkYmxjbGljaycpIHtcblxuICAgICAgICAgICAgICAgIG9uT3BlbihzZWxlY3RlZFBhdGgsIHNlbGVjdGVkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1PdmVyKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmJhY2tncm91bmQgPSBhbWd1aS5jb2xvci5iZ0hvdmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25NT3V0KCkge1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmJhY2tncm91bmQgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTdG9yYWdlU2VsZWN0b3IoKSB7XG5cbiAgICAgICAgdmFyIGJ0blNpemUgPSA1MiwgYnV0dG9ucyA9IFtdO1xuXG4gICAgICAgIGRlU3RvcmFnZVNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlU3RvcmFnZVNlbGVjdG9yLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgZGVTdG9yYWdlU2VsZWN0b3Iuc3R5bGUud2lkdGggPSBidG5TaXplICsgJ3B4JztcbiAgICAgICAgZGVTdG9yYWdlU2VsZWN0b3Iuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBkZVJvb3QuaW5zZXJ0QmVmb3JlKGRlU3RvcmFnZVNlbGVjdG9yLCBkZUxlZnQpO1xuXG4gICAgICAgIGRlU3RvcmFnZVNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgdmFyIGlkeCA9IGUudGFyZ2V0Ll9zdG9yYWdlSWR4O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaWR4ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIHdobS5zZWxlY3RTdG9yYWdlKHdobS5fc3RvcmFnZXNbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUJ1dHRvbnMoKSB7XG5cbiAgICAgICAgICAgIGJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYnRuKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoYnRuLmRvbUVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBidG4uZG9tRWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJ0bi5kb21FbGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBidG4uZG9tRWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2tCdG4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZVN0b3JhZ2VTZWxlY3Rvci5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZW1vdmVCdXR0b25zKCk7XG5cbiAgICAgICAgICAgIHdobS5fc3RvcmFnZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZmVhdHVyZXMucGxhY2Vob2xkZXIgfHwgc3RvcmFnZS5mZWF0dXJlc1ttb2RlXSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUl0ZW0oc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlU3RvcmFnZVNlbGVjdG9yLnJlZnJlc2hTZWxlY3Rpb24oKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkZVN0b3JhZ2VTZWxlY3Rvci5yZWZyZXNoU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBidXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGJ0bikge1xuXG4gICAgICAgICAgICAgICAgaWYgKGJ0bi5zdG9yYWdlID09PSB3aG0uX2N1cnJTdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYnRuLmRvbUVsZW0uZml4SGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidG4uZG9tRWxlbS5yZW1vdmVGaXhIaWdobGlnaHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrQnRuKGUpIHtcblxuICAgICAgICAgICAgYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChidG4pIHtcblxuICAgICAgICAgICAgICAgIGlmIChidG4uZG9tRWxlbSA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgd2htLnNlbGVjdFN0b3JhZ2UoYnRuLnN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gIFxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVJdGVtKHN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgdmFyIGJ0biA9IHtcbiAgICAgICAgICAgICAgICBkb21FbGVtOiBhbWd1aS5jcmVhdGVJY29uQnRuKHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogc3RvcmFnZS5pY29uLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGRlU3RvcmFnZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYnRuU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBidG5TaXplLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogb25DbGlja0J0bixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBzdG9yYWdlOiBzdG9yYWdlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhbWd1aS5hZGRUb29sdGlwKHtcbiAgICAgICAgICAgICAgICBkZVRhcmdldDogYnRuLmRvbUVsZW0sIFxuICAgICAgICAgICAgICAgIHRleHQ6IHN0b3JhZ2UudG9vbHRpcFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaChidG4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlT3B0aW9ucygpIHtcblxuICAgICAgICB2YXIgaXNPcGVuZWQgPSBmYWxzZTtcblxuICAgICAgICBkZU9wdGlvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGVPcHRpb25zLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRlT3B0aW9ucy5zdHlsZS53aWR0aCA9ICcxMzhweCc7XG4gICAgICAgIGRlT3B0aW9ucy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIGRlUm9vdC5hcHBlbmRDaGlsZChkZU9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBjaGVja1NhdmUgPSBjcmVhdGVDaGVja2JveCgnaW5jbHVkZSBzYXZlJywgdHJ1ZSk7XG4gICAgICAgIHZhciBjaGVja01pbmlmeSA9IGNyZWF0ZUNoZWNrYm94KCdtaW5pZnknKTtcbiAgICAgICAgdmFyIGNoZWNrQXV0byA9IGNyZWF0ZUNoZWNrYm94KCdhdXRvIHBsYXknLCB0cnVlKTtcblxuICAgICAgICBkZU9wdGlvbnMuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlU2F2ZTogY2hlY2tTYXZlLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgbWluaWZ5OiBjaGVja01pbmlmeS5jaGVja2VkLFxuICAgICAgICAgICAgICAgIGF1dG9QbGF5OiBjaGVja0F1dG8uY2hlY2tlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBkZU9wdGlvbnMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHQpIHtcblxuICAgICAgICAgICAgY2hlY2tTYXZlLmNoZWNrZWQgPSBvcHQuaW5jbHVkZVNhdmU7XG4gICAgICAgICAgICBjaGVja01pbmlmeS5jaGVja2VkID0gb3B0Lm1pbmlmeTtcbiAgICAgICAgICAgIGNoZWNrQXV0by5jaGVja2VkID0gb3B0LmF1dG9QbGF5O1xuICAgICAgICB9O1xuXG4gICAgICAgIGRlT3B0aW9ucy50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlzT3BlbmVkID0gIWlzT3BlbmVkO1xuXG4gICAgICAgICAgICBkZU9wdGlvbnMuc3R5bGUuZGlzcGxheSA9IGlzT3BlbmVkID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDaGVja2JveChuYW1lLCBjaGVja2VkKSB7XG5cbiAgICAgICAgICAgIHZhciBkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGVPcHRpb25zLmFwcGVuZENoaWxkKGRlKTtcblxuICAgICAgICAgICAgdmFyIGNiID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGNiLnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgY2IuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgICAgICBkZS5hcHBlbmRDaGlsZChjYik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbC5zdHlsZS5jb2xvciA9IGFtZ3VpLmNvbG9yLnRleHQ7XG4gICAgICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICBkZS5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29yRGlhbG9nO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiBEb3dubG9hZChvcHQpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdGhpcy5fcm9vdCA9IG9wdC5yb290IHx8ICdfRG93bmxvYWQvJztcblxuICAgIHRoaXMuaWNvbiA9ICdkb3dubG9hZCc7XG4gICAgdGhpcy50b29sdGlwID0gJ0Rvd25sb2FkJztcbn1cblxuaW5oZXJpdHMoRG93bmxvYWQsIEV2ZW50RW1pdHRlcik7XG52YXIgcCA9IERvd25sb2FkLnByb3RvdHlwZTtcblxucC5mZWF0dXJlcyA9IHtcbiAgICBzYXZlOiB0cnVlLFxufTtcblxucC5zYXZlID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcblxuICAgIGRhdGEgPSAnZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0O2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhKTtcbiAgICAkKCc8YSBkb3dubG9hZD1cIicgKyBuYW1lICsgJ1wiIGhyZWY9XCInICsgZGF0YSArICdcIj48L2E+JylbMF0uY2xpY2soKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRG93bmxvYWQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIEZPTERFUlMgPSAnPGZvbGRlcnM+JztcblxuZnVuY3Rpb24gUGFnZVNjcmlwdChvcHQpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdGhpcy5fcm9vdCA9IG9wdC5yb290IHx8ICdfUGFnZVNjcmlwdC8nO1xuXG4gICAgdGhpcy5pY29uID0gJ2NvZGUnO1xuICAgIHRoaXMudG9vbHRpcCA9ICdydW5uaW5nIEFuaW1hY2hpbmUgcGFnZXNjcmlwdHMnO1xuXG4gICAgdGhpcy5fZm9sZGVycyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLl9yb290ICsgRk9MREVSUyk7XG4gICAgXG4gICAgdHJ5IHsgXG4gICAgICAgIHRoaXMuZm9sZGVycyA9IEpTT04ucGFyc2UodGhpcy5fZm9sZGVycyk7IFxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLl9mb2xkZXJzID0gW107XG4gICAgfVxufVxuXG5pbmhlcml0cyhQYWdlU2NyaXB0LCBFdmVudEVtaXR0ZXIpO1xudmFyIHAgPSBQYWdlU2NyaXB0LnByb3RvdHlwZTtcblxucC5zYXZlID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEsIHBhdGgpIHtcblxuICAgIG5hbWUgPSB0aGlzLl92YWxpZE5hbWUobmFtZSk7XG4gICAgXG4gICAgdGhpcy5ta2RpcihwYXRoKTtcbiAgICB0aGlzLl9zZXQocGF0aCArIG5hbWUsIGRhdGEpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG5wLm9wZW4gPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgaWYgKG5hbWUgaW4gcGFnZVNjcmlwdHMoKSkge1xuXG4gICAgICAgIHJldHVybiBwYWdlU2NyaXB0cygpW25hbWVdO1xuICAgIH1cbn07XG5cbnAuZGlyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgT2JqZWN0LmtleXMocGFnZVNjcmlwdHMoKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIHBhZ2VTY3JpcHRzKCkge1xuXG4gICAgcmV0dXJuICh3aW5kb3cuYW0gJiYgd2luZG93LmFtLnBhZ2VTY3JpcHRzKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlU2NyaXB0OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBST09UID0gJ193ZWJzdG9yYWdlbWFuLycsIFxuICAgIEZPTERFUlMgPSAnPGZvbGRlcnM+JztcblxuZnVuY3Rpb24gV2ViU3RvcmFnZW1hbihvcHQpIHtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdGhpcy5pY29uID0gJ2J1bGxzZXllJztcbiAgICB0aGlzLnJvb3ROYW1lID0gJ3dlYnN0b3JhZ2UnO1xuICAgIHRoaXMudG9vbHRpcCA9ICd3ZWJzdG9yYWdlLCBzdG9yZSBkYXRhIGluIHlvdXIgYnJvd3Nlcic7XG5cbiAgICB0aGlzLl9mb2xkZXJzID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFJPT1QgKyBGT0xERVJTKTtcbiAgICBcbiAgICB0cnkgeyBcbiAgICAgICAgdGhpcy5fZm9sZGVycyA9IEpTT04ucGFyc2UodGhpcy5fZm9sZGVycyk7IFxuICAgIH1cbiAgICBjYXRjaCAoZSkge31cblxuICAgIGlmICghKHRoaXMuX2ZvbGRlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcblxuICAgICAgICB0aGlzLl9mb2xkZXJzID0gW107XG4gICAgfSBcbn1cblxuaW5oZXJpdHMoV2ViU3RvcmFnZW1hbiwgRXZlbnRFbWl0dGVyKTtcbnZhciBwID0gV2ViU3RvcmFnZW1hbi5wcm90b3R5cGU7XG5cbnAuZmVhdHVyZXMgPSB7XG4gICAgc2F2ZTogdHJ1ZSxcbiAgICBvcGVuOiB0cnVlLFxuICAgIGJyb3dzZTogdHJ1ZSxcbn07XG5cblxucC5zYXZlID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEsIHBhdGgpIHtcblxuICAgIG5hbWUgPSB0aGlzLl92YWxpZE5hbWUobmFtZSk7XG4gICAgcGF0aCA9IHRoaXMuX3ZhbGlkUGF0aChwYXRoKTtcbiAgICBcbiAgICB0aGlzLm1rZGlyKHBhdGgpO1xuICAgIHRoaXMuX3NldChwYXRoICsgbmFtZSwgZGF0YSk7XG5cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cbnAubG9hZCA9IGZ1bmN0aW9uIChuYW1lLCBwYXRoKSB7XG5cbiAgICBuYW1lID0gdGhpcy5fdmFsaWROYW1lKG5hbWUpO1xuICAgIHBhdGggPSB0aGlzLl92YWxpZFBhdGgocGF0aCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuX2dldChwYXRoICsgbmFtZSk7XG59O1xuXG5wLm1rZGlyID0gZnVuY3Rpb24gKHBhdGgpIHtcblxuICAgIHBhdGggPSB0aGlzLl92YWxpZFBhdGgocGF0aCkuc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICB2YXIgZm9sZGVyUGF0aCA9ICcnO1xuXG4gICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChmb2xkZXIpIHtcblxuICAgICAgICB0aGlzLl9hZGRGb2xkZXIoZm9sZGVyICsgJy8nKTtcblxuICAgIH0sIHRoaXMpO1xufTtcblxucC5kaXIgPSBmdW5jdGlvbiAocGF0aCkge1xuXG4gICAgcGF0aCA9IFJPT1QgKyB0aGlzLl92YWxpZFBhdGgocGF0aCk7XG5cbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBPYmplY3Qua2V5cyh3aW5kb3cubG9jYWxTdG9yYWdlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoRk9MREVSUykgPT09IC0xKSB7XG5cbiAgICAgICAgICAgIHRlc3RLZXkoa2V5LCAnZmlsZScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9mb2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcblxuICAgICAgICB0ZXN0S2V5KFJPT1QgKyBwYXRoLnNsaWNlKDAsIC0xKSwgJ2ZvbGRlcicpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcblxuICAgIGZ1bmN0aW9uIHRlc3RLZXkoa2V5LCB0eXBlKSB7XG5cbiAgICAgICAgaWYgKGtleS5pbmRleE9mKHBhdGgpID09PSAwKSB7XG5cbiAgICAgICAgICAgIGtleSA9IGtleS5zdWJzdHIocGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJy8nKSA9PT0gLTEpIHtcblxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5wLl9hZGRGb2xkZXIgPSBmdW5jdGlvbihwYXRoKSB7XG5cbiAgICBpZiAodGhpcy5fZm9sZGVycy5pbmRleE9mKHBhdGgpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZm9sZGVycy5wdXNoKHBhdGgpO1xuXG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFJPT1QgKyBGT0xERVJTLCBKU09OLnN0cmluZ2lmeSh0aGlzLl9mb2xkZXJzKSk7XG59O1xuXG5wLl9zZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG5cbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFJPT1QgKyBwYXRoLCBkYXRhKTtcbn07XG5cbnAuX2dldCA9IGZ1bmN0aW9uKHBhdGgpIHtcblxuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oUk9PVCArIHBhdGgpO1xufTtcblxucC5fdmFsaWRQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGguY2hhckF0KHBhdGgubGVuZ3RoLTEpICE9PSAnLycgJiYgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG5wLl92YWxpZE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC88fFxcLy9nLCAnXycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTdG9yYWdlbWFuOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gQmxvY2sob3B0KSB7XG5cbiAgICB0aGlzLl9jcmVhdGVEb21FbGVtKCk7XG5cbiAgICB0aGlzLnNpemUgPSBvcHQuc2l6ZTtcbiAgICB0aGlzLnNjYWxlTW9kZSA9IG9wdC5zY2FsZU1vZGU7XG59XG5cbnZhciBwID0gQmxvY2sucHJvdG90eXBlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cbiAgICBzaXplOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NpemUgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGVNb2RlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjYWxlTW9kZSA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9zY2FsZU1vZGUgPSB2O1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlTW9kZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5wLl9yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGZsZXggPSAnJywgd2lkdGggPSAnJywgaGVpZ2h0ID0gJyc7IFxuXG4gICAgaWYgKHRoaXMuc2NhbGVNb2RlID09PSAnZml4Jykge1xuXG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdyb3cnKSB7XG5cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5zaXplICsgJ3B4JzsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLnNpemUgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVNb2RlID09PSAnZmxleCcpIHtcblxuICAgICAgICBmbGV4ID0gdGhpcy5zaXplO1xuICAgIH1cblxuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLmZsZXggPSBmbGV4O1xufTtcblxucC5fY3JlYXRlRG9tRWxlbSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZG9tRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUuYWxpZ25JdGVtcyA9ICdzdHJldGNoJztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2s7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmxvY2sgPSByZXF1aXJlKCcuL0Jsb2NrJyk7XG52YXIgUGFuZWwgPSByZXF1aXJlKCcuL1BhbmVsJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIGFtZ3VpID0gcmVxdWlyZSgnLi4vYW1ndWknKTtcblxuZnVuY3Rpb24gQ29udGFpbmVyKG9wdCkge1xuXG4gICAgQmxvY2suY2FsbCh0aGlzLCBvcHQpO1xuXG4gICAgdGhpcy5kaXJlY3Rpb24gPSBvcHQuZGlyZWN0aW9uIHx8ICdyb3cnO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdGhpcy5fZGVIYW5kbGVycyA9IFtdO1xuXG4gICAgb3B0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNEYXRhKSB7XG5cbiAgICAgICAgaWYgKGNEYXRhLnR5cGUgPT09ICdjb250YWluZXInKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQobmV3IENvbnRhaW5lcihjRGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNEYXRhLnR5cGUgPT09ICdwYW5lbCcpIHtcblxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChuZXcgUGFuZWwoY0RhdGEpKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xufVxuXG5pbmhlcml0cyhDb250YWluZXIsIEJsb2NrKTtcbnZhciBwID0gQ29udGFpbmVyLnByb3RvdHlwZTtcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cbiAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSB2O1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnAuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcblxuICAgIHRoaXMuYWRkQ2hpbGRBdChjaGlsZCwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKTtcbn07XG5cbnAuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG4gICAgdGhpcy5fcmVmcmVzaENoaWxkcmVuKCk7XG4gICAgdGhpcy5fcmVmcmVzaEhhbmRsZXJzKCk7XG59O1xuXG5wLmZpbmRUYWIgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgdmFyIHRhYjtcblxuICAgIHRoaXMuX2NoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG5cbiAgICAgICAgdGFiID0gY2hpbGQuZmluZFRhYihuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRhYjtcbiAgICB9KTtcblxuICAgIHJldHVybiB0YWI7XG59O1xuXG5cblxucC5fZ2V0RnVsbEZsZXggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYnIgPSB0aGlzLmRvbUVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGZ1bGwgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3JvdycgPyBici53aWR0aCA6IGJyLmhlaWdodDtcblxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG5cbiAgICAgICAgaWYgKGNoaWxkLnNjYWxlTW9kZSA9PT0gJ2ZpeCcpIHtcblxuICAgICAgICAgICAgZnVsbCAtPSBjaGlsZC5zaXplO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVsbDtcbn07XG5cbnAuX3JlZnJlc2hDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmRvbUVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQuZG9tRWxlbSk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5wLl9yZWZyZXNoSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgaSwgZGVIYW5kbGVyLCBuY0JyLCBcbiAgICAgICAgdGhpY2tuZXNzID0gNCxcbiAgICAgICAgYnIgPSB0aGlzLmRvbUVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMTsgKytpKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9kZUhhbmRsZXJzW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9kZUhhbmRsZXJzLnB1c2godGhpcy5fY3JlYXRlSGFuZGxlcigpKVxuICAgICAgICB9XG5cbiAgICAgICAgbmNCciA9IHRoaXMuX2NoaWxkcmVuW2krMV0uZG9tRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgZGVIYW5kbGVyID0gdGhpcy5fZGVIYW5kbGVyc1tpXTtcblxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdyb3cnKSB7XG5cbiAgICAgICAgICAgIGRlSGFuZGxlci5zdHlsZS5sZWZ0ID0gKG5jQnIubGVmdCAtIGJyLmxlZnQgLSB0aGlja25lc3MvMikgKyAncHgnO1xuICAgICAgICAgICAgZGVIYW5kbGVyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgZGVIYW5kbGVyLnN0eWxlLndpZHRoID0gdGhpY2tuZXNzICsgJ3B4JztcbiAgICAgICAgICAgIGRlSGFuZGxlci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZUhhbmRsZXIuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgZGVIYW5kbGVyLnN0eWxlLnRvcCA9IChuY0JyLnRvcCAtIGJyLnRvcCAtIHRoaWNrbmVzcy8yKSArICdweCc7XG4gICAgICAgICAgICBkZUhhbmRsZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICBkZUhhbmRsZXIuc3R5bGUuaGVpZ2h0ID0gdGhpY2tuZXNzICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2RlSGFuZGxlcnMuc3BsaWNlKGkpLmZvckVhY2goZnVuY3Rpb24gKGRlSGFuZGxlcikge1xuXG4gICAgICAgIGRlSGFuZGxlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRlSGFuZGxlcik7XG4gICAgfSlcbn07XG5cblxuXG5cblxuXG5wLl9vbkRyYWdIYW5kbGVyID0gZnVuY3Rpb24gKG1kLCBteCwgbXkpIHtcblxuICAgIHZhciBtb3ZlID0gdGhpcy5kaXJlY3Rpb24gPT09ICdyb3cnID8gbXggLSBtZC5teCA6IG15IC0gbWQubXksXG4gICAgICAgIG1vdmVGbGV4ID0gbW92ZSAvIHRoaXMuX2dldEZ1bGxGbGV4KCksXG4gICAgICAgIHByZXZDaGlsZCA9IHRoaXMuX2NoaWxkcmVuW21kLmlkeF0sXG4gICAgICAgIG5leHRDaGlsZCA9IHRoaXMuX2NoaWxkcmVuW21kLmlkeCArIDFdO1xuXG4gICAgcHJldkNoaWxkLnNpemUgPSBtZC5wcmV2Q2hpbGRTaXplIC0gKHByZXZDaGlsZC5zY2FsZU1vZGUgPT09ICdmaXgnID8gbW92ZSA6IG1vdmVGbGV4KTtcbiAgICBuZXh0Q2hpbGQuc2l6ZSA9IG1kLm5leHRDaGlsZFNpemUgLSAobmV4dENoaWxkLnNjYWxlTW9kZSA9PT0gJ2ZpeCcgPyBtb3ZlIDogbW92ZUZsZXgpO1xufVxuXG5cblxuXG5wLl9jcmVhdGVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgYW1ndWkubWFrZURyYWdnYWJsZSh7XG4gICAgICAgIGRlVGFyZ2V0OiBkZSxcbiAgICAgICAgdGhpc0FyZzogdGhpcyxcbiAgICAgICAgb25Eb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkeDogdGhpcy5fZGVIYW5kbGVycy5pbmRleE9mKGRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbk1vdmU6IHRoaXMuX29uRHJhZ0hhbmRsZXIsXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlLnN0eWxlLmJhY2tncm91bmQgPSAnI2ZmZic7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5kb21FbGVtLmFwcGVuZENoaWxkKGRlKTtcblxuICAgIHJldHVybiBkZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUYWIgPSByZXF1aXJlKCcuL1RhYicpO1xudmFyIGFtZ3VpID0gcmVxdWlyZSgnLi4vYW1ndWknKTtcbnZhciBCbG9jayA9IHJlcXVpcmUoJy4vQmxvY2snKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmZ1bmN0aW9uIFBhbmVsKG9wdCkge1xuXG4gICAgQmxvY2suY2FsbCh0aGlzLCBvcHQpO1xuXG4gICAgdGhpcy5fdGFicyA9IFtdO1xuXG4gICAgdGhpcy5fY3JlYXRlVGFiQmFzZSgpO1xuXG4gICAgdGhpcy5fZW1wdHkgPSBmYWxzZTtcbiAgICB0aGlzLl9jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ub0hlYWQgPSB0cnVlO1xuXG4gICAgaWYgKCdlbXB0eScgaW4gb3B0KSB0aGlzLmVtcHR5ID0gb3B0LmVtcHR5O1xuICAgIGlmICgnY29sbGFwc2VkJyBpbiBvcHQpIHRoaXMuY29sbGFwc2VkID0gb3B0LmNvbGxhcHNlZDtcbiAgICBpZiAoJ25vSGVhZCcgaW4gb3B0KSB0aGlzLm5vSGVhZCA9IG9wdC5ub0hlYWQ7XG5cbiAgICBpZiAob3B0LnRhYnMpIHtcbiAgICAgICAgb3B0LnRhYnMuZm9yRWFjaCh0aGlzLmFkZFRhYiwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90YWJzLnNvbWUoZnVuY3Rpb24gKHRhYikge3JldHVybiB0YWIuc2VsZWN0ZWQ7fSkgJiZcbiAgICAgICAgdGhpcy5fdGFicy5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aGlzLl90YWJzWzBdLnNlbGVjdCgpO1xuICAgIH1cbn1cblxuaW5oZXJpdHMoUGFuZWwsIEJsb2NrKTtcbnZhciBwID0gUGFuZWwucHJvdG90eXBlO1xubW9kdWxlLmV4cG9ydHMgPSBQYW5lbDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXG4gICAgZW1wdHk6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuXG4gICAgICAgICAgICB2ID0gISF2O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtcHR5ID09PSB2KSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuX2VtcHR5ID0gdjtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gdGhpcy5fZW1wdHkgPyAnbm9uZScgOiAnYXV0byc7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW0uc3R5bGUudmlzaWJpbGl0eSA9IHRoaXMuX2VtcHR5ID8gJ2hpZGRlbicgOiAndmlzaWJpbGUnO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbXB0eTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY29sbGFwc2VkOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgdiA9ICEhdjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsYXBzZWQgPT09IHYpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5fY29sbGFwc2VkID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2RlVGFiQmFzZS5zdHlsZS5kaXNwbGF5ID0gdGhpcy5fY29sbGFwc2VkID8gJ25vbmUnIDogJ2ZsZXgnO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG5vSGVhZDoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG5cbiAgICAgICAgICAgIHYgPSAhIXY7XG4gICAgICAgICAgICBpZiAodGhpcy5fbm9IZWFkID09PSB2KSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuX25vSGVhZCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9kZVRhYkhlYWQuc3R5bGUuZGlzcGxheSA9IHRoaXMuX25vSGVhZCA/ICdub25lJyA6ICdmbGV4JztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9IZWFkO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnAuYWRkVGFiID0gZnVuY3Rpb24gKHREYXRhKSB7XG5cbiAgICB2YXIgdGFiID0gbmV3IFRhYih0RGF0YSk7XG4gICAgdGhpcy5fZGVUYWJIZWFkLmFwcGVuZENoaWxkKHRhYi5kZUVhcik7XG4gICAgdGhpcy5fZGVUYWJDb250ZW50LmFwcGVuZENoaWxkKHRhYi5kb21FbGVtKTtcbiAgICB0aGlzLl90YWJzLnB1c2godGFiKTtcbn07XG5cblxucC5maW5kVGFiID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgIHZhciB0YWI7XG5cbiAgICB0aGlzLl90YWJzLnNvbWUoZnVuY3Rpb24gKHQpIHtcblxuICAgICAgICBpZiAodC5uYW1lID09PSBuYW1lKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAodGFiID0gdCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YWI7XG59O1xuXG5wLnNob3dUYWIgPSBmdW5jdGlvbiAodGFiKSB7XG5cbiAgICB0aGlzLl90YWJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgXG4gICAgICAgIGlmICh0YWIgPT09IHQpIHtcbiAgICAgICAgICAgIHQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0LmRlc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbnAuX2NyZWF0ZVRhYkJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9kZVRhYkJhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9kZVRhYkJhc2Uuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5fZGVUYWJCYXNlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLl9kZVRhYkJhc2Uuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB0aGlzLl9kZVRhYkJhc2Uuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdjb2x1bW4nO1xuICAgIHRoaXMuZG9tRWxlbS5hcHBlbmRDaGlsZCh0aGlzLl9kZVRhYkJhc2UpO1xuXG4gICAgdGhpcy5fZGVUYWJIZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fZGVUYWJIZWFkLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuX2RlVGFiSGVhZC5zdHlsZS5oZWlnaHQgPSAnMjNweCc7XG4gICAgdGhpcy5fZGVUYWJIZWFkLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgdGhpcy5fZGVUYWJIZWFkLnN0eWxlLmFsaWduSXRlbXMgPSAnc3RyZXRjaCc7XG4gICAgdGhpcy5fZGVUYWJIZWFkLnN0eWxlLmJhY2tncm91bmQgPSBhbWd1aS5jb2xvci5iZzE7XG4gICAgaWYgKHRoaXMuX3Nob3dIZWFkKSB7XG4gICAgICAgIHRoaXMuX2RlVGFiQmFzZS5hcHBlbmRDaGlsZCh0aGlzLl9kZVRhYkhlYWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlVGFiQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX2RlVGFiQ29udGVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLl9kZVRhYkNvbnRlbnQuc3R5bGUuZmxleCA9IDE7XG4gICAgdGhpcy5fZGVUYWJCYXNlLmFwcGVuZENoaWxkKHRoaXMuX2RlVGFiQ29udGVudCk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gVGFiKG9wdCkge1xuXG4gICAgdGhpcy5uYW1lID0gb3B0Lm5hbWU7XG4gICAgdGhpcy5zZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuICAgIHRoaXMuX2NyZWF0ZURvbUVsZW0oKTtcbiAgICB0aGlzLmRlRWFyID0gdGhpcy5fY3JlYXRlVGFiRWFyKCk7XG5cbiAgICB0aGlzW3RoaXMuc2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICdkZXNlbGVjdCddKCk7XG59XG5cbnZhciBwID0gVGFiLnByb3RvdHlwZTtcblxucC5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGRlQ29udGVudCkge1xuXG4gICAgdGhpcy5kb21FbGVtLmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuZG9tRWxlbS5hcHBlbmRDaGlsZChkZUNvbnRlbnQpO1xufTtcblxucC5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5kZUVhci5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9ICcycHgnO1xufTtcblxucC5kZXNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuZGVFYXIuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSAnMXB4Jztcbn07XG5cbnAuX2NyZWF0ZURvbUVsZW0gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRvbUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLmRvbUVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICdyZ2JhKDAsMCwwLDAuMyknO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xufTtcblxucC5fY3JlYXRlVGFiRWFyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGUudGV4dENvbnRlbnQgPSB0aGlzLm5hbWU7XG4gICAgZGUuc3R5bGUuZmxleCA9IDE7XG4gICAgZGUuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgIGRlLnN0eWxlLmJvcmRlckJvdHRvbSA9ICdzb2xpZCAxcHggd2hpdGUnO1xuICAgIGRlLnN0eWxlLmFsaWduSXRlbXMgPSAnc3RyZXRjaCc7XG5cbiAgICByZXR1cm4gZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250YWluZXIgPSByZXF1aXJlKCcuL0NvbnRhaW5lcicpO1xuXG5mdW5jdGlvbiBXaW5kb29tYW4oKSB7XG5cbiAgICB0aGlzLl90YWJNYXAgPSB7fTtcbiAgICB0aGlzLl93b3Jrc3BhY2VzID0ge307XG5cbiAgICB0aGlzLl9jcmVhdGVEb21FbGVtKCk7XG59XG5cbnZhciBwID0gV2luZG9vbWFuLnByb3RvdHlwZTtcblxucC5sb2FkV29ya3NwYWNlcyA9IGZ1bmN0aW9uICh3b3Jrc3BhY2VzKSB7XG5cbiAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlc1tuYW1lXSA9IHdvcmtzcGFjZXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG59O1xuXG5wLmxvYWQgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgdmFyIG1hcCA9IHRoaXMuX3dvcmtzcGFjZXNbbmFtZV07XG5cbiAgICBpZiAoIW1hcCB8fCBtYXAudHlwZSAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NhblxcJ3QgbG9hZCAnICsgbWFwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yb290ID0gbmV3IENvbnRhaW5lcihtYXApO1xuICAgIFxuICAgIHRoaXMuZG9tRWxlbS5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLmRvbUVsZW0uYXBwZW5kQ2hpbGQodGhpcy5fcm9vdC5kb21FbGVtKTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3RhYk1hcCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgICAgIHRoaXMucGxhY2VUYWIobmFtZSwgdGhpcy5fdGFiTWFwW25hbWVdKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbnAuZmluZFRhYiA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICBpZiAodGhpcy5fcm9vdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LmZpbmRUYWIobmFtZSk7XG4gICAgfVxufTtcblxucC5maWxsVGFiID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcblxuICAgIHRoaXMuX3RhYk1hcFtuYW1lXSA9IGNvbnRlbnQ7XG5cbiAgICB2YXIgdGFiID0gdGhpcy5maW5kVGFiKG5hbWUpO1xuXG4gICAgaWYgKHRhYikge1xuICAgICAgICB0YWIuc2V0Q29udGVudChjb250ZW50KTtcbiAgICB9XG59O1xuXG5wLl9jcmVhdGVEb21FbGVtID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kb21FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb21FbGVtLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuZG9tRWxlbS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG59O1xuXG5wLl9jYWxjQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZG9vbWFuOyJdfQ==
